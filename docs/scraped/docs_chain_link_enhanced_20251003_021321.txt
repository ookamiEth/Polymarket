# Mintlify Documentation Export
Source: https://docs.chain.link/data-streams
Platform: Mintlify (confidence: 0.1)
Exported: 2025-10-03 02:13:21
Total Pages: 101
Failed Pages: 7

================================================================================

## Table of Contents

1. [Chainlink Documentation](https://docs.chain.link/> Chainlink is the backbone of blockchain. It is the standard for onchain finance, verifiable data, and cross-chain interoperability. It unifies liquidity across global markets and has enabled over $20 trillion in transaction value across the blockchain economy. Major financial institutions like Swift, Fidelity International, and ANZ Bank, as well as top DeFi protocols such as Aave, GMX, and Lido, utilize Chainlink to power next-generation applications in banking, asset management, and other sectors.)
2. [Chainlink Developer Docs](https://docs.chain.link/)
3. [Chainlink CCIP - Cross-Chain Interoperability Protocol](https://docs.chain.link/ccip)
4. [Getting Started with Chainlink CCIP](https://docs.chain.link/ccip/getting-started)
5. [CCIP API Reference](https://docs.chain.link/ccip/api-reference)
6. [CCIP Architecture](https://docs.chain.link/ccip/architecture)
7. [CCIP Best Practices](https://docs.chain.link/ccip/best-practices)
8. [CCIP Billing](https://docs.chain.link/ccip/billing)
9. [CCIP Concepts](https://docs.chain.link/ccip/concepts)
10. [Cross-Chain Token Standard](https://docs.chain.link/ccip/concepts/cross-chain-tokens)
11. [CCIP Directory](https://docs.chain.link/ccip/directory/mainnet)
12. [CCIP Directory](https://docs.chain.link/ccip/directory/testnet)
13. [Example Cross-chain dApps](https://docs.chain.link/ccip/examples)
14. [Changelog and Releases | Chainlink](https://docs.chain.link/ccip/release-notes)
15. [CCIP Test Tokens - Faucets for EVM and Solana](https://docs.chain.link/ccip/test-tokens)
16. [ChainlinkCCIP Tutorials](https://docs.chain.link/ccip/tutorials)
17. [Cross-Chain Token (CCT) Tutorials](https://docs.chain.link/ccip/tutorials/cross-chain-tokens)
18. [Transfer Tokens with Data](https://docs.chain.link/ccip/tutorials/programmable-token-transfers)
19. [Transfer Tokens with Data - Defensive Example](https://docs.chain.link/ccip/tutorials/programmable-token-transfers-defensive)
20. [Send Arbitrary Data](https://docs.chain.link/ccip/tutorials/send-arbitrary-data)
21. [Transfer Tokens Between Chains from Smart Contracts](https://docs.chain.link/ccip/tutorials/transfer-tokens-from-contract)
22. [Transfer USDC with Data](https://docs.chain.link/ccip/tutorials/usdc)
23. [Chainlink Data Feeds](https://docs.chain.link/data-feeds)
24. [Data Feeds API Reference](https://docs.chain.link/data-feeds/api-reference)
25. [Developer Responsibilities: Market Integrity and Application Code Risks](https://docs.chain.link/data-feeds/developer-responsibilities)
26. [Consuming Data Feeds](https://docs.chain.link/data-feeds/getting-started)
27. [Getting Historical Data](https://docs.chain.link/data-feeds/historical-data)
28. [L2 Sequencer Uptime Feeds](https://docs.chain.link/data-feeds/l2-sequencer-feeds)
29. [Price Feeds](https://docs.chain.link/data-feeds/price-feeds)
30. [Price Feed Contract Addresses](https://docs.chain.link/data-feeds/price-feeds/addresses)
31. [SmartData](https://docs.chain.link/data-feeds/proof-of-reserve)
32. [SmartData Feed Addresses](https://docs.chain.link/data-feeds/proof-of-reserve/addresses)
33. [Rate and Volatility Feeds](https://docs.chain.link/data-feeds/rates-feeds)
34. [Rate and Volatility Feed Addresses](https://docs.chain.link/data-feeds/rates-feeds/addresses)
35. [Selecting Quality Data Feeds](https://docs.chain.link/data-feeds/selecting-data-feeds)
36. [Data Feeds on Solana](https://docs.chain.link/data-feeds/solana)
37. [Using Data Feeds on EVM Chains](https://docs.chain.link/data-feeds/using-data-feeds)
38. [Chainlink Data Streams](https://docs.chain.link/data-streams)
39. [Getting Started with Chainlink Data Streams (Remix)](https://docs.chain.link/data-streams/getting-started)
40. [Data Streams Billing](https://docs.chain.link/data-streams/billing)
41. [Data Streams Crypto streams](https://docs.chain.link/data-streams/stream-ids)
42. [Chainlink Automation](https://docs.chain.link/chainlink-automation)
43. [Getting Started with Chainlink Automation](https://docs.chain.link/chainlink-automation/overview/getting-started)
44. [Automation Billing and Costs](https://docs.chain.link/chainlink-automation/overview/automation-economics)
45. [Supported Networks](https://docs.chain.link/chainlink-automation/overview/supported-networks)
46. [Create Automation-Compatible Contracts](https://docs.chain.link/chainlink-automation/guides/compatible-contracts)
47. [Create a Time-Based Upkeep](https://docs.chain.link/chainlink-automation/guides/job-scheduler)
48. [Chainlink Functions](https://docs.chain.link/chainlink-functions)
49. [Getting Started](https://docs.chain.link/chainlink-functions/getting-started)
50. [Chainlink Functions Architecture](https://docs.chain.link/chainlink-functions/resources/architecture)
51. [Chainlink Functions Billing](https://docs.chain.link/chainlink-functions/resources/billing)
52. [Supported Networks](https://docs.chain.link/chainlink-functions/supported-networks)
53. [Call an API with HTTP Query Parameters](https://docs.chain.link/chainlink-functions/tutorials/api-query-parameters)
54. [Request Computation](https://docs.chain.link/chainlink-functions/tutorials/simple-computation)
55. [Chainlink VRF](https://docs.chain.link/vrf)
56. [Getting Started with Chainlink VRF V2.5](https://docs.chain.link/vrf/v2-5/getting-started)
57. [VRF Billing](https://docs.chain.link/vrf/v2-5/billing)
58. [Migrating from VRF v2](https://docs.chain.link/vrf/v2-5/migration-from-v2)
59. [Subscription Method](https://docs.chain.link/vrf/v2-5/overview/subscription)
60. [Create and manage VRF V2.5 subscriptions](https://docs.chain.link/vrf/v2-5/subscription/create-manage)
61. [Get a Random Number](https://docs.chain.link/vrf/v2-5/subscription/get-a-random-number)
62. [Supported Networks](https://docs.chain.link/vrf/v2-5/supported-networks)
63. [Decentralized Data Model](https://docs.chain.link/architecture-overview/architecture-decentralized-model)
64. [Data Feeds Architecture](https://docs.chain.link/architecture-overview/architecture-overview)
65. [Basic Request Model](https://docs.chain.link/architecture-overview/architecture-request-model)
66. [Offchain Reporting](https://docs.chain.link/architecture-overview/off-chain-reporting)
67. [Chainlink Nodes](https://docs.chain.link/chainlink-nodes)
68. [Configuring Nodes](https://docs.chain.link/chainlink-nodes/configuring-nodes)
69. [Job Types](https://docs.chain.link/chainlink-nodes/oracle-jobs/all-jobs)
70. [Task Types](https://docs.chain.link/chainlink-nodes/oracle-jobs/all-tasks)
71. [Requirements](https://docs.chain.link/chainlink-nodes/resources/requirements)
72. [Fulfilling Requests](https://docs.chain.link/chainlink-nodes/v1/fulfilling-requests)
73. [Node Config (TOML)](https://docs.chain.link/chainlink-nodes/v1/node-config)
74. [Running a Chainlink Node](https://docs.chain.link/chainlink-nodes/v1/running-a-chainlink-node)
75. [Deploy Your First Smart Contract](https://docs.chain.link/quickstarts/deploy-your-first-contract)
76. [Foundry Chainlink Toolkit](https://docs.chain.link/quickstarts/foundry-chainlink-toolkit)
77. [Historical Price Feeds API](https://docs.chain.link/quickstarts/historical-price-feeds-api)
78. [The hub for Chainlink developers](https://docs.chain.link/getting-started/other-tutorials)
79. [Getting Started with Any API](https://docs.chain.link/any-api/getting-started)
80. [Chainlink Any API Documentation](https://docs.chain.link/any-api/introduction)
81. [ChainlinkClient API Reference](https://docs.chain.link/any-api/api-reference)
82. [Make a GET Request](https://docs.chain.link/any-api/get-request/introduction)
83. [Single Word Response](https://docs.chain.link/any-api/get-request/examples/single-word-response)
84. [Testnet Oracles](https://docs.chain.link/any-api/testnet-oracles)
85. [Courses | Chainlink Certifications](https://dev.chain.link/certification)
86. [Smart Contract Overview](https://docs.chain.link/getting-started/conceptual-overview)
87. [Acquire testnet LINK](https://docs.chain.link/resources/acquire-link)
88. [Cross-chain bridges and associated risks](https://docs.chain.link/resources/bridge-risks)
89. [Install Frameworks](https://docs.chain.link/resources/create-a-chainlinked-project)
90. [Developer Communications](https://docs.chain.link/resources/developer-communications)
91. [Fund Your Contracts](https://docs.chain.link/resources/fund-your-contract)
92. [Hackathon Resources](https://docs.chain.link/resources/hackathon-resources)
93. [LINK Token Contracts](https://docs.chain.link/resources/link-token-contracts)
94. [Integrating EVM Networks With Chainlink Services](https://docs.chain.link/resources/network-integration)
95. [Faucets](https://faucets.chain.link/)
96. [PegSwap](https://pegswap.chain.link/)
97. [Metrics | Chainlink](https://metrics.chain.link/)
98. [Staking](https://staking.chain.link/)
99. [Chainlink Local](https://docs.chain.link/chainlink-local)
100. [functions-toolkit](https://www.npmjs.com/package/@chainlink/functions-toolkit)
101. [Search code, repositories, users, issues, pull requests...](https://github.com/smartcontractkit/ccip-javascript-sdk)

================================================================================

# Chainlink Documentation

Source: https://docs.chain.link/> Chainlink is the backbone of blockchain. It is the standard for onchain finance, verifiable data, and cross-chain interoperability. It unifies liquidity across global markets and has enabled over $20 trillion in transaction value across the blockchain economy. Major financial institutions like Swift, Fidelity International, and ANZ Bank, as well as top DeFi protocols such as Aave, GMX, and Lido, utilize Chainlink to power next-generation applications in banking, asset management, and other sectors.
Extraction Method: playwright

## 404

## Page not found
We're sorry, but we couldn't find the page you were looking for. You can select a section from the top of the
      page, or browse the links on the left. If you followed a broken link, let us know
, or send a PR on GitHub

================================================================================

# Chainlink Developer Docs

Source: https://docs.chain.link/
Extraction Method: playwright

# Chainlink Developer Docs

## What are you building?
[CCIPGlobal standard for building secure cross-chain applications.](/ccip)[Data FeedsDecentralized and high-quality data for DeFi, sports, weather, and more.](/data-feeds)[Data StreamsSecure and reliable high-frequency market data for ultra-fast derivatives products.](/data-streams)[FunctionsServerless platform that fetches data from any API & runs custom compute.](/chainlink-functions)[AutomationReliable, high-performance, decentralized automation for smart contracts.](/chainlink-automation)[VRFVerifiable, tamper-proof random number generator for blockchain gaming and NFTs.](/vrf)[DataLinkInstitutional-grade data publishing solution for specialized market data onchain.](/datalink)[DTATechnical standard for subscriptions, redemptions, and settlements.](/dta-technical-standard)
#### Recommended reading

## We think you'd love to explore
[General](/getting-started/conceptual-overview)[Link Token Contracts](/resources/link-token-contracts)[Getting Started with CCIP](/ccip/getting-started)[CCIP Directory](/ccip/directory)[Data Feed Addresses](/data-feeds/price-feeds/addresses)[SmartData Feed Addresses](/data-feeds/smartdata/addresses)[Getting Started with Data Streams](/data-streams/getting-started-hardhat)[Data Streams Addresses](/data-streams/crypto-streams)

================================================================================

# Chainlink CCIP - Cross-Chain Interoperability Protocol

Source: https://docs.chain.link/ccip
Extraction Method: playwright
Components: table(1)

# Chainlink CCIP - Cross-Chain Interoperability Protocol
[Image: note]Talk to a CCIP expert

If you require technical advice or wish to consult on your project's implementation, please contact a CCIP expert. Our
dedicated team is ready to support your projects and ensure their success. For expert guidance, visit the Chainlink
CCIP Contact form.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }Blockchain interoperability protocols are important for the Web3 ecosystem and traditional systems that need to interact with different blockchains. These protocols are the foundation for building blockchain abstraction layers, allowing traditional backends and dApps to interact with any blockchain network through a single middleware solution. Without a blockchain interoperability protocol, Web2 systems and dApps would need to build separate in-house implementations for each cross-chain interaction that they want to use, which is a time-consuming, resource-intensive, and complex process.

Blockchain interoperability protocols provide the following capabilities:

• You can transfer assets and information across multiple blockchains.
• Application developers can leverage the strengths and benefits of different chains.
• Collaboration between developers from diverse blockchain ecosystems enables the building of cross-chain applications to serve more users and provide additional features or products for them.

The Chainlink Cross-Chain Interoperability Protocol (CCIP) provides these capabilities and enables a variety of use cases.

## What is Chainlink CCIP?
Chainlink CCIP is a blockchain interoperability protocol that enables developers to build secure applications that can transfer tokens, messages (data), or both tokens and messages across chains.

Given the inherent risks of cross-chain interoperability, CCIP features defense-in-depth security and is powered by Chainlink's industry-standard oracle networks which have a proven track record of securing tens of billions of dollars and enabling over $14 trillion in onchain transaction value.

CCIP provides several key security benefits:

• Multiple independent nodes run by independent key holders.
• Three decentralized networks all executing and verifying every cross-chain transaction.
• Separation of responsibilities, with distinct sets of node operators, and with no nodes shared between the transactional DONs and the Risk Management Network.
• Increased decentralization with two separate code bases across two different implementations, written in two different languages to create a previously unseen diversity of software clients in the cross-chain world.
• Novel risk management system with level-5 security that can be rapidly adapted to any new risks or attacks that appear in cross-chain messaging.

astro-island,astro-slot,astro-static-slot{display:contents}(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).only=e;window.dispatchEvent(new Event("astro:only"));})();(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();[Image: Chainlink CCIP Architecture]To understand how Chainlink CCIP works, refer to the architecture section. If you are new to using Chainlink CCIP, read these guides before you deploy any contracts that use CCIP.

## Chainlink CCIP core capabilities
Chainlink CCIP supports three main capabilities:

### Arbitrary Messaging
The ability to send arbitrary data (encoded as bytes) to a receiving smart contract on a different blockchain. The developer is free to encode any data they wish to send.

Typically, developers use arbitrary messaging to trigger an informed action on the receiving smart contract, such as rebalancing an index, minting a specific NFT, or calling an arbitrary function with the sent data as custom parameters. Developers can encode multiple instructions in a single message, enabling them to orchestrate complex, multi-step, multi-chain tasks.

### Token Transfer
The ability to transfer tokens to an account on a different blockchain. This capability enables the seamless movement of assets across chains.

### Programmable Token Transfer
The ability to simultaneously transfer tokens and arbitrary data (encoded as bytes) within a single transaction. This mechanism allows users to transfer tokens and send instructions on what to do with those tokens.

For example, a user could transfer tokens to a lending protocol with instructions to leverage those tokens as collateral for a loan, borrowing another asset to be sent back to the user.

### Receiving account types
With CCIP, you send transactions with data (arbitrary messaging), tokens, or both data and tokens (programmable token transfer). The receiver of a CCIP transaction varies by blockchain family:

CCIP capability | What is sent | Receiving account types
--- | --- | ---
Arbitrary Messaging | Data | EVM: Smart contracts onlySVM: Programs only
Token Transfer | Tokens | EVM: Smart contracts and EOAsSVM: User wallets or program-controlled PDAs
Programmable Token Transfer | Data and tokens | EVM: Smart contracts onlySVM: Data to programs, tokens to program-controlled PDAs

Note: On EVM chains, EOAs cannot receive messages. On Solana (SVM), programs work with Program Derived Addresses (PDAs) to manage token reception.

## Common use cases
Chainlink CCIP enables a variety of use cases:

• Cross-chain lending: Chainlink CCIP enables users to lend and borrow a wide range of crypto assets across multiple DeFi platforms running on independent chains.
• Low-cost transaction computation: Chainlink CCIP can help offload the computation of transaction data on cost-optimized chains.
• Optimizing cross-chain yield: Users can leverage Chainlink CCIP to move collateral to new DeFi protocols to maximize yield across chains.
• Creating new kinds of dApps: Chainlink CCIP enables users to take advantage of network effects on certain chains while harnessing compute and storage capabilities of other chains.

Read What Are Cross-Chain Smart Contracts to learn about cross-chain smart contracts and examples of use cases they enable.

## CCIP Directory
See the CCIP Directory page for a list of supported networks, tokens, and contract addresses.

To learn about tokens, token pools, and the token onboarding process, see the CCIP Architecture page.

================================================================================

# Getting Started with Chainlink CCIP

Source: https://docs.chain.link/ccip/getting-started
Extraction Method: playwright

# Getting Started with Chainlink CCIP

## Available Blockchain Families
CCIP supports multiple blockchain families:

• EVM: Send messages and tokens between Ethereum, Avalanche, Polygon, and other EVM-compatible networks
• SVM: Connect Solana with other chain families through CCIP

Check the CCIP Directory for a list of supported blockchains.

## What You Can Build with CCIP

• Cross-Chain dApps: Create applications that operate seamlessly across multiple blockchains
• Token Bridges: Transfer tokens between different blockchain networks
• Cross-Chain Data Messaging: Send arbitrary data between smart contracts on different chains
• Programmable Token Transfers: Combine token transfers with messaging to trigger specific actions on destination chains

## Getting Started Guides
Choose your starting point based on your blockchain platform:

• Getting Started with CCIP on EVM Chains - Learn how to deploy sender/receiver contracts and send messages between EVM chains
• Getting Started with CCIP on Solana (SVM)

================================================================================

# CCIP API Reference

Source: https://docs.chain.link/ccip/api-reference
Extraction Method: playwright

# CCIP API Reference
Chainlink Cross-Chain Interoperability Protocol (CCIP) provides secure cross-chain messaging and token transfers between blockchain networks.

• EVM-based Blockchains: Complete API reference for CCIP on Ethereum Virtual Machine (EVM) compatible blockchains.
• Solana: Complete API reference for CCIP on Solana.
• Aptos Blockchain: Complete API reference for CCIP on the Aptos blockchain.

================================================================================

# CCIP Architecture

Source: https://docs.chain.link/ccip/architecture
Extraction Method: playwright

# CCIP Architecture
This section explains the core architecture of the Cross-Chain Interoperability Protocol (CCIP). Learn about the fundamental components and how they interact to enable secure cross-chain communication.

• Overview: Get a high-level summary of the CCIP architecture.
• Key Concepts: Understand the essential terms and components within the CCIP ecosystem.
• Onchain Components: Explore the on‑chain components, including EVM smart contracts and Solana programs, and Aptos modules, that operate directly on blockchains.
• Offchain Components: Discover the offchain systems, like the Risk Management Network and Decentralized Oracle Network, that support CCIP operations.

================================================================================

# CCIP Best Practices

Source: https://docs.chain.link/ccip/best-practices
Extraction Method: playwright

# CCIP Best Practices
This section outlines recommended practices for using Chainlink CCIP effectively and securely.

• EVM Best Practices: Recommended guidelines for interacting with CCIP on EVM-compatible chains.
• SVM Best Practices: Recommended guidelines for interacting with CCIP on SVM-based chains like Solana.
• Aptos Best Practices: Recommended guidelines for interacting with CCIP on Aptos chain.

================================================================================

# CCIP Billing

Source: https://docs.chain.link/ccip/billing
Extraction Method: playwright
Components: code_block(5), table(2)

# CCIP Billing
[Image: note]Prerequisites

Read the CCIP Introduction and Concepts to understand all the concepts discussed on this
page.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }The CCIP billing model uses the feeToken specified in the message to pay a single fee on the source blockchain. CCIP uses a gas-locked fee payment mechanism to help ensure the reliable execution of cross-chain transactions regardless of destination blockchain gas spikes. For developers, this means you can simply pay on the source blockchain and CCIP will take care of execution on the destination blockchain.

CCIP supports fee payments in LINK and in alternative assets, including blockchain-native gas tokens and their ERC-20 wrapped versions. The payment model for CCIP is designed to significantly reduce friction for users and quickly scale CCIP to more blockchains by supporting fee payments that originate across a multitude of blockchains over time.

Aside from billing, remember to carefully estimate the gasLimit that you set for your destination contract so CCIP can have enough gas to execute ccipReceive(), if applicable. Any unspent gas from this user-set limit is not refunded.

## Billing mechanism
The fee is calculated by the following formula:

[Image: copy to clipboard]
```plaintext
fee = blockchain fee + network fee
```

Where:

• fee: The total fee for processing a CCIP message. Note: Users can call the getFee function to estimate the fee.
• blockchain fee: This represents an estimation of the gas cost the node operators will pay to deliver the CCIP message to the destination blockchain.
• network fee: Fee paid to CCIP service providers, including node operators running the Decentralized Oracle Network and Risk Management Network.

### Blockchain fee
The blockchain fee is calculated by the following formula:

[Image: copy to clipboard]
```plaintext
blockchain fee = execution cost + data availability cost
```

#### Execution cost
The execution cost is directly correlated with the estimated gas usage to execute the transaction on the destination blockchain:

[Image: copy to clipboard]
```plaintext
execution cost = gas price * gas usage * gas multiplier
```

Where:

• gas price: The destination gas price. CCIP maintains a cache of destination gas prices on each source blockchain, denominated in each feeToken.
• gas multiplier: Scaling factor. This multiplier ensures the reliable execution of transactions regardless of destination blockchain gas spikes.
• gas usage:
gas usage = gas limit + destination gas overhead + destination gas per payload + gas for token transfers`

Where:

gas limit: This specifies the maximum amount of gas CCIP can consume to execute ccipReceive() on the receiver contract located on the destination blockchain. Users set the gas limit in the extra argument field of the CCIP message. Note: Remember to carefully estimate the gasLimit that you set for your destination contract so CCIP can have enough gas to execute ccipReceive(). Any unspent gas from this user-set limit is not refunded.
destination gas overhead: This is the fixed gas cost incurred on the destination blockchain by CCIP (Committing DON + Executing DON) and Risk Management Network.
destination gas per payload: This variable gas depends on the length of the data field in the CCIP message. If there is no payload (CCIP only transfers tokens), the value is 0.
gas for token transfers: This variable gas cost is for transferring tokens onto the destination blockchain. If there are no token transfers, the value is 0.

#### Data availability cost
This cost is only relevant if the destination blockchain is a L2 layer. Some L2s charge fees for data availability. For instance, optimistic rollups process the transactions offchain then post the transaction data to Ethereum as calldata, which costs additional gas.

### Network fee
The fee paid to CCIP service providers, including node operators running the Decentralized Oracle Network and Risk Management Network is calculated as follows:

#### Token transfers or programmable token transfers
For token transfers or programmable token transfers (token + data), the network fee varies based on the token handling mechanism and the lanes:

• Lock and Unlock: The network fee is percentage-based. For each token, it is calculated using the following expression:
tokenAmount * price * percentage

Where:

tokenAmount: The amount of tokens being transferred.
price: Initially priced in USD and converted into the feeToken.
percentage: The values are provided in the network fee table.
• Lock and Mint, Burn and Mint and Burn and Unlock: The network fee is a static amount. See the network fee table.
      Determine Token Handling Mechanism  Use the calculator below or consult the CCIP Directory on the
mainnet or (/ccip/directory/testnet) pages to determine a token's handling mechanism on a
given lane.

#### Messaging (only data)
For messaging (only data): The network fee is a static amount, denominated in USD. See the network fee table.

#### Network fee table
The table below provides an overview of the network fees charged for different use cases on different lanes. Percentage-based fees are calculated on the value transferred in a message. USD-denominated fees are applied per message.

Use case | Token Pool Mechanism | Lanes | Fee Token
--- | --- | --- | ---
LINK | Others
Token Transfers Programmable Token Transfers | Lock and Unlock | All Lanes | 0.063 % | 0.07 %
Lock and MintBurn and MintBurn and Unlock | Non-Ethereum | 0.225 USD | 0.25 USD
From: Ethereum | 0.45 USD | 0.50 USD
To: Ethereum | 1.35 USD | 1.50 USD
Messaging | N/A | Non-Ethereum | 0.09 USD | 0.10 USD
From/To: Ethereum | 0.45 USD | 0.50 USD

You can use the calculator below to learn the network fees for a specific token. Select the environment (mainnet/testnet), the token, the source blockchain, and the destination blockchain to get the network fee:

astro-island,astro-slot,astro-static-slot{display:contents}(()=>{var l=(n,t)=>{let i=async()=>{await(await n())()},e=typeof t.value=="object"?t.value:void 0,s={timeout:e==null?void 0:e.timeout};"requestIdleCallback"in window?window.requestIdleCallback(i,s):setTimeout(i,s.timeout||200)};(self.Astro||(self.Astro={})).idle=l;window.dispatchEvent(new Event("astro:idle"));})();(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();Calculate
Token | Mechanism | Fee Token
--- | --- | ---
LINK | Others
 |  |  |

================================================================================

# CCIP Concepts

Source: https://docs.chain.link/ccip/concepts
Extraction Method: playwright

# CCIP Concepts
This section explores the foundational concepts of the Cross-Chain Interoperability Protocol (CCIP). Understanding these concepts will help you effectively build and deploy secure cross-chain applications.

• Architecture: Understand the core components and structure of CCIP, including onchain and offchain systems.
• Cross-Chain Token Standard: Learn about the Cross-Chain Token (CCT) standard that enables secure token transfers across different blockchains.
• Best Practices: Discover recommended guidelines for using CCIP effectively and securely on both EVM and SVM blockchains.
• Manual Execution: Learn why some CCIP messages might require manual execution and how to handle these situations.

================================================================================

# Cross-Chain Token Standard

Source: https://docs.chain.link/ccip/concepts/cross-chain-tokens
Extraction Method: playwright

# Cross-Chain Token Standard
This section explains the Cross-Chain Token (CCT) standard, a Chainlink CCIP feature enabling secure and reliable cross-chain token transfers. Learn how to make your tokens compatible with CCIP.

• Overview: Get a high-level summary of the CCT standard and its benefits.
• EVM Tokens: Guidance for integrating tokens on EVM-compatible blockchains.
• SVM Tokens: Guidance for integrating tokens on SVM-based blockchains like Solana.

================================================================================

# CCIP Directory

Source: https://docs.chain.link/ccip/directory/mainnet
Extraction Method: playwright

(()=>{var a=(s,i,o)=>{let r=async()=>{await(await s())()},t=typeof i.value=="object"?i.value:void 0,c={rootMargin:t==null?void 0:t.rootMargin},n=new IntersectionObserver(e=>{for(let l of e)if(l.isIntersecting){n.disconnect(),r();break}},c);for(let e of o.children)n.observe(e)};(self.Astro||(self.Astro={})).visible=a;window.dispatchEvent(new Event("astro:visible"));})();
# CCIP Directory
[Image: Search icon]
## Networks mainnet (64)
$[0G5 lanes | 2 tokens](/ccip/directory/mainnet/chain/0g-mainnet)[Abstract1 lane | 0 token](/ccip/directory/mainnet/chain/abstract-mainnet)[Apechain4 lanes | 0 token](/ccip/directory/mainnet/chain/apechain-mainnet)[Aptos Mainnet7 lanes | 3 tokens](/ccip/directory/mainnet/chain/aptos-mainnet)[Arbitrum One32 lanes | 76 tokens](/ccip/directory/mainnet/chain/ethereum-mainnet-arbitrum-1)[Astar2 lanes | 5 tokens](/ccip/directory/mainnet/chain/polkadot-mainnet-astar)[Avalanche20 lanes | 29 tokens](/ccip/directory/mainnet/chain/avalanche-mainnet)[B²3 lanes | 2 tokens](/ccip/directory/mainnet/chain/bitcoin-mainnet-bsquared-1)[Base31 lanes | 91 tokens](/ccip/directory/mainnet/chain/ethereum-mainnet-base-1)[Berachain9 lanes | 11 tokens](/ccip/directory/mainnet/chain/berachain-mainnet)[Bitlayer4 lanes | 5 tokens](/ccip/directory/mainnet/chain/bitcoin-mainnet-bitlayer-1)[Blast4 lanes | 5 tokens](/ccip/directory/mainnet/chain/ethereum-mainnet-blast-1)[BNB Chain29 lanes | 63 tokens](/ccip/directory/mainnet/chain/bsc-mainnet)[BOB14 lanes | 7 tokens](/ccip/directory/mainnet/chain/bitcoin-mainnet-bob-1)See more/$
## Tokens (182)
[Add my token](/ccip/tutorials/evm/token-manager#verifying-your-token)$[$PAAL](/ccip/directory/mainnet/token/$PAAL)[1XMM](/ccip/directory/mainnet/token/1XMM)[AISTR](/ccip/directory/mainnet/token/AISTR)[ANIMA](/ccip/directory/mainnet/token/ANIMA)[APRS](/ccip/directory/mainnet/token/APRS)[APU](/ccip/directory/mainnet/token/APU)[avETH](/ccip/directory/mainnet/token/avETH)[avETHx](/ccip/directory/mainnet/token/avETHx)[AXS](/ccip/directory/mainnet/token/AXS)[BANANA](/ccip/directory/mainnet/token/BANANA)[BARD](/ccip/directory/mainnet/token/BARD)[beraBTC](/ccip/directory/mainnet/token/beraBTC)[BETS](/ccip/directory/mainnet/token/BETS)[BMX](/ccip/directory/mainnet/token/BMX)[BOLD](/ccip/directory/mainnet/token/BOLD)[BONE](/ccip/directory/mainnet/token/BONE)[BR](/ccip/directory/mainnet/token/BR)[brBTC](/ccip/directory/mainnet/token/brBTC)[BTR](/ccip/directory/mainnet/token/BTR)[BYTES](/ccip/directory/mainnet/token/BYTES)[CANNED](/ccip/directory/mainnet/token/CANNED)[CGX](/ccip/directory/mainnet/token/CGX)[CHIKA](/ccip/directory/mainnet/token/CHIKA)[CKP](/ccip/directory/mainnet/token/CKP)See more/$

================================================================================

# CCIP Directory

Source: https://docs.chain.link/ccip/directory/testnet
Extraction Method: playwright

(()=>{var a=(s,i,o)=>{let r=async()=>{await(await s())()},t=typeof i.value=="object"?i.value:void 0,c={rootMargin:t==null?void 0:t.rootMargin},n=new IntersectionObserver(e=>{for(let l of e)if(l.isIntersecting){n.disconnect(),r();break}},c);for(let e of o.children)n.observe(e)};(self.Astro||(self.Astro={})).visible=a;window.dispatchEvent(new Event("astro:visible"));})();
# CCIP Directory
[Image: Search icon]
## Networks testnet (70)
$[0G Galileo Testnet1 lane | 0 token](/ccip/directory/testnet/chain/0g-testnet-galileo)[Abstract Sepolia1 lane | 1 token](/ccip/directory/testnet/chain/abstract-testnet)[Apechain Curtis1 lane | 1 token](/ccip/directory/testnet/chain/apechain-testnet-curtis)[Aptos Testnet6 lanes | 1 token](/ccip/directory/testnet/chain/aptos-testnet)[Arbitrum Sepolia16 lanes | 3 tokens](/ccip/directory/testnet/chain/ethereum-testnet-sepolia-arbitrum-1)[Astar Shibuya2 lanes | 2 tokens](/ccip/directory/testnet/chain/polkadot-testnet-astar-shibuya)[Avalanche Fuji13 lanes | 3 tokens](/ccip/directory/testnet/chain/avalanche-fuji-testnet)[B² Testnet2 lanes | 1 token](/ccip/directory/testnet/chain/bitcoin-testnet-bsquared-1)[Base Sepolia18 lanes | 3 tokens](/ccip/directory/testnet/chain/ethereum-testnet-sepolia-base-1)[Berachain Bartio1 lane | 0 token](/ccip/directory/testnet/chain/berachain-testnet-bartio)[Bitlayer Testnet3 lanes | 0 token](/ccip/directory/testnet/chain/bitcoin-testnet-bitlayer-1)[Blast Sepolia2 lanes | 2 tokens](/ccip/directory/testnet/chain/ethereum-testnet-sepolia-blast-1)[BNB Chain Testnet14 lanes | 2 tokens](/ccip/directory/testnet/chain/bsc-testnet)[BOB Sepolia1 lane | 1 token](/ccip/directory/testnet/chain/bitcoin-testnet-sepolia-bob-1)See more/$
## Tokens (3)
[Add my token](/ccip/tutorials/evm/token-manager#verifying-your-token)$[CCIP-BnM](/ccip/directory/testnet/token/CCIP-BnM)[CCIP-LnM](/ccip/directory/testnet/token/CCIP-LnM)[USDC](/ccip/directory/testnet/token/USDC)/$

================================================================================

# Example Cross-chain dApps

Source: https://docs.chain.link/ccip/examples
Extraction Method: playwright

# Example Cross-chain dApps
[Image: note]Talk to a CCIP expert

If you require technical advice or wish to consult on your project's implementation, please contact a CCIP expert. Our
dedicated team is ready to support your projects and ensure their success. For expert guidance, visit the Chainlink
CCIP Contact form.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }Several example dApps and tools are available to help you learn about use cases for CCIP.

## CCIP Direct Staking
CCIP Direct Staking enables users to stake native tokens on supported L2 networks and receive liquid staked tokens (LSTs, e.g., wstETH) directly on the same chain. Supports both instant (fast) and delayed (slow) staking options.

Learn more about the architecture and workflow in the technical blog post.

For third-party integrators who want to build offchain components to interact with CCIP Direct Staking contracts, see the Direct Staking integration guide with reference implementations and utilities. The guide includes a hands-on tutorial using Lido on Base Mainnet.

## CCIP Starter Kits
The CCIP Starter Kits demonstrate how to transfer tokens and send messages using the HardHat or Foundry frameworks.

• HardHat CCIP Starter Kit
• Foundry CCIP Starter Kit

## CCIP Tic Tac Toe
CCIP Tic Tac Toe demonstrates how to build a gaming dApp that operates across multiple blockchain networks.

## Cross-chain name service
The Cross-chain Name Service is an educational example of how to create a minimal cross-chain name service using Chainlink CCIP.

## DeFi lending
The DeFi Lending examples shows how a cross-chain lending application can work using CCIP.

## DeFi liquidation protection
The DeFi liquidation protection example shows how a DeFi dApp can use CCIP to prevent liquidation when lending assets across multiple blockchain networks.

## Cross Chain NFT
The Cross Chain NFT example shows you how to mint an NFT on one blockchain from another blockchain.

================================================================================

# Changelog and Releases | Chainlink

Source: https://docs.chain.link/ccip/release-notes
Extraction Method: playwright

/* Hover for View all button */
.arrow-btn:hover path {
	stroke: var(--biscay);
}

.arrow-btn.arrow-btn--white path {
	stroke: var(--white);
} 
.arrow-btn.arrow-btn--white:hover path {
	stroke: var(--blue-300);
}/* Devhub navbar styles */
@media (min-width: 992px) {
    .dev-nav-link:hover .dev-nav-link__shape,
    .dev-nav-link.w--current .dev-nav-link__shape,
    .dev-nav-link.w--open .dev-nav-link__shape {
        display: block;
    }
}

.dev-nav-link.dev-nav-link--dd:hover .dev-nav-link__shape path{
	fill: var(--chainlink-blue);
}

[data-nav-menu-open] {
	background-color: white;
}

.w-nav-overlay [data-nav-menu-open] {
    top: 64px;
}

@media (min-width: 991px) {
  .acad-nav-link:hover path {
    stroke: var(--chainlink-blue);
  }
}
  
/* Disable Blue Highlight  */
.dev-nav-link.dev-nav-link--dd {
		-webkit-tap-highlight-color:  rgba(255, 255, 255, 0); 
}Resources<svg xmlns="http://www.w3.org/2000/svg" width="47" height="39" viewBox="0 0 47 39" fill="none">
<g filter="url(#filter0_dd_921_10269)">
<path d="M11 14L27 14L19.7071 6.70711C19.3166 6.31658 18.6834 6.31658 18.2929 6.70711L11 14Z" fill="white"/>
</g>
<defs>
<filter id="filter0_dd_921_10269" x="0.6" y="0.714063" width="46" height="37.5859" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
<feFlood flood-opacity="0" result="BackgroundImageFix"/>
<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
<feMorphology radius="1" operator="dilate" in="SourceAlpha" result="effect1_dropShadow_921_10269"/>
<feOffset dx="4.6" dy="9.3"/>
<feGaussianBlur stdDeviation="7"/>
<feComposite in2="hardAlpha" operator="out"/>
<feColorMatrix type="matrix" values="0 0 0 0 0.596078 0 0 0 0 0.627451 0 0 0 0 0.72549 0 0 0 0.04 0"/>
<feBlend mode="normal" in2="BackgroundImageFix" result="effect1_dropShadow_921_10269"/>
<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
<feMorphology radius="0.3" operator="erode" in="SourceAlpha" result="effect2_dropShadow_921_10269"/>
<feOffset dx="1" dy="-1"/>
<feGaussianBlur stdDeviation="1.5"/>
<feComposite in2="hardAlpha" operator="out"/>
<feColorMatrix type="matrix" values="0 0 0 0 0.596078 0 0 0 0 0.627451 0 0 0 0 0.72549 0 0 0 0.21 0"/>
<feBlend mode="normal" in2="effect1_dropShadow_921_10269" result="effect2_dropShadow_921_10269"/>
<feBlend mode="normal" in="SourceGraphic" in2="effect2_dropShadow_921_10269" result="shape"/>
</filter>
</defs>
</svg>ResourcesCross-ChainCCIPGlobal standard for building secure cross-chain applications.

[Docs](https://docs.chain.link/ccip)[Learn](/products/ccip)[SDK](https://github.com/smartcontractkit/ccip-javascript-sdk)[View all resources](/resources)[Learn about Chainlink](/products/general)DataData resourcesMarket and Data Feeds resources for devs of any level.

[Learn](/products/data)FeedsDecentralized and high-quality data for DeFi, sports, weather, and more.

[Docs](https://docs.chain.link/data-feeds)[Learn](/products/data?sub-product=Data+Feeds)StreamsSecure high-frequency market data for ultra-fast derivative products.

[Docs](https://docs.chain.link/data-streams)[Learn](/products/data?sub-product=Data+Streams)ComputeAutomationHigh-performance, decentralized automation for smart contracts.

[Docs](https://docs.chain.link/chainlink-automation)[Learn](/products/automation)FunctionsServerless platform that fetches data from any API & runs custom compute.

[Docs](https://docs.chain.link/chainlink-functions)[Learn](/products/functions)VRFRandom number generator for blockchain gaming and NFTs.

[Docs](https://docs.chain.link/vrf)[Learn](/products/vrf)FeaturedHardhat CLI for Data Streams[Docs](https://docs.chain.link/data-streams/getting-started-hardhat)Try out Chainlink Automation[Docs](https://docs.chain.link/chainlink-automation/overview/getting-started)[Docs](https://docs.chain.link/)[Demos](/demos)[Tools](/tools)[Changelog](/changelog)[Get Certified](/certification)⌘KIntroducing DataLink: Bringing Institutional Market Data Onchain With Launch Partner Deutsche Börse.[Learn more.](https://blog.chain.link/introducing-datalink/?utm_campaign=datalink&utm_source=chainlink-dev&utm_medium=referral)Changelog
## Never miss an update
Mar 2024IntegrationSep 28, 2025Copy URLCopiedhttps://dev.chain.link/changelog/cross-chain-token-cct-standard-added-support-for-new-tokens-5d75aShow moreCCIP
### Cross-chain token (CCT) standard: Added support for new tokens
Newly supported tokens: AISTR, BARD, FF, USX, avETH, avETHx, clBTC, eUSX, kHYPE, sUSD1+, savETH, syrupUSDT, wstETH, wstPOL

[AicroStrategy](https://docs.chain.link/ccip/directory/mainnet/token/AISTR)[Lombard](https://docs.chain.link/ccip/directory/mainnet/token/BARD)[Falcon Finance](https://docs.chain.link/ccip/directory/mainnet/token/FF)[USX Stablecoin](https://docs.chain.link/ccip/directory/mainnet/token/USX)[avETH](https://docs.chain.link/ccip/directory/mainnet/token/avETH)[avETH MAX](https://docs.chain.link/ccip/directory/mainnet/token/avETHx)[clBTC](https://docs.chain.link/ccip/directory/mainnet/token/clBTC)[eUSX Token](https://docs.chain.link/ccip/directory/mainnet/token/eUSX)[Kinetiq Staked HYPE](https://docs.chain.link/ccip/directory/mainnet/token/kHYPE)[sUSD1+](https://docs.chain.link/ccip/directory/mainnet/token/sUSD1+)[Staked avETH](https://docs.chain.link/ccip/directory/mainnet/token/savETH)[Syrup USDT](https://docs.chain.link/ccip/directory/mainnet/token/syrupUSDT)[Wrapped stETH](https://docs.chain.link/ccip/directory/mainnet/token/wstETH)[Wrapped stPOL](https://docs.chain.link/ccip/directory/mainnet/token/wstPOL)BTC / USDEthereumBTC / USDEthereumIntegrationSep 25, 2025Copy URLCopiedhttps://dev.chain.link/changelog/ccip-on-0gShow more[Image: 0G]0GCCIP
### CCIP on 0G
Chainlink CCIP expands support to 0G Mainnet.

[0G Mainnet](https://docs.chain.link/ccip/directory/mainnet/chain/0g-mainnet)BTC / USDEthereumBTC / USDEthereumIntegrationSep 22, 2025Copy URLCopiedhttps://dev.chain.link/changelog/ccip-on-plasmaShow more[Image: Plasma]PlasmaCCIP
### CCIP on Plasma
Chainlink CCIP expands support to Plasma.

[Plasma Mainnet](https://docs.chain.link/ccip/directory/mainnet/chain/plasma-mainnet)[Plasma Testnet](https://docs.chain.link/ccip/directory/testnet/chain/plasma-testnet)BTC / USDEthereumBTC / USDEthereumIntegrationSep 17, 2025Copy URLCopiedhttps://dev.chain.link/changelog/ccip-on-kaia-and-tacShow more[Image: Kaia]Kaia[Image: TAC]TACCCIP
### CCIP on Kaia and Tac
Chainlink CCIP expands support to Kaia and Tac.

[Kaia Mainnet](https://docs.chain.link/ccip/directory/mainnet/chain/kaia-mainnet)[Kaia Kairos Testnet](https://docs.chain.link/ccip/directory/testnet/chain/kaia-testnet-kairos)[TAC Mainnet](https://docs.chain.link/ccip/directory/mainnet/chain/tac-mainnet)[TAC Saint Petersburg Testnet](https://docs.chain.link/ccip/directory/testnet/chain/tac-testnet)BTC / USDEthereumBTC / USDEthereumIntegrationSep 14, 2025Copy URLCopiedhttps://dev.chain.link/changelog/cross-chain-token-cct-standard-added-support-for-new-tokens-73512Show moreCCIP
### Cross-chain token (CCT) standard: Added support for new tokens
Newly supported tokens: CGX, DOBO, JASMY, Memento, OHM, OVER, SOIL, USUAL, YNE, beraBTC, oXAUT

[Forkast](https://docs.chain.link/ccip/directory/mainnet/token/CGX)[DogeBonk.com](https://docs.chain.link/ccip/directory/mainnet/token/DOBO)[JasmyCoin](https://docs.chain.link/ccip/directory/mainnet/token/JASMY)[DEXTF Token](https://docs.chain.link/ccip/directory/mainnet/token/Memento)[Olympus](https://docs.chain.link/ccip/directory/mainnet/token/OHM)[Overtime DAO Token](https://docs.chain.link/ccip/directory/mainnet/token/OVER)[Soil](https://docs.chain.link/ccip/directory/mainnet/token/SOIL)[USUAL](https://docs.chain.link/ccip/directory/mainnet/token/USUAL)[yesnoerror](https://docs.chain.link/ccip/directory/mainnet/token/YNE)[Bera Bitcoin](https://docs.chain.link/ccip/directory/mainnet/token/beraBTC)[OpenXAUT](https://docs.chain.link/ccip/directory/mainnet/token/oXAUT)BTC / USDEthereumBTC / USDEthereumIntegrationSep 9, 2025Copy URLCopiedhttps://dev.chain.link/changelog/ccip-on-aptosShow more[Image: Aptos]AptosCCIP
### CCIP on Aptos

• This release continues CCIP's expansion to non-EVMs by adding support for the Aptos blockchain.
• Aptos is now interoperable with several EVM chains including Ethereum, Arbitrum, Base, BNB, Optimism, and Sonic using the latest CCIP architecture.
• More lanes to and from Aptos will be added in the future.
• No change to any existing EVM Router addresses.
• Aptos CCIP details can be seen on the CCIP Directory.

[Aptos Mainnet](https://docs.chain.link/ccip/directory/mainnet/chain/aptos-mainnet)[Aptos Testnet](https://docs.chain.link/ccip/directory/testnet/chain/aptos-testnet)BTC / USDEthereumBTC / USDEthereumIntegrationSep 7, 2025Copy URLCopiedhttps://dev.chain.link/changelog/cross-chain-token-cct-standard-added-support-for-new-tokens-b3921Show moreCCIP
### Cross-chain token (CCT) standard: Added support for new tokens
Newly supported tokens: WLFI

[World Liberty Financial](https://docs.chain.link/ccip/directory/mainnet/token/WLFI)BTC / USDEthereumBTC / USDEthereumIntegrationAug 31, 2025Copy URLCopiedhttps://dev.chain.link/changelog/cross-chain-token-cct-standard-added-support-for-new-tokens-abb6dShow moreCCIP
### Cross-chain token (CCT) standard: Added support for new tokens
Newly supported tokens: WFRAGSOL, XLAB

[Wrapped Fragmetric Restaked SOL](https://docs.chain.link/ccip/directory/mainnet/token/WFRAGSOL)[Dexlab](https://docs.chain.link/ccip/directory/mainnet/token/XLAB)BTC / USDEthereumBTC / USDEthereumIntegrationAug 24, 2025Copy URLCopiedhttps://dev.chain.link/changelog/cross-chain-token-cct-standard-added-support-for-new-tokens-a9bb6Show moreCCIP
### Cross-chain token (CCT) standard: Added support for new tokens
Newly supported tokens: ORNG, xGold

[Orange](https://docs.chain.link/ccip/directory/mainnet/token/ORNG)[xGold](https://docs.chain.link/ccip/directory/mainnet/token/xGold)BTC / USDEthereumBTC / USDEthereumIntegrationAug 3, 2025Copy URLCopiedhttps://dev.chain.link/changelog/cross-chain-token-cct-standard-added-support-for-new-tokens-559deShow moreCCIP
### Cross-chain token (CCT) standard: Added support for new tokens
Newly supported tokens: USDf, VSN, enzoBTC

[Falcon USD](https://docs.chain.link/ccip/directory/mainnet/token/USDf)[Vision](https://docs.chain.link/ccip/directory/mainnet/token/VSN)[Lorenzo Wrapped Bitcoin](https://docs.chain.link/ccip/directory/mainnet/token/enzoBTC)BTC / USDEthereumBTC / USDEthereumNo updates foundWe couldn’t find anything matching your filters.[Previous](?bcc22d62_page=1)[Load more](?bcc22d62_page=2)Showing10of297updates@media (max-width: 991px) {
    .float-checkbox.float-checkbox--active .float-tick {
        opacity: 1;
    }
    
     .float-checkbox.float-checkbox--active .float-label {
        color: var(--chainlink-blue);
    }
}

@media (min-width: 992px) {
    .float-checkbox.float-checkbox--active {
        background-color: var(--grey-700);
    }

    .float-checkbox.float-checkbox--active .float-close {
        display: inline-block;
    }

    .float-dd.float-dd--active .float-dd-arr {
        display: none;
    }

    .float-dd.float-dd--active .float-dd-text {
        flex-grow: 1;
    }

    .float-dd.float-dd--active .float-dd-close {
        display: block;
    }
}

/* width */
.float-list::-webkit-scrollbar {
  width: 4px;
}
/* Track */
.float-list::-webkit-scrollbar-track {
  border-radius: 1px;
  border-left: 1px solid transparent;
  border-right: 1px solid transparent;
  background-clip: padding-box;
}
.float-list::-webkit-scrollbar-thumb {
  border-radius: 4px;
}

@media screen and (min-width: 992px) {
  /* Track */
  .float-list::-webkit-scrollbar-track {
    background: var(--grey-700); 
  }
  /* Handle */
  .float-list::-webkit-scrollbar-thumb {
    background: var(--grey-500); 
  }
}

@media screen and (max-width: 991px) {
  /* Track */
  .float-list::-webkit-scrollbar-track {
    background: var(--mirage-05); 
  }
  /* Handle */
  .float-list::-webkit-scrollbar-thumb {
    background: var(--grey-300); 
  }
}

@media screen and (max-width: 991px) {
  .float-dd.float-dd--tablet .float-dd-text {
  display: none;
  }
}
.float-search.float-search--active .float-search__clear{
	display: block;
}
.float-search.float-search--active .float-search__input{
	display: block;
}[Image: Close icon]FilterClearProducts1Network1Type1ProductClearCCIPData FeedsData StreamsSmartDataFunctionsAutomationVRFNodesGeneralView ResultsNetworkClear0GAbstractApechainAptosArbitrumAstarAvalancheB2BNB ChainBaseBerachainBitlayerBlastBobBotanixCeloCoreCornCronosCronos zkEVMEthereumFantomFraxtalGnosis ChainHarmonyHashKey ChainHederaHemiHyperliquidInkJanctionJovayLensLineaLiskMantleMegaETHMerlinMetal L2MetisMind NetworkMintModeMonadMoonbeamMoonriverNeo XOptimismPlasmaPlumePolygonPolygon KatanaPolygon zkEVMRoninRootstockScrollSei NetworkShibariumSolanaSoneiumSonicStarknetSuperseedTaikoTreasureTronUnichainWorld ChainX LayerZircuitZoraopBNBzkSyncView ResultsTypeClearBlogBug FixDeprecationFeatureIntegrationReleaseUpdateView ResultsProduct1Network0Type0Filter by1Thank you! Your submission has been received!Oops! Something went wrong while submitting the form.
### Developers

• Docs
• Builder Quick Links
• Faucets
• Developer Hub
• Chainlink Hackathon
• Bootcamp
• Use Cross-Chain (CCIP)
• Use Data Feeds
• Use Randomness (VRF)
• Use Automation
• Use Functions
• Node Operators

### Products

• Cross-Chain
• Data Streams
• Market and Data Feeds
• Functions
• VRF
• Automation
• Proof of Reserve

### Use Cases

• Overview
• Asset Tokenization
• Financial Services
• DeFi
• Gaming
• NFT Collectibles
• Climate Markets
• Enterprise
• Insurance

### Community

• Community Overview
• Grant Program
• Events
• Become an Advocate
• Code of Conduct

### Resources

• Whitepaper
• Blog
• Economics
• Staking
• Rewards
• FAQs
• Education Hub
• What Is DeFi?
• What Is an Oracle?
• What Is a Smart Contract?
• What Is an NFT?
• What Is Web3?

### Chainlink

• Ecosystem
• Data Providers
• Press
• Team
• Circulating Supply
• CareersWE ARE HIRING!
• Brand Assets
• Chainlink Badging

### Contact

• Talk to an expert
• Security
• Support
• Custom Chainlinks
• Press inquiries
• Legal Support
• Legal

### Social

• X
• LinkedIn
• YouTube
• Instagram
• TikTok
• Discord
• Telegram
• Reddit
• Facebook
• WeChat

[Home](https://chain.link/)Chainlink®© 2024 Chainlink FoundationenZH[Privacy Policy](https://chain.link/privacy-policy)[Terms of Service](https://chain.link/terms)document.addEventListener("DOMContentLoaded", function () {
    if (/(Mac|iPhone|iPod|iPad)/i.test(navigator.platform)) {
      const macElements = document.querySelectorAll('.show-mac');
      const otherElements = document.querySelectorAll('.show-other-os');

      macElements.forEach(macElement => {
          macElement.style.display = 'inline';
      });

      otherElements.forEach(otherElement => {
          otherElement.style.display = 'none';
      });
  }
});document.addEventListener("DOMContentLoaded", function() {
    if (window.innerWidth < 992) {

    let accordionItems = document.querySelectorAll('.mega-menu-card:not(.mega-menu-card--no-accordeon)');
    let transitionDuration = '0.3s';
    let transitionTiming = 'ease';
    
    accordionItems.forEach(function(item) {
        let content = item.querySelector('.mega-menu-card__content');
        let caret = item.querySelector('.mega-menu-card__caret-vert');
        content.style.transition = 'height ' + transitionDuration + ' ' + transitionTiming;
        caret.style.transition = 'transform ' + transitionDuration + ' ' + transitionTiming;

        item.addEventListener('click', function() {
            let isVisible = content.offsetHeight > 0;

            accordionItems.forEach(function(otherItem) {
                let otherContent = otherItem.querySelector('.mega-menu-card__content');
                let otherCaret = otherItem.querySelector('.mega-menu-card__caret-vert');

                if (otherItem !== item) {
                    otherContent.style.height = '0';
                    otherCaret.style.transform = 'rotate(0deg)';
                }
            });

            content.style.height = isVisible ? '0' : content.scrollHeight + 'px';
            caret.style.transform = isVisible ? 'rotate(0deg)' : 'rotate(90deg)';
        });
    });
    }
});document.addEventListener("DOMContentLoaded", function() {
    if (window.innerWidth < 992) {
      var source = document.getElementById('res-link-source');
      var target = document.getElementById('res-link-target');
      while (source.childNodes.length > 0) {
        target.appendChild(source.childNodes[0]);
      }
    }
});document.addEventListener('DOMContentLoaded', function() {
    if (window.innerWidth < 992) {
      let isBodyScrollDisabled = false;

      // Utility function to toggle body scroll
      function toggleBodyScroll() {
          document.body.style.overflow = isBodyScrollDisabled ? '' : 'hidden';
          isBodyScrollDisabled = !isBodyScrollDisabled;
      }

      // Event listener for .dev-nav__menu-btn
      document.querySelector('.dev-nav__menu-btn').addEventListener('click', toggleBodyScroll);

      // Event listener for .dev-nav__search-wrap
      document.querySelector('.dev-nav__search-wrap').addEventListener('click', function() {
          if (isBodyScrollDisabled) {
              toggleBodyScroll(); // This will re-enable body scroll
          }
      });
    }
});document.addEventListener("DOMContentLoaded", function() {
    // First set of elements
    const closeBtn1 = document.querySelector("[mega-dd='close']");
    const openBtn1 = document.querySelector("[mega-dd='open']");
    const menuWrapper1 = document.querySelector("[mega-dd='wrapper']");
    
    // Second set of elements
    const closeBtn2 = document.querySelector("[mega-dd='close-2']");
    const openBtn2 = document.querySelector("[mega-dd='open-2']");
    const menuWrapper2 = document.querySelector("[mega-dd='wrapper-2']");
    
    const devNavCenter = document.querySelector('.dev-nav__center');
    
    function handleMenuActions(closeBtn, openBtn, menuWrapper) {
        if (window.innerWidth < 992) {
            closeBtn.addEventListener('click', function(event) {
                event.stopPropagation(); // Prevent the click event from bubbling up
                menuWrapper.style.display = 'none';
                devNavCenter.style.zIndex = '10';
            });

            openBtn.addEventListener('click', function() {
                menuWrapper.style.display = 'flex';
                devNavCenter.style.zIndex = '50';
            });
        }
        
        openBtn.addEventListener('click', function() {
            const navMenuOpenElement = document.querySelector('.w-nav-overlay [data-nav-menu-open]');
            if (navMenuOpenElement) {
                navMenuOpenElement.style.top = '0px';
            }
        });

        closeBtn.addEventListener('click', function() {
            document.querySelector('.w-nav-overlay [data-nav-menu-open]').style.top = '64px';
        });
    }
    
    handleMenuActions(closeBtn1, openBtn1, menuWrapper1);
    handleMenuActions(closeBtn2, openBtn2, menuWrapper2);
});document.addEventListener('DOMContentLoaded', () => {
    if (window.innerWidth < 992) {  
        const floatDdTablet = document.querySelector('.float-dd.float-dd--tablet');
        const floatListTopClose = document.querySelector('.float-list-top__close');
        const floatResBtns = document.querySelectorAll('.float-view-res');
        const floatDdCounterTablet = document.querySelector('.float-dd__counter.float-dd__counter--tablet');
        const floatFilterBlock = document.querySelector('.float-filter-block');

        if (!floatFilterBlock) return;

        const setZIndex = (value) => {
            floatFilterBlock.style.zIndex = value;
        }

        const resetZIndex = () => setZIndex('5');

        if (floatDdTablet) {
            floatDdTablet.addEventListener('click', () => setZIndex('201'));
        }

        if (floatListTopClose) {
            floatListTopClose.addEventListener('click', resetZIndex);
        }

        floatResBtns.forEach(btn => {
            btn.addEventListener('click', resetZIndex);
        });

        if (floatDdCounterTablet) {
            floatDdCounterTablet.addEventListener('click', (event) => {
                event.stopPropagation();
                resetZIndex();
            });
        }
    }
});document.addEventListener("DOMContentLoaded", function () {
    let sourceElement = document.getElementById('result-count-source');
    let targetElement = document.getElementById('result-count-target');

    if (sourceElement && targetElement) {
        sourceElement.parentNode.removeChild(sourceElement);
        targetElement.parentNode.insertBefore(sourceElement, targetElement);
    }
});document.addEventListener('DOMContentLoaded', () => {
           const floatSearch = document.querySelector('.float-search');

    //Open search
    if (window.location.href.includes('*=')) {
        setTimeout(() => floatSearch?.click(), 500);
    }
    
    if (window.innerWidth >= 992) {
        // Cache DOM elements to avoid redundant queries
        const floatFilterElement = document.querySelector('.float-filter');
        const floatFilterBottom = document.querySelector('.float-filter-bottom');
        const filterOverlay = document.querySelector('.float-filter-overlay');
        const floatDDs = document.querySelectorAll('.float-dd');
        const floatLists = document.querySelectorAll('.float-list');
        const tabletFilters = document.querySelectorAll('.float-tablet-filters');
        const closeButtons = document.querySelectorAll('.float-dd-close');
        const inputElement = document.querySelector('.float-search__input');
        const clearButton = document.querySelector('.float-search__clear');

        // Function to update counters for all dropdown buttons
        function updateAllCounters() {
            floatLists.forEach((list, index) => {
                const activeCheckboxes = list.querySelectorAll('.float-checkbox--active').length;
                const counter = document.querySelectorAll('.float-dd__counter.float-dd__counter--desktop .float-dd__number')[index];
                counter.textContent = activeCheckboxes;

                // Toggle display of parent .float-dd__counter based on counter value
                const counterParent = counter.closest('.float-dd__counter.float-dd__counter--desktop');
                counterParent.style.display = activeCheckboxes > 0 ? 'flex' : 'none';
            });
        }

        // Function to hide all lists and remove active class from all buttons
        function hideAllListsAndButtons() {
            tabletFilters.forEach(list => list.style.display = 'none');
            floatDDs.forEach(btn => btn.classList.remove('float-dd--active'));
        }

        // Function to reset float filter element styles
        function resetFloatFilterStyles() {
            floatFilterElement.style.width = 'auto';
            floatFilterBottom.style.borderTopLeftRadius = '32px';
            floatFilterBottom.style.borderTopRightRadius = '32px';
        }

        // Add event listeners to dropdown buttons
        floatDDs.forEach((button, index) => {
            button.addEventListener('click', (event) => {
                // Check if the clicked element is the clear filter button
                if (event.target.classList.contains('float-dd__clear-filter')) return;

                floatFilterElement.style.width = `${floatFilterElement.offsetWidth}px`;
                floatFilterBottom.style.borderTopLeftRadius = '0px';
                floatFilterBottom.style.borderTopRightRadius = '0px';
                hideAllListsAndButtons();
                tabletFilters[index].style.display = 'block';
                filterOverlay.style.display = 'block';
                button.classList.add('float-dd--active');
            });
        });

        // Add event listener to overlay
        filterOverlay.addEventListener('click', () => {
            resetFloatFilterStyles();
            hideAllListsAndButtons();
            filterOverlay.style.display = 'none';
        });

        // Add event listeners to close buttons
        closeButtons.forEach(closeButton => {
            closeButton.addEventListener('click', event => {
                event.stopPropagation();
                resetFloatFilterStyles();
                hideAllListsAndButtons();
                filterOverlay.style.display = 'none';
            });
        });

        // Add event listener to float search
        floatSearch?.addEventListener('click', () => {
            inputElement.focus();
            floatFilterElement.style.width = `${floatFilterElement.offsetWidth}px`;
            floatSearch.classList.add('float-search--active');
        });

        // Add event listener to clear button
        clearButton?.addEventListener('click', event => {
            event.stopPropagation(); // Prevent the click event from bubbling up to the parent
            floatSearch.classList.remove('float-search--active');
            floatFilterElement.style.width = 'auto';
        });

        // Call update counters on load
        updateAllCounters();

        // Observer configuration
        const observerConfig = { attributes: true, attributeFilter: ['class'], subtree: true };

        // Callback function to execute when mutations are observed
        const mutationCallback = mutationsList => {
            mutationsList.forEach(mutation => {
                if (mutation.type === 'attributes' && mutation.attributeName === 'class' && mutation.target.classList.contains('float-checkbox')) {
                    updateAllCounters();
                    setTimeout(() => {
                    	resetFloatFilterStyles();
           						hideAllListsAndButtons();
            					filterOverlay.style.display = 'none';
        						}, 300);
                    
                }
            });
        };

        // Create a new instance of MutationObserver with the callback function
        const observer = new MutationObserver(mutationCallback);

        // Start observing the target node for configured mutations
        observer.observe(document.body, observerConfig);

    }

    if (window.innerWidth < 992) {
        document.querySelector('.float-search__input')?.setAttribute('placeholder', 'Search');

        // Cache the selectors
        const floatFilterTop = document.querySelector('.float-filter-top');
        const floatModalTablet = document.querySelector('.float-modal-tablet');
        const floatTabletFiltersWrap = document.querySelector('.float-tablet-filters-wrap');
        const floatTabletFilters = document.querySelectorAll('.float-tablet-filters');

        // Event listeners for elements with the class '.float-dd'
        document.querySelectorAll('.float-dd').forEach(element => {
            element.addEventListener('click', (event) => {
                // Check if the clicked element is the clear filter button
                if (event.target.classList.contains('float-dd__counter') || event.target.closest('.float-dd__counter')) {
                    return; // Exit the function if it's the clear filter button
                } floatFilterTop.style.display = 'flex';
            });

        });

        // Event listeners for elements with the class '.float-list-top__back'
        document.querySelectorAll('.float-list-top__back').forEach(element => {
            element.addEventListener('click', () => {
                floatTabletFilters.forEach(div => div.style.display = 'none');
                floatTabletFiltersWrap.style.display = 'none';
                floatModalTablet.style.display = 'block';
            });
        });

        // Event listeners for elements with the class '.float-list-top__close'
        document.querySelectorAll('.float-list-top__close').forEach(element => {
            element.addEventListener('click', () => {
                floatFilterTop.style.display = 'none';
            });
        });

        // Event listeners for elements with the class '.float-view-res'
        document.querySelectorAll('.float-view-res').forEach(element => {
            element.addEventListener('click', () => {
                floatFilterTop.style.display = 'none';
                floatTabletFiltersWrap.style.display = 'none';
                floatModalTablet.style.display = 'block';
            });
        });

        // Event listeners for elements with the class '.float-dd-tablet'
        document.querySelectorAll('.float-dd-tablet').forEach((element, index) => {
            element.addEventListener('click', (event) => {
                // Check if the clicked element is the clear filter button
                if (event.target.classList.contains('float-dd__counter') || event.target.closest('.float-dd__counter')) {
                    return; // Exit the function if it's the clear filter button
                }
                floatModalTablet.style.display = 'none';
                floatTabletFiltersWrap.style.display = 'block';
                floatTabletFilters.forEach(div => div.style.display = 'none');
                floatTabletFilters[index].style.display = 'block';
            });
        });

        function updateAllCounters() {

            let allActiveCheckboxes = document.querySelectorAll('.float-checkbox.float-checkbox--active').length;

            const mainCounter = document.querySelector('.float-dd.float-dd--tablet .float-dd__number');
            mainCounter.textContent = allActiveCheckboxes;
            const counterParent = mainCounter.closest('.float-dd__counter');
            // const chipsText = document.querySelector('.float-chips-text');

            if (allActiveCheckboxes > 0) {
                counterParent.style.display = 'flex';
                console.log("flex was set");
                document.querySelector('.float-list-top__clear-all').style.opacity = '1';
                // chipsText.style.display = 'flex';

            } else {
                counterParent.style.display = 'none';
                console.log("none was set");

                document.querySelector('.float-list-top__clear-all').style.opacity = '0';
                //  chipsText.style.display = 'none';

            }

            document.querySelectorAll('.float-list').forEach((list, index) => {
                const activeCheckboxes = list.querySelectorAll('.float-checkbox--active').length;
                const counter = document.querySelectorAll('.float-dd-tablet .float-dd__number')[index];
                counter.textContent = activeCheckboxes;

                // Toggle display of parent .float-dd__counter based on counter value
                const counterParent = counter.closest('.float-dd__counter');
                if (activeCheckboxes > 0) {
                    counterParent.style.display = 'flex';
                    document.querySelectorAll('.float-list-top__clear')[index].style.opacity = '1';

                } else {
                    counterParent.style.display = 'none';
                    document.querySelectorAll('.float-list-top__clear')[index].style.opacity = '0';

                }
            });
        }

        var floatFilterElement = document.querySelector('.float-filter');
        var inputElement = document.querySelector('.float-search__input');

        document.querySelector('.float-search')?.addEventListener('click', function () {
            if (window.innerWidth < 375) {
               floatFilterElement.style.width = "300px";
            } else {
               floatFilterElement.style.width = "360px";
            }
            this.classList.add('float-search--active');
            inputElement.focus();

        });
        // Add event listener to .float-search__clear element
        document.querySelector('.float-search__clear')?.addEventListener('click', function (event) {
            event.stopPropagation(); // Prevent the click event from bubbling up to the parent
            document.querySelector('.float-search').classList.remove('float-search--active');
            floatFilterElement.style.width = 'auto';

        });

        // Observer configuration
        const observerConfig = { attributes: true, attributeFilter: ['class'], subtree: true };

        // Callback function to execute when mutations are observed
        const mutationCallback = function (mutationsList) {
            mutationsList.forEach(mutation => {
                if (mutation.type === 'attributes' && mutation.attributeName === 'class' && mutation.target.classList.contains('float-checkbox')) {
                    updateAllCounters();
                }
            });
        };

        // Create a new instance of MutationObserver with the callback function
        const observer = new MutationObserver(mutationCallback);

        // Start observing the target node for configured mutations
        setTimeout(() => {
            updateAllCounters();
            observer.observe(document.body, observerConfig);
        }, 500);
    }
});/*
window.onload = function() {
    // Function to scroll to the target element
    function scrollToTarget() {
        const target = document.querySelector('#filters-scroll');
        if (target) {
            target.scrollIntoView({ behavior: 'smooth' });
        }
    }

    // Select all elements with the class .float-checkbox
    const floatCheckboxes = document.querySelectorAll('.float-checkbox');

    // Callback function to execute when mutations are observed
    const mutationCallback = function(mutationsList) {
        for (let mutation of mutationsList) {
            if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                scrollToTarget();
            }
        }
    };

    // Create an observer instance linked to the callback function
    const observer = new MutationObserver(mutationCallback);

    // Options for the observer (which mutations to observe)
    const observerConfig = { attributes: true, attributeFilter: ['class'] };

    // Start observing each float-checkbox element
    floatCheckboxes.forEach((checkbox) => {
        observer.observe(checkbox, observerConfig);
    });

    // Select all elements with the class .float-search__input
    const floatSearchInputs = document.querySelectorAll('.float-search__input');

    // Add event listener for input changes
    floatSearchInputs.forEach((input) => {
        input.addEventListener('input', function() {
            if (window.innerWidth >= 992) {
                scrollToTarget();
            }
        });
    });
};
*/

window.onload = function() {
    let canScroll = false;

    // Block scrolling for 1 second after page load
    setTimeout(() => {
        canScroll = true;
    }, 3000);

    // Function to scroll to the target element
    function scrollToTarget() {
        if (canScroll) {
            const target = document.querySelector('#filters-scroll');
            if (target) {
                target.scrollIntoView({ behavior: 'smooth' });
            }
        }
    }

    // Select all elements with the class .float-checkbox
    const floatCheckboxes = document.querySelectorAll('.float-checkbox');

    // Callback function to execute when mutations are observed
    const mutationCallback = function(mutationsList) {
        for (let mutation of mutationsList) {
            if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                scrollToTarget();
            }
        }
    };

    // Create an observer instance linked to the callback function
    const observer = new MutationObserver(mutationCallback);

    // Options for the observer (which mutations to observe)
    const observerConfig = { attributes: true, attributeFilter: ['class'] };

    // Start observing each float-checkbox element
    floatCheckboxes.forEach((checkbox) => {
        observer.observe(checkbox, observerConfig);
    });

    // Select all elements with the class .float-search__input
    const floatSearchInputs = document.querySelectorAll('.float-search__input');

    // Add event listener for input changes
    floatSearchInputs.forEach((input) => {
        input.addEventListener('input', function() {
            if (window.innerWidth >= 992) {
                scrollToTarget();
            }
        });
    });
};// This script is used for the copy to clipboard functionality and for scrolling to the heading
  const handleCopyToClipboard = (text) => {
    try {
      if (text) {
        navigator.clipboard.writeText(text);
      }
    } catch (error) {
      console.error('Error copying to clipboard', error);
    }
  };

const logList = document.querySelector(".change-logs");
logList.addEventListener("click", (event)=> {
	const button = event.target.closest(".log-share");
  if (button) {
  	const text = button.nextSibling?.textContent;
  	handleCopyToClipboard(text)
  }
})import { replaceAllTokenImages } from 'https://thisdot.github.io/chainlink-webflow-cms-api/webflow-script/fetch-icons.js';
  const chaingeLogs = document.querySelector(".change-logs");
  const singleLog = document.querySelector(".log-item-single");
  const resizeObserver = new ResizeObserver((entries) => {
      replaceAllTokenImages();
  });

	resizeObserver.observe(chaingeLogs || singleLog);
  
  replaceAllTokenImages();@media (min-width: 992px) {
  .float-list-wrap.mask-active {
    -webkit-mask-image: linear-gradient(to bottom, black 90%, transparent 100%);
    mask-image: linear-gradient(to bottom, black 90%, transparent 100%);
  }
}

.log-item__description.w-richtext code {
    padding: 1px 4px;
}

/*
.log-item__description li a {
    font-weight: 600;
}

.log-item__description ul li:has(a) {
    list-style-type: disc;
    color: var(--chainlink-blue);
}*/

.log-item__description.w-richtext code {
	text-wrap: wrap;
}
.log-item__description a:hover {
		text-decoration: underline;
}const searchData = (searchQuery) => {
  window.dataLayer = window.dataLayer || [];
  window.dataLayer.push({
    'event': 'float_nav_search',
    'search_query': searchQuery
  });
}
const searchInput = document.getElementById('Search-2');
if( searchInput) {
  searchInput.addEventListener("blur", searchData);
}Main nav show/hide overlay 
<script>
        window.onload = function() {
            var overlay = document.querySelector('.res-nav-overlay');
            
            window.addEventListener('scroll', function() {
                var scrollPosition = window.scrollY;

                if (scrollPosition >= 12) {
                    overlay.style.opacity = '0.8';
                } else {
                    overlay.style.opacity = '0';
                }
            });
        }
</script>function loadJS(FILE_URL, callback, type = "text/javascript") {
  let scriptEle = document.createElement("script");
  const urlWithAppendedDate = `${FILE_URL}?v=${Date.now()}`;
  scriptEle.setAttribute("src", urlWithAppendedDate);
  scriptEle.setAttribute("type", type);
  scriptEle.setAttribute("defer", true);

  document.body.appendChild(scriptEle);

  // success event 
  scriptEle.addEventListener("load", (callback) => {
    console.log("File loaded");
    callback();
  });
   // error event
  scriptEle.addEventListener("error", (ev) => {
    console.log("Error on loading file", ev);
  });
}
function loadCSS(FILE_URL) {
  let scriptEle = document.createElement("link");
  const urlWithAppendedDate = `${FILE_URL}?v=${Date.now()}`;
  scriptEle.setAttribute("href", urlWithAppendedDate);
  scriptEle.setAttribute("rel", "stylesheet");
  scriptEle.setAttribute("type", "text/css");

  document.body.appendChild(scriptEle);

  // success event 
  scriptEle.addEventListener("load", () => {
    console.log("File loaded")
  });
   // error event
  scriptEle.addEventListener("error", (ev) => {
    console.log("Error on loading file", ev);
  });
}Search dialog from external packageRollback plan: Please replace the content of Href with the following: https://cdn.jsdelivr.net/npm/chainlink-algolia-search@0.10.1/dist/index.cssvar currentPageURL=document.location.href,cdomain="chain.link",now=new Date,time=now.getTime(),expireTime=time+15552E6;now.setTime(expireTime);currentPageURL.includes("utm_medium")&&(document.cookie="__wf_campaign_url\x3d"+encodeURIComponent(currentPageURL)+";expires\x3d"+now.toUTCString()+";path\x3d/;domain\x3d"+cdomain);(function(){function c(){var a=document.querySelector('input[class*\x3d"aiDrawerInput"]');a&&!a._chatListenerAttached&&(a._chatListenerAttached=!0,a.addEventListener("keydown",function(b){b=b||window.event;b.key!=="Enter"&&b.keyCode!==13||a.value.trim()===""||(window.dataLayer=window.dataLayer||[],window.dataLayer.push({event:"user_ai_query",user_ai_query:a.value.trim()}))}))}var d=new MutationObserver(function(a){(a=document.querySelector('input[class*\x3d"aiDrawerInput"]'))&&c()});d.observe(document.body,
{childList:!0,subtree:!0});c()})();window.process = window.process ||{};
  process.env = window.process.env || {};
  process.env.NODE_ENV = "production";Rollback plan: Please replace the content of the import with the following: https://cdn.jsdelivr.net/npm/chainlink-algolia-search@0.10.1/dist/webflow-import.mjsimport { webflowComponentImport } from 'https://cdn.jsdelivr.net/npm/@chainlink/cl-search-frontend@0.11.4/dist/webflow-import.mjs';
  webflowComponentImport( {
	elementId:"search-container",
    algoliaAppId: "K1NK1TQHV9",
    algoliaPublicApiKey: "6499ecf5d48e511595fd0f88f1c2c0fa",
    popularCards:[
      {
          url: "https://docs.chain.link/",
          imgSrc: "https://cdn.prod.website-files.com/64cc2c23d8dbd707cdb556d8/684b2a334369d2fb64c04591_Docs.svg",
          label: "Docs",
      },
      { 
          url: "https://dev.chain.link/demos",
          imgSrc: "https://cdn.prod.website-files.com/64cc2c23d8dbd707cdb556d8/684b2a33b0dd30e514591610_Demos.svg",
          label: "Demos"
      }
    ]});END:Search dialog from external packageStart of HubSpot Embed CodeEnd of HubSpot Embed CodeStart of External scriptimport { manageBanner } from 'https://thisdot.github.io/chainlink-webflow-cms-api/webflow-script/banner.js';
  manageBanner({
    bannerSelector: ".header-banner",
    bannerDescriptionSelector: '.header-banner-description',
    closeButtonSelector: ".banner-close",
  });End of External scriptfunction initializeLogItems() {
    document.querySelectorAll(".log-item:not(.showMore_initialized)").forEach(logItem => {
        let maxHeight = window.innerWidth <= 768 ? 440 : 300; // Adjust height for mobile
        if (logItem.offsetHeight > maxHeight) {
            showShowMoreButton(logItem, maxHeight);
            applyMaskEffect(logItem);
        }
    });
}

function showShowMoreButton(logItem, maxHeight) {
    const showMore = logItem.querySelector(".log-item__show-more");
    if (showMore) {
        showMore.style.display = "flex";
        showMore.closest(".log-item").classList.add("showMore_initialized");
    }
    logItem.style.height = maxHeight + "px";

    const longCss = logItem.querySelector(".log-item__long-css");
    if (longCss) {
        longCss.style.visibility = "visible";
    }
}

function applyMaskEffect(logItem) {
    const logItemInfo = logItem.querySelector(".log-item__info");
    if (logItemInfo) {
        logItemInfo.style.maskImage = "linear-gradient(to bottom, rgba(0,0,0,1) 50%, rgba(0,0,0,0) 85%)";
        logItemInfo.style.webkitMaskImage = "linear-gradient(to bottom, rgba(0,0,0,1) 50%, rgba(0,0,0,0) 85%)";
    }
}

function setupShowMoreButtons() {
    document.querySelectorAll(".log-item__show-more").forEach(button => {
        button.addEventListener("click", function () {
            handleShowMoreClick(this);
        });
    });
}

function handleShowMoreClick(button) {
    console.log("clicked");
    const logItem = button.closest(".log-item");
    if (logItem) {
        expandLogItem(logItem);
    }
}

function expandLogItem(logItem) {
    const showMore = logItem.querySelector(".log-item__show-more");
    if (showMore) {
        showMore.style.display = "none";
    }
    logItem.style.height = "auto";
    logItem.style.maxHeight = "none";

    const logItemInfo = logItem.querySelector(".log-item__info");
    if (logItemInfo) {
        logItemInfo.style.maskImage = "none";
        logItemInfo.style.webkitMaskImage = "none";
    }
}

function observeNewLogItems() {
    const observer = new MutationObserver(() => {
        initializeLogItems();
        setupShowMoreButtons();
    });
    observer.observe(document.body, { childList: true, subtree: true });
}

document.addEventListener("DOMContentLoaded", function () {
    initializeLogItems();
    setupShowMoreButtons();
    observeNewLogItems();
});

// Handle dynamically added log items
document.querySelector("[button='load-more']").addEventListener("click", function () {
    setTimeout(() => {
        initializeLogItems();
        setupShowMoreButtons();
    }, 500); // Small delay to ensure new elements are in the DOM
});Ask AI

================================================================================

# CCIP Test Tokens - Faucets for EVM and Solana

Source: https://docs.chain.link/ccip/test-tokens
Extraction Method: playwright
Components: code_block(1), table(1)

# CCIP Test Tokens - Faucets for EVM and Solana
CCIP provides test tokens that you can mint on testnets for development and testing.

## Quick Start

### EVM Chains
Call the drip function directly on token contracts using the interface below or through block explorers:

astro-island,astro-slot,astro-static-slot{display:contents}(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).only=e;window.dispatchEvent(new Event("astro:only"));})();(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();⚠
### MetaMask Wallet Required
To mint test tokens, you need a compatible wallet. Please install MetaMask to continue.

#### Install Wallet:
[🔗Install MetaMaskBrowser extension](https://metamask.io/download/)After installing your wallet, refresh this page to detect it automatically.

Check for Wallets
### Solana Devnet
Use the dedicated faucet interface for CCIP-BnM tokens:

⚠
### Solana Wallet Required
To mint test tokens, you need a compatible wallet. Please install Phantom, Solflare or Backpack to continue.

#### Install Wallet:
[🔗Install PhantomMobile & Browser](https://phantom.app/download)[🔗Install SolflareMobile & Browser](https://solflare.com/download)[🔗Install BackpackMobile & Browser](https://www.backpack.app/download)After installing your wallet, refresh this page to detect it automatically.

Check for Wallets
#### Amount and rate limits

• The faucet mints 1 CCIP‑BnM per request.
• Requests are rate‑limited to about once every 3 hours per wallet.

#### Signature requirement
The faucet requires wallet signature verification. When you request tokens, your wallet will prompt you to sign a message.

• Message signing is free (no SOL required) and grants no spending permissions.
• After signature verification, the server executes the token mint transaction.

## About CCIP Test Tokens
CCIP supports specialized test tokens designed for cross-chain testing. These tokens are available on all CCIP-supported testnets.

Token | Type | Availability | Description
--- | --- | --- | ---
CCIP-BnM | Burn & Mint | All testnets | Burned on source chain, minted on destination chain
CCIP-LnM | Lock & Mint | Ethereum Sepolia (native)Other chains (wrapped as clCCIP-LnM) | Locked on Ethereum Sepolia, minted as wrapped tokens elsewhere

On EVM chains, tokens are minted by calling the drip function directly on contracts. On Solana Devnet, CCIP-BnM tokens are available through a dedicated faucet interface.

## LINK Token Faucets
For CCIP operations, you also need LINK tokens to pay transaction fees. Use the official Chainlink faucets to obtain LINK tokens on supported testnets by connecting your wallet.

## Block Explorer Method (EVM Chains)
For EVM chains, you call the drip function directly on token contracts. You can use block explorers instead of the interface above:

[Image: copy to clipboard]
```solidity
function drip(address to) external {
  _mint(to, 1e18);
}
```

### General Process
Navigate to the CCIP Directory to find token contract addresses, open the contract on the appropriate block explorer, connect your wallet, and call the drip function with your wallet address.

### Example: Ethereum Sepolia CCIP-BnM
Locate the CCIP-BnM contract address in the CCIP Directory under Ethereum Sepolia. Open the contract on Etherscan, navigate to the Contract tab, select Write Contract, and connect your wallet. Call the drip function with your wallet address to mint 1 CCIP-BnM token. Import the token in your wallet using this MetaMask guide.

[Image: caution]Educational Example Disclaimer

This page includes an educational example to use a Chainlink system, product, or service and is provided to
demonstrate how to interact with Chainlink's systems, products, and services to integrate them into your own. This
template is provided "AS IS" and "AS AVAILABLE" without warranties of any kind, it has not been audited, and it may be
missing key checks or error handling to make the usage of the system, product or service more clear. Do not use the
code in this example in a production environment without completing your own audits and application of best practices.
Neither Chainlink Labs, the Chainlink Foundation, nor Chainlink node operators are responsible for unintended outputs
that are generated due to errors in code.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }

================================================================================

# ChainlinkCCIP Tutorials

Source: https://docs.chain.link/ccip/tutorials
Extraction Method: playwright

# ChainlinkCCIP Tutorials
Chainlink Cross-Chain Interoperability Protocol (CCIP) enables secure cross-chain communication, allowing you to transfer tokens and data across different blockchain networks. These tutorials provide step-by-step instructions to help you understand and implement cross-chain functionality in your applications.

## Available Tutorials
Choose the tutorial section based on your blockchain platform:

• EVM Tutorials - Tutorials for Ethereum Virtual Machine compatible chains
• SVM Tutorials - Tutorials for Solana Virtual Machine chains
• Aptos Tutorials - Tutorials for Aptos chain

================================================================================

# Cross-Chain Token (CCT) Tutorials

Source: https://docs.chain.link/ccip/tutorials/cross-chain-tokens
Extraction Method: playwright

# Cross-Chain Token (CCT) Tutorials
[Image: note]Prerequisites

Familiarize yourself with the CCT standard and CCIP
architecture before proceeding with these tutorials.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }Before diving into the tutorials, it's important first to understand the overall procedure for enabling your tokens in CCIP. This procedure involves deploying tokens and token pools, registering administrative roles, and configuring token pools to enable secure token transfers using CCIP. The diagram below outlines the entire process:

astro-island,astro-slot,astro-static-slot{display:contents}(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).only=e;window.dispatchEvent(new Event("astro:only"));})();(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();[Image: Process for enabling a token in CCIP.]
### Understanding the Procedure
The steps in the diagram highlight the flow of actions needed to enable a token for cross-chain transfers. These steps will be the foundation of the tutorials. Whether you're working with an Externally Owned Account (EOA) or a Smart Account (such as one using a multisig scheme), the overall logic remains the same. You'll follow the same process to enable cross-chain token transfers, configure pools, and register administrative roles.

In the following tutorials, we will walk through each step of the process to give you hands-on experience, from deploying your token to registering and configuring token pools. The process will apply equally whether you use an EOA or a Smart Account (such as with multisig transactions), ensuring flexibility across different account types.

### Key Steps to Keep in Mind:

1. Token Deployment: If the token is not yet deployed, you'll deploy an ERC20-compatible token.
2. Admin Registration: The token administrator must be registered in the TokenAdminRegistry via self-service.
3. Pool Deployment and Configuration: Token pools are deployed, linked to tokens, and configured to manage cross-chain token transfers.

The tutorials will implement the logic of this process, which involves deploying and configuring token pools and registering administrative roles, step-by-step.

## Tutorials

• Deploy Using Remix IDE: Learn how to deploy and register cross-chain tokens using only your browser and Remix IDE.

No development environment setup required
Great for quick testing and learning
• Register from an EOA (Burn & Mint): Learn how to register a cross-chain token with the Burn & Mint mechanism using an EOA.

Hardhat version
Foundry version
• Register from an EOA (Lock & Mint): Learn how to register a cross-chain token with the Lock & Mint mechanism using an EOA.

Hardhat version
Foundry version
• Set Token Pool Rate Limits: Learn how to set rate limits for token pools to control cross-chain token transfers.

Hardhat version
Foundry version
• Register from a Safe (Burn & Mint): Learn how to register a cross-chain token with the Burn & Mint mechanism using a Safe Smart Account.

Hardhat version

[Image: caution]Educational Example Disclaimer

This page includes an educational example to use a Chainlink system, product, or service and is provided to
demonstrate how to interact with Chainlink's systems, products, and services to integrate them into your own. This
template is provided "AS IS" and "AS AVAILABLE" without warranties of any kind, it has not been audited, and it may be
missing key checks or error handling to make the usage of the system, product or service more clear. Do not use the
code in this example in a production environment without completing your own audits and application of best practices.
Neither Chainlink Labs, the Chainlink Foundation, nor Chainlink node operators are responsible for unintended outputs
that are generated due to errors in code.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }

================================================================================

# Transfer Tokens with Data

Source: https://docs.chain.link/ccip/tutorials/programmable-token-transfers
Extraction Method: playwright
Components: code_block(4), table(2)

# Transfer Tokens with Data
In this tutorial, you will use Chainlink CCIP to transfer tokens and arbitrary data between smart contracts on different blockchains. First, you will pay for the CCIP fees on the source blockchain using LINK. Then, you will use the same contract to pay CCIP fees in native gas tokens. For example, you would use ETH on Ethereum or AVAX on Avalanche.

[Image: note]Node Operator Rewards

CCIP rewards the oracle node and Risk Management node operators in LINK.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }[Image: caution]Transferring tokens

This tutorial uses the term "transferring tokens" even though the tokens are not technically transferred. Instead,
they are locked or burned on the source chain and then unlocked or minted on the destination chain. Read the Token
Pools section to understand the various mechanisms that are used to
transfer value across chains.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
## Before you begin

1. You should understand how to write, compile, deploy, and fund a smart contract. If you need to brush up on the basics, read this tutorial, which will guide you through using the Solidity programming language, interacting with the MetaMask wallet and working within the Remix Development Environment.
2. Your account must have some AVAX and LINK tokens on Avalanche Fuji and ETH tokens on Ethereum Sepolia. Learn how to Acquire testnet LINK.
3. Check the CCIP Directory to confirm that the tokens you will transfer are supported for your lane. In this example, you will transfer tokens from Avalanche Fuji to Ethereum Sepolia so check the list of supported tokens here.
4. Learn how to acquire CCIP test tokens. Following this guide, you should have CCIP-BnM tokens, and CCIP-BnM should appear in the list of your tokens in MetaMask.
5. Learn how to fund your contract. This guide shows how to fund your contract in LINK, but you can use the same guide for funding your contract with any ERC20 tokens as long as they appear in the list of tokens in MetaMask.
6. Follow the previous tutorial: Transfer tokens.

## Tutorial
[Image: note]Optimize your development with the CCIP local simulator

Enhance your development workflow using the Chainlink CCIP local
simulator, an installable package designed to simulate Chainlink
CCIP locally within your Hardhat and Foundry projects. It provides a robust smart contracts and scripts suite,
enabling you to build, deploy, and execute CCIP token transfers and arbitrary messages on a local Hardhat or Anvil
development node. With Chainlink Local, you can also work on forked nodes, ensuring a seamless transition of your
contracts to test networks without modifications. Start integrating Chainlink Local today to streamline your
development process and validate your CCIP implementations effectively.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }In this tutorial, you will send a string text and CCIP-BnM tokens between smart contracts on Avalanche Fuji and Ethereum Sepolia using CCIP. First, you will pay CCIP fees in LINK, then you will pay CCIP fees in native gas.

[Image: copy to clipboard]
```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import {IRouterClient} from "@chainlink/contracts-ccip/contracts/interfaces/IRouterClient.sol";
import {OwnerIsCreator} from "@chainlink/contracts/src/v0.8/shared/access/OwnerIsCreator.sol";
import {Client} from "@chainlink/contracts-ccip/contracts/libraries/Client.sol";
import {CCIPReceiver} from "@chainlink/contracts-ccip/contracts/applications/CCIPReceiver.sol";
import {IERC20} from "@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/utils/SafeERC20.sol";

/**
 * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
 * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

/// @title - A simple messenger contract for transferring/receiving tokens and data across chains.
contract ProgrammableTokenTransfers is CCIPReceiver, OwnerIsCreator {
    using SafeERC20 for IERC20;

    // Custom errors to provide more descriptive revert messages.
    error NotEnoughBalance(uint256 currentBalance, uint256 requiredBalance); // Used to make sure contract has enough token balance
    error NothingToWithdraw(); // Used when trying to withdraw Ether but there's nothing to withdraw.
    error FailedToWithdrawEth(address owner, address target, uint256 value); // Used when the withdrawal of Ether fails.
    error DestinationChainNotAllowed(uint64 destinationChainSelector); // Used when the destination chain has not been allowlisted by the contract owner.
    error SourceChainNotAllowed(uint64 sourceChainSelector); // Used when the source chain has not been allowlisted by the contract owner.
    error SenderNotAllowed(address sender); // Used when the sender has not been allowlisted by the contract owner.
    error InvalidReceiverAddress(); // Used when the receiver address is 0.

    // Event emitted when a message is sent to another chain.
    event MessageSent(
        bytes32 indexed messageId, // The unique ID of the CCIP message.
        uint64 indexed destinationChainSelector, // The chain selector of the destination chain.
        address receiver, // The address of the receiver on the destination chain.
        string text, // The text being sent.
        address token, // The token address that was transferred.
        uint256 tokenAmount, // The token amount that was transferred.
        address feeToken, // the token address used to pay CCIP fees.
        uint256 fees // The fees paid for sending the message.
    );

    // Event emitted when a message is received from another chain.
    event MessageReceived(
        bytes32 indexed messageId, // The unique ID of the CCIP message.
        uint64 indexed sourceChainSelector, // The chain selector of the source chain.
        address sender, // The address of the sender from the source chain.
        string text, // The text that was received.
        address token, // The token address that was transferred.
        uint256 tokenAmount // The token amount that was transferred.
    );

    bytes32 private s_lastReceivedMessageId; // Store the last received messageId.
    address private s_lastReceivedTokenAddress; // Store the last received token address.
    uint256 private s_lastReceivedTokenAmount; // Store the last received amount.
    string private s_lastReceivedText; // Store the last received text.

    // Mapping to keep track of allowlisted destination chains.
    mapping(uint64 => bool) public allowlistedDestinationChains;

    // Mapping to keep track of allowlisted source chains.
    mapping(uint64 => bool) public allowlistedSourceChains;

    // Mapping to keep track of allowlisted senders.
    mapping(address => bool) public allowlistedSenders;

    IERC20 private s_linkToken;

    /// @notice Constructor initializes the contract with the router address.
    /// @param _router The address of the router contract.
    /// @param _link The address of the link contract.
    constructor(address _router, address _link) CCIPReceiver(_router) {
        s_linkToken = IERC20(_link);
    }

    /// @dev Modifier that checks if the chain with the given destinationChainSelector is allowlisted.
    /// @param _destinationChainSelector The selector of the destination chain.
    modifier onlyAllowlistedDestinationChain(uint64 _destinationChainSelector) {
        if (!allowlistedDestinationChains[_destinationChainSelector])
            revert DestinationChainNotAllowed(_destinationChainSelector);
        _;
    }

    /// @dev Modifier that checks the receiver address is not 0.
    /// @param _receiver The receiver address.
    modifier validateReceiver(address _receiver) {
        if (_receiver == address(0)) revert InvalidReceiverAddress();
        _;
    }

    /// @dev Modifier that checks if the chain with the given sourceChainSelector is allowlisted and if the sender is allowlisted.
    /// @param _sourceChainSelector The selector of the destination chain.
    /// @param _sender The address of the sender.
    modifier onlyAllowlisted(uint64 _sourceChainSelector, address _sender) {
        if (!allowlistedSourceChains[_sourceChainSelector])
            revert SourceChainNotAllowed(_sourceChainSelector);
        if (!allowlistedSenders[_sender]) revert SenderNotAllowed(_sender);
        _;
    }

    /// @dev Updates the allowlist status of a destination chain for transactions.
    /// @notice This function can only be called by the owner.
    /// @param _destinationChainSelector The selector of the destination chain to be updated.
    /// @param allowed The allowlist status to be set for the destination chain.
    function allowlistDestinationChain(
        uint64 _destinationChainSelector,
        bool allowed
    ) external onlyOwner {
        allowlistedDestinationChains[_destinationChainSelector] = allowed;
    }

    /// @dev Updates the allowlist status of a source chain
    /// @notice This function can only be called by the owner.
    /// @param _sourceChainSelector The selector of the source chain to be updated.
    /// @param allowed The allowlist status to be set for the source chain.
    function allowlistSourceChain(
        uint64 _sourceChainSelector,
        bool allowed
    ) external onlyOwner {
        allowlistedSourceChains[_sourceChainSelector] = allowed;
    }

    /// @dev Updates the allowlist status of a sender for transactions.
    /// @notice This function can only be called by the owner.
    /// @param _sender The address of the sender to be updated.
    /// @param allowed The allowlist status to be set for the sender.
    function allowlistSender(address _sender, bool allowed) external onlyOwner {
        allowlistedSenders[_sender] = allowed;
    }

    /// @notice Sends data and transfer tokens to receiver on the destination chain.
    /// @notice Pay for fees in LINK.
    /// @dev Assumes your contract has sufficient LINK to pay for CCIP fees.
    /// @param _destinationChainSelector The identifier (aka selector) for the destination blockchain.
    /// @param _receiver The address of the recipient on the destination blockchain.
    /// @param _text The string data to be sent.
    /// @param _token token address.
    /// @param _amount token amount.
    /// @return messageId The ID of the CCIP message that was sent.
    function sendMessagePayLINK(
        uint64 _destinationChainSelector,
        address _receiver,
        string calldata _text,
        address _token,
        uint256 _amount
    )
        external
        onlyOwner
        onlyAllowlistedDestinationChain(_destinationChainSelector)
        validateReceiver(_receiver)
        returns (bytes32 messageId)
    {
        // Create an EVM2AnyMessage struct in memory with necessary information for sending a cross-chain message
        // address(linkToken) means fees are paid in LINK
        Client.EVM2AnyMessage memory evm2AnyMessage = _buildCCIPMessage(
            _receiver,
            _text,
            _token,
            _amount,
            address(s_linkToken)
        );

        // Initialize a router client instance to interact with cross-chain router
        IRouterClient router = IRouterClient(this.getRouter());

        // Get the fee required to send the CCIP message
        uint256 fees = router.getFee(_destinationChainSelector, evm2AnyMessage);

        uint256 requiredLinkBalance;
        if (_token == address(s_linkToken)) {
            // Required LINK Balance is the sum of fees and amount to transfer, if the token to transfer is LINK
            requiredLinkBalance = fees + _amount;
        } else {
            requiredLinkBalance = fees;
        }

        uint256 linkBalance = s_linkToken.balanceOf(address(this));

        if (requiredLinkBalance > linkBalance) {
            revert NotEnoughBalance(linkBalance, requiredLinkBalance);
        }

        // approve the Router to transfer LINK tokens on contract's behalf. It will spend the requiredLinkBalance
        s_linkToken.approve(address(router), requiredLinkBalance);

        // If sending a token other than LINK, approve it separately
        if (_token != address(s_linkToken)) {
            uint256 tokenBalance = IERC20(_token).balanceOf(address(this));
            if (_amount > tokenBalance) {
                revert NotEnoughBalance(tokenBalance, _amount);
            }
            // approve the Router to spend tokens on contract's behalf. It will spend the amount of the given token
            IERC20(_token).approve(address(router), _amount);
        }

        // Send the message through the router and store the returned message ID
        messageId = router.ccipSend(_destinationChainSelector, evm2AnyMessage);

        // Emit an event with message details
        emit MessageSent(
            messageId,
            _destinationChainSelector,
            _receiver,
            _text,
            _token,
            _amount,
            address(s_linkToken),
            fees
        );

        // Return the message ID
        return messageId;
    }

    /// @notice Sends data and transfer tokens to receiver on the destination chain.
    /// @notice Pay for fees in native gas.
    /// @dev Assumes your contract has sufficient native gas like ETH on Ethereum or POL on Polygon.
    /// @param _destinationChainSelector The identifier (aka selector) for the destination blockchain.
    /// @param _receiver The address of the recipient on the destination blockchain.
    /// @param _text The string data to be sent.
    /// @param _token token address.
    /// @param _amount token amount.
    /// @return messageId The ID of the CCIP message that was sent.
    function sendMessagePayNative(
        uint64 _destinationChainSelector,
        address _receiver,
        string calldata _text,
        address _token,
        uint256 _amount
    )
        external
        onlyOwner
        onlyAllowlistedDestinationChain(_destinationChainSelector)
        validateReceiver(_receiver)
        returns (bytes32 messageId)
    {
        // Create an EVM2AnyMessage struct in memory with necessary information for sending a cross-chain message
        // address(0) means fees are paid in native gas
        Client.EVM2AnyMessage memory evm2AnyMessage = _buildCCIPMessage(
            _receiver,
            _text,
            _token,
            _amount,
            address(0)
        );

        // Initialize a router client instance to interact with cross-chain router
        IRouterClient router = IRouterClient(this.getRouter());

        // Get the fee required to send the CCIP message
        uint256 fees = router.getFee(_destinationChainSelector, evm2AnyMessage);

        if (fees > address(this).balance)
            revert NotEnoughBalance(address(this).balance, fees);

        // approve the Router to spend tokens on contract's behalf. It will spend the amount of the given token
        IERC20(_token).approve(address(router), _amount);

        // Send the message through the router and store the returned message ID
        messageId = router.ccipSend{value: fees}(
            _destinationChainSelector,
            evm2AnyMessage
        );

        // Emit an event with message details
        emit MessageSent(
            messageId,
            _destinationChainSelector,
            _receiver,
            _text,
            _token,
            _amount,
            address(0),
            fees
        );

        // Return the message ID
        return messageId;
    }

    /**
     * @notice Returns the details of the last CCIP received message.
     * @dev This function retrieves the ID, text, token address, and token amount of the last received CCIP message.
     * @return messageId The ID of the last received CCIP message.
     * @return text The text of the last received CCIP message.
     * @return tokenAddress The address of the token in the last CCIP received message.
     * @return tokenAmount The amount of the token in the last CCIP received message.
     */
    function getLastReceivedMessageDetails()
        public
        view
        returns (
            bytes32 messageId,
            string memory text,
            address tokenAddress,
            uint256 tokenAmount
        )
    {
        return (
            s_lastReceivedMessageId,
            s_lastReceivedText,
            s_lastReceivedTokenAddress,
            s_lastReceivedTokenAmount
        );
    }

    /// handle a received message
    function _ccipReceive(
        Client.Any2EVMMessage memory any2EvmMessage
    )
        internal
        override
        onlyAllowlisted(
            any2EvmMessage.sourceChainSelector,
            abi.decode(any2EvmMessage.sender, (address))
        ) // Make sure source chain and sender are allowlisted
    {
        s_lastReceivedMessageId = any2EvmMessage.messageId; // fetch the messageId
        s_lastReceivedText = abi.decode(any2EvmMessage.data, (string)); // abi-decoding of the sent text
        // Expect one token to be transferred at once, but you can transfer several tokens.
        s_lastReceivedTokenAddress = any2EvmMessage.destTokenAmounts[0].token;
        s_lastReceivedTokenAmount = any2EvmMessage.destTokenAmounts[0].amount;

        emit MessageReceived(
            any2EvmMessage.messageId,
            any2EvmMessage.sourceChainSelector, // fetch the source chain identifier (aka selector)
            abi.decode(any2EvmMessage.sender, (address)), // abi-decoding of the sender address,
            abi.decode(any2EvmMessage.data, (string)),
            any2EvmMessage.destTokenAmounts[0].token,
            any2EvmMessage.destTokenAmounts[0].amount
        );
    }

    /// @notice Construct a CCIP message.
    /// @dev This function will create an EVM2AnyMessage struct with all the necessary information for programmable tokens transfer.
    /// @param _receiver The address of the receiver.
    /// @param _text The string data to be sent.
    /// @param _token The token to be transferred.
    /// @param _amount The amount of the token to be transferred.
    /// @param _feeTokenAddress The address of the token used for fees. Set address(0) for native gas.
    /// @return Client.EVM2AnyMessage Returns an EVM2AnyMessage struct which contains information for sending a CCIP message.
    function _buildCCIPMessage(
        address _receiver,
        string calldata _text,
        address _token,
        uint256 _amount,
        address _feeTokenAddress
    ) private pure returns (Client.EVM2AnyMessage memory) {
        // Set the token amounts
        Client.EVMTokenAmount[]
            memory tokenAmounts = new Client.EVMTokenAmount[](1);
        tokenAmounts[0] = Client.EVMTokenAmount({
            token: _token,
            amount: _amount
        });
        // Create an EVM2AnyMessage struct in memory with necessary information for sending a cross-chain message
        return
            Client.EVM2AnyMessage({
                receiver: abi.encode(_receiver), // ABI-encoded receiver address
                data: abi.encode(_text), // ABI-encoded string
                tokenAmounts: tokenAmounts, // The amount and type of token being transferred
                extraArgs: Client._argsToBytes(
                    // Additional arguments, setting gas limit and allowing out-of-order execution.
                    // Best Practice: For simplicity, the values are hardcoded. It is advisable to use a more dynamic approach
                    // where you set the extra arguments off-chain. This allows adaptation depending on the lanes, messages,
                    // and ensures compatibility with future CCIP upgrades. Read more about it here: https://docs.chain.link/ccip/concepts/best-practices/evm#using-extraargs
                    Client.GenericExtraArgsV2({
                        gasLimit: 200_000, // Gas limit for the callback on the destination chain
                        allowOutOfOrderExecution: true // Allows the message to be executed out of order relative to other messages from the same sender
                    })
                ),
                // Set the feeToken to a feeTokenAddress, indicating specific asset will be used for fees
                feeToken: _feeTokenAddress
            });
    }

    /// @notice Fallback function to allow the contract to receive Ether.
    /// @dev This function has no function body, making it a default function for receiving Ether.
    /// It is automatically called when Ether is sent to the contract without any data.
    receive() external payable {}

    /// @notice Allows the contract owner to withdraw the entire balance of Ether from the contract.
    /// @dev This function reverts if there are no funds to withdraw or if the transfer fails.
    /// It should only be callable by the owner of the contract.
    /// @param _beneficiary The address to which the Ether should be sent.
    function withdraw(address _beneficiary) public onlyOwner {
        // Retrieve the balance of this contract
        uint256 amount = address(this).balance;

        // Revert if there is nothing to withdraw
        if (amount == 0) revert NothingToWithdraw();

        // Attempt to send the funds, capturing the success status and discarding any return data
        (bool sent, ) = _beneficiary.call{value: amount}("");

        // Revert if the send failed, with information about the attempted transfer
        if (!sent) revert FailedToWithdrawEth(msg.sender, _beneficiary, amount);
    }

    /// @notice Allows the owner of the contract to withdraw all tokens of a specific ERC20 token.
    /// @dev This function reverts with a 'NothingToWithdraw' error if there are no tokens to withdraw.
    /// @param _beneficiary The address to which the tokens will be sent.
    /// @param _token The contract address of the ERC20 token to be withdrawn.
    function withdrawToken(
        address _beneficiary,
        address _token
    ) public onlyOwner {
        // Retrieve the balance of this contract
        uint256 amount = IERC20(_token).balanceOf(address(this));

        // Revert if there is nothing to withdraw
        if (amount == 0) revert NothingToWithdraw();

        IERC20(_token).safeTransfer(_beneficiary, amount);
    }
}
```

[Open in Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/CCIP/ProgrammableTokenTransfers.sol&autoCompile=true)[What is Remix?](/getting-started/conceptual-overview#what-is-remix)
### Deploy your contracts
To use this contract:

1. Open the contract in Remix.
2. Compile your contract.
3. Deploy, fund your sender contract on Avalanche Fuji and enable sending messages to Ethereum Sepolia:

Open MetaMask and select the network Avalanche Fuji.
In Remix IDE, click on Deploy & Run Transactions and select Injected Provider - MetaMask from the environment list. Remix will then interact with your MetaMask wallet to communicate with Avalanche Fuji.
Fill in your blockchain's router and LINK contract addresses. The router address can be found on the CCIP Directory and the LINK contract address on the LINK token contracts page. For Avalanche Fuji:

The router address is 0xF694E193200268f9a4868e4Aa017A0118C9a8177,
The LINK contract address is 0x0b9d5D9136855f6FEc3c0993feE6E9CE8a297846.

Click the transact button. After you confirm the transaction, the contract address appears on the Deployed Contracts list.
Note your contract address.
Open MetaMask and fund your contract with CCIP-BnM tokens. You can transfer 0.002 CCIP-BnM to your contract.
Enable your contract to send CCIP messages to Ethereum Sepolia:

In Remix IDE, under Deploy & Run Transactions, open the list of functions of your smart contract deployed on Avalanche Fuji.
Call the allowlistDestinationChain, setting the destination chain selector to 16015286601757825753 and setting allowed to true. Each chain selector is found on the CCIP Directory.
4. Deploy your receiver contract on Ethereum Sepolia and enable receiving messages from your sender contract:

Open MetaMask and select the network Ethereum Sepolia.
In Remix IDE, under Deploy & Run Transactions, make sure the environment is still Injected Provider - MetaMask.
Fill in your blockchain's router and LINK contract addresses. The router address can be found on the CCIP Directory and the LINK contract address on the LINK token contracts page. For Ethereum Sepolia, the router address is 0x0BF3dE8c5D3e8A2B34D2BEeB17ABfCeBaf363A59 and the LINK contract address is 0x779877A7B0D9E8603169DdbD7836e478b4624789.
Click the transact button. After you confirm the transaction, the contract address appears on the Deployed Contracts list.
Note your contract address.
Enable your contract to receive CCIP messages from Avalanche Fuji:

In Remix IDE, under Deploy & Run Transactions, open the list of functions of your smart contract deployed on Ethereum Sepolia.
Call the allowlistSourceChain with 14767482510784806043 as the source chain selector, and true as allowed. Each chain selector is found on the CCIP Directory.

Enable your contract to receive CCIP messages from the contract that you deployed on Avalanche Fuji:

In Remix IDE, under Deploy & Run Transactions, open the list of functions of your smart contract deployed on Ethereum Sepolia.
Call the allowlistSender with the contract address of the contract that you deployed on Avalanche Fuji, and true as allowed.

At this point, you have one sender contract on Avalanche Fuji and one receiver contract on Ethereum Sepolia. As security measures, you enabled the sender contract to send CCIP messages to Ethereum Sepolia and the receiver contract to receive CCIP messages from the sender on Avalanche Fuji.

Note: Another security measure enforces that only the router can call the _ccipReceive function. Read the explanation section for more details.

### Transfer and Receive tokens and data and pay in LINK
You will transfer 0.001 CCIP-BnM and a text. The CCIP fees for using CCIP will be paid in LINK. Read this explanation for a detailed description of the code example.

1. Open MetaMask and connect to Avalanche Fuji. Fund your contract with LINK tokens. You can transfer 70 LINK to your contract. In this example, LINK is used to pay the CCIP fees.
Note: This transaction fee is significantly higher than normal due to gas spikes on Sepolia. To run this example, you can get additional testnet LINK
from faucets.chain.link or use a supported testnet other than Sepolia.
2. Send a string data with tokens from Avalanche Fuji:

Open MetaMask and select the network Avalanche Fuji.

In Remix IDE, under Deploy & Run Transactions, open the list of functions of your smart contract deployed on Avalanche Fuji.

Fill in the arguments of the sendMessagePayLINK function:

ArgumentValue and Description_destinationChainSelector16015286601757825753  CCIP Chain identifier of the destination blockchain (Ethereum Sepolia in this example). You can find each chain selector on the CCIP Directory._receiverYour receiver contract address on Ethereum Sepolia.  The destination contract address._textHello World!Any string_token0xD21341536c5cF5EB1bcb58f6723cE26e8D8E90e4 The CCIP-BnM contract address at the source chain (Avalanche Fuji in this example). You can find all the addresses for each supported blockchain on the CCIP Directory._amount1000000000000000  The token amount (0.001 CCIP-BnM).

Click on transact and confirm the transaction on MetaMask.

After the transaction is successful, record the transaction hash. Here is an example of a transaction on Avalanche Fuji.
      Gas price spikes  Under normal circumstances, transactions on the Ethereum Sepolia network require significantly fewer tokens to pay for gas. However, during exceptional periods of high gas price spikes, your transactions may fail if not sufficiently funded. In such cases, you may need to fund your contract with additional tokens. We recommend paying for your CCIP transactions in LINK tokens (rather than native tokens) as you can obtain extra LINK testnet tokens from faucets.chain.link. If you encounter a transaction failure due to these gas price spikes, please add additional LINK tokens to your contract and try again.
Alternatively, you can use a supported testnet other than Sepolia.
3. Open the CCIP explorer and search your cross-chain transaction using the transaction hash.
4. The CCIP transaction is completed once the status is marked as "Success". In this example, the CCIP message ID is 0x99a15381125e740c43a60f03c6b011ae05a3541998ca482fb5a4814417627df8.
5. Check the receiver contract on the destination chain:

Open MetaMask and select the network Ethereum Sepolia.

In Remix IDE, under Deploy & Run Transactions, open the list of functions of your smart contract deployed on Ethereum Sepolia.

Call the getLastReceivedMessageDetails function.

  

Notice the received messageId is 0x99a15381125e740c43a60f03c6b011ae05a3541998ca482fb5a4814417627df8, the received text is Hello World!, the token address is 0xFd57b4ddBf88a4e07fF4e34C487b99af2Fe82a05 (CCIP-BnM token address on Ethereum Sepolia) and the token amount is 1000000000000000 (0.001 CCIP-BnM).

Note: These example contracts are designed to work bi-directionally. As an exercise, you can use them to transfer tokens with data from Avalanche Fuji to Ethereum Sepolia and from Ethereum Sepolia back to Avalanche Fuji.

### Transfer and Receive tokens and data and pay in native
You will transfer 0.001 CCIP-BnM and a text. The CCIP fees for using CCIP will be paid in Avalanche's native AVAX. Read this explanation for a detailed description of the code example.

1. Open MetaMask and connect to Avalanche Fuji. Fund your contract with AVAX tokens. You can transfer 0.2 AVAX to your contract. The native gas tokens are used to pay the CCIP fees.
2. Send a string data with tokens from Avalanche Fuji:

Open MetaMask and select the network Avalanche Fuji.

In Remix IDE, under Deploy & Run Transactions, open the list of functions of your smart contract deployed on Avalanche Fuji.

Fill in the arguments of the sendMessagePayNative function:

ArgumentValue and Description_destinationChainSelector16015286601757825753  CCIP Chain identifier of the destination blockchain (Ethereum Sepolia in this example). You can find each chain selector on the CCIP Directory._receiverYour receiver contract address at Ethereum Sepolia.  The destination contract address._textHello World!Any string_token0xD21341536c5cF5EB1bcb58f6723cE26e8D8E90e4 The CCIP-BnM contract address at the source chain (Avalanche Fuji in this example). You can find all the addresses for each supported blockchain on the CCIP Directory._amount1000000000000000  The token amount (0.001 CCIP-BnM).

Click on transact and confirm the transaction on MetaMask.

Once the transaction is successful, note the transaction hash. Here is an example of a transaction on Avalanche Fuji.
      Gas price spikes  Under normal circumstances, transactions on the Ethereum Sepolia network require significantly fewer tokens to pay for gas. However, during exceptional periods of high gas price spikes, your transactions may fail if not sufficiently funded. In such cases, you may need to fund your contract with additional tokens. We recommend paying for your CCIP transactions in LINK tokens (rather than native tokens) as you can obtain extra LINK testnet tokens from faucets.chain.link. If you encounter a transaction failure due to these gas price spikes, please add additional LINK tokens to your contract and try again.
Alternatively, you can use a supported testnet other than Sepolia.
3. Open the CCIP explorer and search your cross-chain transaction using the transaction hash.
4. The CCIP transaction is completed once the status is marked as "Success". In this example, the CCIP message ID is 0x32bf96ac8b01fe3f04ffa548a3403b3105b4ed479eff407ff763b7539a1d43bd. Note that CCIP fees are denominated in LINK. Even if CCIP fees are paid using native gas tokens, node operators will be paid in LINK.
5. Check the receiver contract on the destination chain:

Open MetaMask and select the network Ethereum Sepolia.

In Remix IDE, under Deploy & Run Transactions, open the list of functions of your smart contract deployed on Ethereum Sepolia.

Call the getLastReceivedMessageDetails function.

  

Notice the received messageId is 0x32bf96ac8b01fe3f04ffa548a3403b3105b4ed479eff407ff763b7539a1d43bd, the received text is Hello World!, the token address is 0xFd57b4ddBf88a4e07fF4e34C487b99af2Fe82a05 (CCIP-BnM token address on Ethereum Sepolia) and the token amount is 1000000000000000 (0.001 CCIP-BnM).

Note: These example contracts are designed to work bi-directionally. As an exercise, you can use them to transfer tokens with data from Avalanche Fuji to Ethereum Sepolia and from Ethereum Sepolia back to Avalanche Fuji.

## Explanation
[Image: note]Integrate Chainlink CCIP v1.6.0 into your project

(()=>{var a=(s,i,o)=>{let r=async()=>{await(await s())()},t=typeof i.value=="object"?i.value:void 0,c={rootMargin:t==null?void 0:t.rootMargin},n=new IntersectionObserver(e=>{for(let l of e)if(l.isIntersecting){n.disconnect(),r();break}},c);for(let e of o.children)n.observe(e)};(self.Astro||(self.Astro={})).visible=a;window.dispatchEvent(new Event("astro:visible"));})();npmyarnfoundryIf you use NPM, install the @chainlink/contracts-ccip NPM package:

[Image: copy to clipboard]
```shell
npm install @chainlink/contracts-ccip@1.6.0
```

If you use Yarn, install the @chainlink/contracts-ccip NPM package:

[Image: copy to clipboard]
```shell
yarn add @chainlink/contracts-ccip@1.6.0
```

If you use Foundry, install the package:

[Image: copy to clipboard]
```shell
forge install smartcontractkit/chainlink-ccip@2114b90f39c82c052e05af7c33d42c1ae98f4180
```

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }The smart contract featured in this tutorial is designed to interact with CCIP to transfer and receive tokens and data. The contract code contains supporting comments clarifying the functions, events, and underlying logic. Here we will further explain initializing the contract and sending data with tokens.

### Initializing the contract
When deploying the contract, we define the router address and LINK contract address of the blockchain we deploy the contract on.
Defining the router address is useful for the following:

• Sender part:

Calls the router's getFee function to estimate the CCIP fees.
Calls the router's ccipSend function to send CCIP messages.
• Receiver part:

The contract inherits from CCIPReceiver, which serves as a base contract for receiver contracts. This contract requires that child contracts implement the _ccipReceive function. _ccipReceive is called by the ccipReceive function, which ensures that only the router can deliver CCIP messages to the receiver contract.

### Transferring tokens and data and pay in LINK
The sendMessagePayLINK function undertakes six primary operations:

1. Call the _buildCCIPMessage private function to construct a CCIP-compatible message using the EVM2AnyMessage struct:

The _receiver address is encoded in bytes to accommodate non-EVM destination blockchains with distinct address formats. The encoding is achieved through abi.encode.

The data is encoded from a string to bytes using abi.encode.

The tokenAmounts is an array, with each element comprising an EVMTokenAmount struct containing the token address and amount. The array contains one element where the _token (token address) and _amount (token amount) are passed by the user when calling the sendMessagePayLINK function.

The extraArgs specifies the gasLimit for relaying the message to the recipient contract on the destination blockchain. In this example, the gasLimit is set to `200000.

The _feeTokenAddress designates the token address used for CCIP fees. Here, address(linkToken) signifies payment in LINK.
      Best Practices  This example is simplified for educational purposes. For production code, please adhere to the following best practices:

Do Not Hardcode extraArgs: In this example, extraArgs are hardcoded within the contract for simplicity. It is recommended to make extraArgs mutable. For instance, you can construct extraArgs off-chain and pass them into your function calls, or store them in a storage variable that can be updated as needed. This approach ensures that extraArgs remain backward compatible with future CCIP upgrades. Refer to the Best Practices guide for more information.

Validate the Destination Chain: Always ensure that the destination chain is valid and supported before sending messages.

Understand allowOutOfOrderExecution Usage: This example sets allowOutOfOrderExecution to true (see GenericExtraArgsV2). Read the Best Practices: Setting allowOutOfOrderExecution to learn more about this parameter.

Understand CCIP Service Limits: Review the CCIP Service Limits for constraints on message data size, execution gas, and the number of tokens per transaction. If your requirements exceed these limits, you may need to contact the Chainlink Labs Team.

Following these best practices ensures that your contract is robust, future-proof, and compliant with CCIP standards.
2. Computes the fees by invoking the router's getFee function.
3. Ensures your contract balance in LINK is enough to cover the fees.
4. Grants the router contract permission to deduct the fees from the contract's LINK balance.
5. Grants the router contract permission to deduct the amount from the contract's CCIP-BnM balance.
6. Dispatches the CCIP message to the destination chain by executing the router's ccipSend function.

Note: As a security measure, the sendMessagePayLINK function is protected by the onlyAllowlistedDestinationChain, ensuring the contract owner has allowlisted a destination chain.

### Transferring tokens and data and pay in native
The sendMessagePayNative function undertakes five primary operations:

1. Call the _buildCCIPMessage private function to construct a CCIP-compatible message using the EVM2AnyMessage struct:

The _receiver address is encoded in bytes to accommodate non-EVM destination blockchains with distinct address formats. The encoding is achieved through abi.encode.

The data is encoded from a string to bytes using abi.encode.

The tokenAmounts is an array, with each element comprising an EVMTokenAmount struct containing the token address and amount. The array contains one element where the _token (token address) and _amount (token amount) are passed by the user when calling the sendMessagePayNative function.

The extraArgs specifies the gasLimit for relaying the message to the recipient contract on the destination blockchain. In this example, the gasLimit is set to `200000.

The _feeTokenAddress designates the token address used for CCIP fees. Here, address(0) signifies payment in native gas tokens (ETH).
      Best Practices  This example is simplified for educational purposes. For production code, please adhere to the following best practices:

Do Not Hardcode extraArgs: In this example, extraArgs are hardcoded within the contract for simplicity. It is recommended to make extraArgs mutable. For instance, you can construct extraArgs off-chain and pass them into your function calls, or store them in a storage variable that can be updated as needed. This approach ensures that extraArgs remain backward compatible with future CCIP upgrades. Refer to the Best Practices guide for more information.

Validate the Destination Chain: Always ensure that the destination chain is valid and supported before sending messages.

Understand allowOutOfOrderExecution Usage: This example sets allowOutOfOrderExecution to true (see GenericExtraArgsV2). Read the Best Practices: Setting allowOutOfOrderExecution to learn more about this parameter.

Understand CCIP Service Limits: Review the CCIP Service Limits for constraints on message data size, execution gas, and the number of tokens per transaction. If your requirements exceed these limits, you may need to contact the Chainlink Labs Team.

Following these best practices ensures that your contract is robust, future-proof, and compliant with CCIP standards.
2. Computes the fees by invoking the router's getFee function.
3. Ensures your contract balance in native gas is enough to cover the fees.
4. Grants the router contract permission to deduct the amount from the contract's CCIP-BnM balance.
5. Dispatches the CCIP message to the destination chain by executing the router's ccipSend function. Note: msg.value is set because you pay in native gas.

Note: As a security measure, the sendMessagePayNative function is protected by the onlyAllowlistedDestinationChain, ensuring the contract owner has allowlisted a destination chain.

### Receiving messages
On the destination blockchain, the router invokes the _ccipReceive function which expects a Any2EVMMessage struct that contains:

• The CCIP messageId.
• The sourceChainSelector.
• The sender address in bytes format. Given that the sender is known to be a contract deployed on an EVM-compatible blockchain, the address is decoded from bytes to an Ethereum address using the ABI specifications.
• The tokenAmounts is an array containing received tokens and their respective amounts. Given that only one token transfer is expected, the first element of the array is extracted.
• The data, which is also in bytes format. Given a string is expected, the data is decoded from bytes to a string using the ABI specifications.

Note: Three important security measures are applied:

• _ccipReceive is called by the ccipReceive function, which ensures that only the router can deliver CCIP messages to the receiver contract. See the onlyRouter modifier for more information.
• The modifier onlyAllowlisted ensures that only a call from an allowlisted source chain and sender is accepted.

[Image: caution]Educational Example Disclaimer

This page includes an educational example to use a Chainlink system, product, or service and is provided to
demonstrate how to interact with Chainlink's systems, products, and services to integrate them into your own. This
template is provided "AS IS" and "AS AVAILABLE" without warranties of any kind, it has not been audited, and it may be
missing key checks or error handling to make the usage of the system, product or service more clear. Do not use the
code in this example in a production environment without completing your own audits and application of best practices.
Neither Chainlink Labs, the Chainlink Foundation, nor Chainlink node operators are responsible for unintended outputs
that are generated due to errors in code.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }

================================================================================

# Transfer Tokens with Data - Defensive Example

Source: https://docs.chain.link/ccip/tutorials/programmable-token-transfers-defensive
Extraction Method: playwright
Components: code_block(4), table(2)

# Transfer Tokens with Data - Defensive Example
This tutorial extends the programmable token transfers example. It uses Chainlink CCIP to transfer tokens and arbitrary data between smart contracts on different blockchains, and focuses on defensive coding in the receiver contract. In the event of a specified error during the CCIP message reception, the contract locks the tokens. Locking the tokens allows the owner to recover and redirect them as needed. Defensive coding is crucial as it enables the recovery of locked tokens and ensures the protection of your users' assets.

[Image: caution]Transferring tokens

This tutorial uses the term "transferring tokens" even though the tokens are not technically transferred. Instead,
they are locked or burned on the source chain and then unlocked or minted on the destination chain. Read the Token
Pools section to understand the various mechanisms that are used to
transfer value across chains.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
## Before you begin

1. You should understand how to write, compile, deploy, and fund a smart contract. If you need to brush up on the basics, read this tutorial, which will guide you through using the Solidity programming language, interacting with the MetaMask wallet and working within the Remix Development Environment.
2. Your account must have some AVAX and LINK tokens on Avalanche Fuji and ETH tokens on Ethereum Sepolia. Learn how to Acquire testnet LINK.
3. Check the CCIP Directory to confirm that the tokens you will transfer are supported for your lane. In this example, you will transfer tokens from Avalanche Fuji to Ethereum Sepolia so check the list of supported tokens here.
4. Learn how to acquire CCIP test tokens. Following this guide, you should have CCIP-BnM tokens, and CCIP-BnM should appear in the list of your tokens in MetaMask.
5. Learn how to fund your contract. This guide shows how to fund your contract in LINK, but you can use the same guide for funding your contract with any ERC20 tokens as long as they appear in the list of tokens in MetaMask.
6. Follow the previous tutorial: Transfer Tokens with Data to learn how to make programmable token transfers using CCIP.

## Tutorial
[Image: note]Optimize your development with the CCIP local simulator

Enhance your development workflow using the Chainlink CCIP local
simulator, an installable package designed to simulate Chainlink
CCIP locally within your Hardhat and Foundry projects. It provides a robust smart contracts and scripts suite,
enabling you to build, deploy, and execute CCIP token transfers and arbitrary messages on a local Hardhat or Anvil
development node. With Chainlink Local, you can also work on forked nodes, ensuring a seamless transition of your
contracts to test networks without modifications. Start integrating Chainlink Local today to streamline your
development process and validate your CCIP implementations effectively.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }In this guide, you'll initiate a transaction from a smart contract on Avalanche Fuji, sending a string text and CCIP-BnM tokens to another smart contract on Ethereum Sepolia using CCIP. However, a deliberate failure in the processing logic will occur upon reaching the receiver contract. This tutorial will demonstrate a graceful error-handling approach, allowing the contract owner to recover the locked tokens.

[Image: note]Correctly estimate your gas limit

It is crucial to thoroughly test all scenarios to accurately estimate the required gas limit, including for failure
scenarios. Be aware that the gas used to execute the error-handling logic for failure scenarios may be higher than
that for successful scenarios.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }[Image: copy to clipboard]
```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import {IRouterClient} from "@chainlink/contracts-ccip/contracts/interfaces/IRouterClient.sol";
import {OwnerIsCreator} from "@chainlink/contracts/src/v0.8/shared/access/OwnerIsCreator.sol";
import {Client} from "@chainlink/contracts-ccip/contracts/libraries/Client.sol";
import {CCIPReceiver} from "@chainlink/contracts-ccip/contracts/applications/CCIPReceiver.sol";
import {IERC20} from "@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/utils/SafeERC20.sol";
import {EnumerableMap} from "@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/utils/structs/EnumerableMap.sol";

/**
 * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
 * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

/// @title - A simple messenger contract for transferring/receiving tokens and data across chains.
/// @dev - This example shows how to recover tokens in case of revert
contract ProgrammableDefensiveTokenTransfers is CCIPReceiver, OwnerIsCreator {
    using EnumerableMap for EnumerableMap.Bytes32ToUintMap;
    using SafeERC20 for IERC20;

    // Custom errors to provide more descriptive revert messages.
    error NotEnoughBalance(uint256 currentBalance, uint256 requiredBalance); // Used to make sure contract has enough token balance
    error NothingToWithdraw(); // Used when trying to withdraw Ether but there's nothing to withdraw.
    error FailedToWithdrawEth(address owner, address target, uint256 value); // Used when the withdrawal of Ether fails.
    error DestinationChainNotAllowlisted(uint64 destinationChainSelector); // Used when the destination chain has not been allowlisted by the contract owner.
    error SourceChainNotAllowed(uint64 sourceChainSelector); // Used when the source chain has not been allowlisted by the contract owner.
    error SenderNotAllowed(address sender); // Used when the sender has not been allowlisted by the contract owner.
    error InvalidReceiverAddress(); // Used when the receiver address is 0.
    error OnlySelf(); // Used when a function is called outside of the contract itself.
    error ErrorCase(); // Used when simulating a revert during message processing.
    error MessageNotFailed(bytes32 messageId);

    // Example error code, could have many different error codes.
    enum ErrorCode {
        // RESOLVED is first so that the default value is resolved.
        RESOLVED,
        // Could have any number of error codes here.
        FAILED
    }

    struct FailedMessage {
        bytes32 messageId;
        ErrorCode errorCode;
    }

    // Event emitted when a message is sent to another chain.
    event MessageSent(
        bytes32 indexed messageId, // The unique ID of the CCIP message.
        uint64 indexed destinationChainSelector, // The chain selector of the destination chain.
        address receiver, // The address of the receiver on the destination chain.
        string text, // The text being sent.
        address token, // The token address that was transferred.
        uint256 tokenAmount, // The token amount that was transferred.
        address feeToken, // the token address used to pay CCIP fees.
        uint256 fees // The fees paid for sending the message.
    );

    // Event emitted when a message is received from another chain.
    event MessageReceived(
        bytes32 indexed messageId, // The unique ID of the CCIP message.
        uint64 indexed sourceChainSelector, // The chain selector of the source chain.
        address sender, // The address of the sender from the source chain.
        string text, // The text that was received.
        address token, // The token address that was transferred.
        uint256 tokenAmount // The token amount that was transferred.
    );

    event MessageFailed(bytes32 indexed messageId, bytes reason);
    event MessageRecovered(bytes32 indexed messageId);

    bytes32 private s_lastReceivedMessageId; // Store the last received messageId.
    address private s_lastReceivedTokenAddress; // Store the last received token address.
    uint256 private s_lastReceivedTokenAmount; // Store the last received amount.
    string private s_lastReceivedText; // Store the last received text.

    // Mapping to keep track of allowlisted destination chains.
    mapping(uint64 => bool) public allowlistedDestinationChains;

    // Mapping to keep track of allowlisted source chains.
    mapping(uint64 => bool) public allowlistedSourceChains;

    // Mapping to keep track of allowlisted senders.
    mapping(address => bool) public allowlistedSenders;

    IERC20 private s_linkToken;

    // The message contents of failed messages are stored here.
    mapping(bytes32 messageId => Client.Any2EVMMessage contents)
        public s_messageContents;

    // Contains failed messages and their state.
    EnumerableMap.Bytes32ToUintMap internal s_failedMessages;

    // This is used to simulate a revert in the processMessage function.
    bool internal s_simRevert = false;

    /// @notice Constructor initializes the contract with the router address.
    /// @param _router The address of the router contract.
    /// @param _link The address of the link contract.
    constructor(address _router, address _link) CCIPReceiver(_router) {
        s_linkToken = IERC20(_link);
    }

    /// @dev Modifier that checks if the chain with the given destinationChainSelector is allowlisted.
    /// @param _destinationChainSelector The selector of the destination chain.
    modifier onlyAllowlistedDestinationChain(uint64 _destinationChainSelector) {
        if (!allowlistedDestinationChains[_destinationChainSelector])
            revert DestinationChainNotAllowlisted(_destinationChainSelector);
        _;
    }

    /// @dev Modifier that checks if the chain with the given sourceChainSelector is allowlisted and if the sender is allowlisted.
    /// @param _sourceChainSelector The selector of the destination chain.
    /// @param _sender The address of the sender.
    modifier onlyAllowlisted(uint64 _sourceChainSelector, address _sender) {
        if (!allowlistedSourceChains[_sourceChainSelector])
            revert SourceChainNotAllowed(_sourceChainSelector);
        if (!allowlistedSenders[_sender]) revert SenderNotAllowed(_sender);
        _;
    }

    /// @dev Modifier that checks the receiver address is not 0.
    /// @param _receiver The receiver address.
    modifier validateReceiver(address _receiver) {
        if (_receiver == address(0)) revert InvalidReceiverAddress();
        _;
    }

    /// @dev Modifier to allow only the contract itself to execute a function.
    /// Throws an exception if called by any account other than the contract itself.
    modifier onlySelf() {
        if (msg.sender != address(this)) revert OnlySelf();
        _;
    }

    /// @dev Updates the allowlist status of a destination chain for transactions.
    /// @notice This function can only be called by the owner.
    /// @param _destinationChainSelector The selector of the destination chain to be updated.
    /// @param allowed The allowlist status to be set for the destination chain.
    function allowlistDestinationChain(
        uint64 _destinationChainSelector,
        bool allowed
    ) external onlyOwner {
        allowlistedDestinationChains[_destinationChainSelector] = allowed;
    }

    /// @dev Updates the allowlist status of a source chain
    /// @notice This function can only be called by the owner.
    /// @param _sourceChainSelector The selector of the source chain to be updated.
    /// @param allowed The allowlist status to be set for the source chain.
    function allowlistSourceChain(
        uint64 _sourceChainSelector,
        bool allowed
    ) external onlyOwner {
        allowlistedSourceChains[_sourceChainSelector] = allowed;
    }

    /// @dev Updates the allowlist status of a sender for transactions.
    /// @notice This function can only be called by the owner.
    /// @param _sender The address of the sender to be updated.
    /// @param allowed The allowlist status to be set for the sender.
    function allowlistSender(address _sender, bool allowed) external onlyOwner {
        allowlistedSenders[_sender] = allowed;
    }

    /// @notice Sends data and transfer tokens to receiver on the destination chain.
    /// @notice Pay for fees in LINK.
    /// @dev Assumes your contract has sufficient LINK to pay for CCIP fees.
    /// @param _destinationChainSelector The identifier (aka selector) for the destination blockchain.
    /// @param _receiver The address of the recipient on the destination blockchain.
    /// @param _text The string data to be sent.
    /// @param _token token address.
    /// @param _amount token amount.
    /// @return messageId The ID of the CCIP message that was sent.
    function sendMessagePayLINK(
        uint64 _destinationChainSelector,
        address _receiver,
        string calldata _text,
        address _token,
        uint256 _amount
    )
        external
        onlyOwner
        onlyAllowlistedDestinationChain(_destinationChainSelector)
        validateReceiver(_receiver)
        returns (bytes32 messageId)
    {
        // Create an EVM2AnyMessage struct in memory with necessary information for sending a cross-chain message
        // address(linkToken) means fees are paid in LINK
        Client.EVM2AnyMessage memory evm2AnyMessage = _buildCCIPMessage(
            _receiver,
            _text,
            _token,
            _amount,
            address(s_linkToken)
        );

        // Initialize a router client instance to interact with cross-chain router
        IRouterClient router = IRouterClient(this.getRouter());

        // Get the fee required to send the CCIP message
        uint256 fees = router.getFee(_destinationChainSelector, evm2AnyMessage);

        uint256 requiredLinkBalance;
        if (_token == address(s_linkToken)) {
            // Required LINK Balance is the sum of fees and amount to transfer, if the token to transfer is LINK
            requiredLinkBalance = fees + _amount;
        } else {
            requiredLinkBalance = fees;
        }

        uint256 linkBalance = s_linkToken.balanceOf(address(this));

        if (requiredLinkBalance > linkBalance) {
            revert NotEnoughBalance(linkBalance, requiredLinkBalance);
        }

        // approve the Router to transfer LINK tokens on contract's behalf. It will spend the requiredLinkBalance
        s_linkToken.approve(address(router), requiredLinkBalance);

        // If sending a token other than LINK, approve it separately
        if (_token != address(s_linkToken)) {
            uint256 tokenBalance = IERC20(_token).balanceOf(address(this));
            if (_amount > tokenBalance) {
                revert NotEnoughBalance(tokenBalance, _amount);
            }
            // approve the Router to spend tokens on contract's behalf. It will spend the amount of the given token
            IERC20(_token).approve(address(router), _amount);
        }

        // Send the message through the router and store the returned message ID
        messageId = router.ccipSend(_destinationChainSelector, evm2AnyMessage);

        // Emit an event with message details
        emit MessageSent(
            messageId,
            _destinationChainSelector,
            _receiver,
            _text,
            _token,
            _amount,
            address(s_linkToken),
            fees
        );

        // Return the message ID
        return messageId;
    }

    /// @notice Sends data and transfer tokens to receiver on the destination chain.
    /// @notice Pay for fees in native gas.
    /// @dev Assumes your contract has sufficient native gas like ETH on Ethereum or POL on Polygon.
    /// @param _destinationChainSelector The identifier (aka selector) for the destination blockchain.
    /// @param _receiver The address of the recipient on the destination blockchain.
    /// @param _text The string data to be sent.
    /// @param _token token address.
    /// @param _amount token amount.
    /// @return messageId The ID of the CCIP message that was sent.
    function sendMessagePayNative(
        uint64 _destinationChainSelector,
        address _receiver,
        string calldata _text,
        address _token,
        uint256 _amount
    )
        external
        onlyOwner
        onlyAllowlistedDestinationChain(_destinationChainSelector)
        validateReceiver(_receiver)
        returns (bytes32 messageId)
    {
        // Create an EVM2AnyMessage struct in memory with necessary information for sending a cross-chain message
        // address(0) means fees are paid in native gas
        Client.EVM2AnyMessage memory evm2AnyMessage = _buildCCIPMessage(
            _receiver,
            _text,
            _token,
            _amount,
            address(0)
        );

        // Initialize a router client instance to interact with cross-chain router
        IRouterClient router = IRouterClient(this.getRouter());

        // Get the fee required to send the CCIP message
        uint256 fees = router.getFee(_destinationChainSelector, evm2AnyMessage);

        if (fees > address(this).balance)
            revert NotEnoughBalance(address(this).balance, fees);

        // approve the Router to spend tokens on contract's behalf. It will spend the amount of the given token
        IERC20(_token).approve(address(router), _amount);

        // Send the message through the router and store the returned message ID
        messageId = router.ccipSend{value: fees}(
            _destinationChainSelector,
            evm2AnyMessage
        );

        // Emit an event with message details
        emit MessageSent(
            messageId,
            _destinationChainSelector,
            _receiver,
            _text,
            _token,
            _amount,
            address(0),
            fees
        );

        // Return the message ID
        return messageId;
    }

    /**
     * @notice Returns the details of the last CCIP received message.
     * @dev This function retrieves the ID, text, token address, and token amount of the last received CCIP message.
     * @return messageId The ID of the last received CCIP message.
     * @return text The text of the last received CCIP message.
     * @return tokenAddress The address of the token in the last CCIP received message.
     * @return tokenAmount The amount of the token in the last CCIP received message.
     */
    function getLastReceivedMessageDetails()
        public
        view
        returns (
            bytes32 messageId,
            string memory text,
            address tokenAddress,
            uint256 tokenAmount
        )
    {
        return (
            s_lastReceivedMessageId,
            s_lastReceivedText,
            s_lastReceivedTokenAddress,
            s_lastReceivedTokenAmount
        );
    }

    /**
     * @notice Retrieves a paginated list of failed messages.
     * @dev This function returns a subset of failed messages defined by `offset` and `limit` parameters. It ensures that the pagination parameters are within the bounds of the available data set.
     * @param offset The index of the first failed message to return, enabling pagination by skipping a specified number of messages from the start of the dataset.
     * @param limit The maximum number of failed messages to return, restricting the size of the returned array.
     * @return failedMessages An array of `FailedMessage` struct, each containing a `messageId` and an `errorCode` (RESOLVED or FAILED), representing the requested subset of failed messages. The length of the returned array is determined by the `limit` and the total number of failed messages.
     */
    function getFailedMessages(
        uint256 offset,
        uint256 limit
    ) external view returns (FailedMessage[] memory) {
        uint256 length = s_failedMessages.length();

        // Calculate the actual number of items to return (can't exceed total length or requested limit)
        uint256 returnLength = (offset + limit > length)
            ? length - offset
            : limit;
        FailedMessage[] memory failedMessages = new FailedMessage[](
            returnLength
        );

        // Adjust loop to respect pagination (start at offset, end at offset + limit or total length)
        for (uint256 i = 0; i < returnLength; i++) {
            (bytes32 messageId, uint256 errorCode) = s_failedMessages.at(
                offset + i
            );
            failedMessages[i] = FailedMessage(messageId, ErrorCode(errorCode));
        }
        return failedMessages;
    }

    /// @notice The entrypoint for the CCIP router to call. This function should
    /// never revert, all errors should be handled internally in this contract.
    /// @param any2EvmMessage The message to process.
    /// @dev Extremely important to ensure only router calls this.
    function ccipReceive(
        Client.Any2EVMMessage calldata any2EvmMessage
    )
        external
        override
        onlyRouter
        onlyAllowlisted(
            any2EvmMessage.sourceChainSelector,
            abi.decode(any2EvmMessage.sender, (address))
        ) // Make sure the source chain and sender are allowlisted
    {
        /* solhint-disable no-empty-blocks */
        try this.processMessage(any2EvmMessage) {
            // Intentionally empty in this example; no action needed if processMessage succeeds
        } catch (bytes memory err) {
            // Could set different error codes based on the caught error. Each could be
            // handled differently.
            s_failedMessages.set(
                any2EvmMessage.messageId,
                uint256(ErrorCode.FAILED)
            );
            s_messageContents[any2EvmMessage.messageId] = any2EvmMessage;
            // Don't revert so CCIP doesn't revert. Emit event instead.
            // The message can be retried later without having to do manual execution of CCIP.
            emit MessageFailed(any2EvmMessage.messageId, err);
            return;
        }
    }

    /// @notice Serves as the entry point for this contract to process incoming messages.
    /// @param any2EvmMessage Received CCIP message.
    /// @dev Transfers specified token amounts to the owner of this contract. This function
    /// must be external because of the  try/catch for error handling.
    /// It uses the `onlySelf`: can only be called from the contract.
    function processMessage(
        Client.Any2EVMMessage calldata any2EvmMessage
    )
        external
        onlySelf
        onlyAllowlisted(
            any2EvmMessage.sourceChainSelector,
            abi.decode(any2EvmMessage.sender, (address))
        ) // Make sure the source chain and sender are allowlisted
    {
        // Simulate a revert for testing purposes
        if (s_simRevert) revert ErrorCase();

        _ccipReceive(any2EvmMessage); // process the message - may revert as well
    }

    /// @notice Allows the owner to retry a failed message in order to unblock the associated tokens.
    /// @param messageId The unique identifier of the failed message.
    /// @param tokenReceiver The address to which the tokens will be sent.
    /// @dev This function is only callable by the contract owner. It changes the status of the message
    /// from 'failed' to 'resolved' to prevent reentry and multiple retries of the same message.
    function retryFailedMessage(
        bytes32 messageId,
        address tokenReceiver
    ) external onlyOwner {
        // Check if the message has failed; if not, revert the transaction.
        if (s_failedMessages.get(messageId) != uint256(ErrorCode.FAILED))
            revert MessageNotFailed(messageId);

        // Set the error code to RESOLVED to disallow reentry and multiple retries of the same failed message.
        s_failedMessages.set(messageId, uint256(ErrorCode.RESOLVED));

        // Retrieve the content of the failed message.
        Client.Any2EVMMessage memory message = s_messageContents[messageId];

        // This example expects one token to have been sent, but you can handle multiple tokens.
        // Transfer the associated tokens to the specified receiver as an escape hatch.
        IERC20(message.destTokenAmounts[0].token).safeTransfer(
            tokenReceiver,
            message.destTokenAmounts[0].amount
        );

        // Emit an event indicating that the message has been recovered.
        emit MessageRecovered(messageId);
    }

    /// @notice Allows the owner to toggle simulation of reversion for testing purposes.
    /// @param simRevert If `true`, simulates a revert condition; if `false`, disables the simulation.
    /// @dev This function is only callable by the contract owner.
    function setSimRevert(bool simRevert) external onlyOwner {
        s_simRevert = simRevert;
    }

    function _ccipReceive(
        Client.Any2EVMMessage memory any2EvmMessage
    ) internal override {
        s_lastReceivedMessageId = any2EvmMessage.messageId; // fetch the messageId
        s_lastReceivedText = abi.decode(any2EvmMessage.data, (string)); // abi-decoding of the sent text
        // Expect one token to be transferred at once, but you can transfer several tokens.
        s_lastReceivedTokenAddress = any2EvmMessage.destTokenAmounts[0].token;
        s_lastReceivedTokenAmount = any2EvmMessage.destTokenAmounts[0].amount;
        emit MessageReceived(
            any2EvmMessage.messageId,
            any2EvmMessage.sourceChainSelector, // fetch the source chain identifier (aka selector)
            abi.decode(any2EvmMessage.sender, (address)), // abi-decoding of the sender address,
            abi.decode(any2EvmMessage.data, (string)),
            any2EvmMessage.destTokenAmounts[0].token,
            any2EvmMessage.destTokenAmounts[0].amount
        );
    }

    /// @notice Construct a CCIP message.
    /// @dev This function will create an EVM2AnyMessage struct with all the necessary information for programmable tokens transfer.
    /// @param _receiver The address of the receiver.
    /// @param _text The string data to be sent.
    /// @param _token The token to be transferred.
    /// @param _amount The amount of the token to be transferred.
    /// @param _feeTokenAddress The address of the token used for fees. Set address(0) for native gas.
    /// @return Client.EVM2AnyMessage Returns an EVM2AnyMessage struct which contains information for sending a CCIP message.
    function _buildCCIPMessage(
        address _receiver,
        string calldata _text,
        address _token,
        uint256 _amount,
        address _feeTokenAddress
    ) private pure returns (Client.EVM2AnyMessage memory) {
        // Set the token amounts
        Client.EVMTokenAmount[]
            memory tokenAmounts = new Client.EVMTokenAmount[](1);
        Client.EVMTokenAmount memory tokenAmount = Client.EVMTokenAmount({
            token: _token,
            amount: _amount
        });
        tokenAmounts[0] = tokenAmount;
        // Create an EVM2AnyMessage struct in memory with necessary information for sending a cross-chain message
        Client.EVM2AnyMessage memory evm2AnyMessage = Client.EVM2AnyMessage({
            receiver: abi.encode(_receiver), // ABI-encoded receiver address
            data: abi.encode(_text), // ABI-encoded string
            tokenAmounts: tokenAmounts, // The amount and type of token being transferred
            extraArgs: Client._argsToBytes(
                // Additional arguments, setting gas limit and allowing out-of-order execution.
                // Best Practice: For simplicity, the values are hardcoded. It is advisable to use a more dynamic approach
                // where you set the extra arguments off-chain. This allows adaptation depending on the lanes, messages,
                // and ensures compatibility with future CCIP upgrades. Read more about it here: https://docs.chain.link/ccip/concepts/best-practices/evm#using-extraargs
                Client.GenericExtraArgsV2({
                    gasLimit: 400_000, // Gas limit for the callback on the destination chain
                    allowOutOfOrderExecution: true // Allows the message to be executed out of order relative to other messages from the same sender
                })
            ),
            // Set the feeToken to a feeTokenAddress, indicating specific asset will be used for fees
            feeToken: _feeTokenAddress
        });
        return evm2AnyMessage;
    }

    /// @notice Fallback function to allow the contract to receive Ether.
    /// @dev This function has no function body, making it a default function for receiving Ether.
    /// It is automatically called when Ether is sent to the contract without any data.
    receive() external payable {}

    /// @notice Allows the contract owner to withdraw the entire balance of Ether from the contract.
    /// @dev This function reverts if there are no funds to withdraw or if the transfer fails.
    /// It should only be callable by the owner of the contract.
    /// @param _beneficiary The address to which the Ether should be sent.
    function withdraw(address _beneficiary) public onlyOwner {
        // Retrieve the balance of this contract
        uint256 amount = address(this).balance;

        // Revert if there is nothing to withdraw
        if (amount == 0) revert NothingToWithdraw();

        // Attempt to send the funds, capturing the success status and discarding any return data
        (bool sent, ) = _beneficiary.call{value: amount}("");

        // Revert if the send failed, with information about the attempted transfer
        if (!sent) revert FailedToWithdrawEth(msg.sender, _beneficiary, amount);
    }

    /// @notice Allows the owner of the contract to withdraw all tokens of a specific ERC20 token.
    /// @dev This function reverts with a 'NothingToWithdraw' error if there are no tokens to withdraw.
    /// @param _beneficiary The address to which the tokens will be sent.
    /// @param _token The contract address of the ERC20 token to be withdrawn.
    function withdrawToken(
        address _beneficiary,
        address _token
    ) public onlyOwner {
        // Retrieve the balance of this contract
        uint256 amount = IERC20(_token).balanceOf(address(this));

        // Revert if there is nothing to withdraw
        if (amount == 0) revert NothingToWithdraw();

        IERC20(_token).safeTransfer(_beneficiary, amount);
    }
}
```

[Open in Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/CCIP/ProgrammableDefensiveTokenTransfers.sol&autoCompile=true)[What is Remix?](/getting-started/conceptual-overview#what-is-remix)
### Deploy your contracts
To use this contract:

1. Open the contract in Remix.
2. Compile your contract.
3. Deploy, fund your sender contract on Avalanche Fuji and enable sending messages to Ethereum Sepolia:

Open MetaMask and select the network Avalanche Fuji.
In Remix IDE, click on Deploy & Run Transactions and select Injected Provider - MetaMask from the environment list. Remix will then interact with your MetaMask wallet to communicate with Avalanche Fuji.
Fill in your blockchain's router and LINK contract addresses. The router address can be found on the CCIP Directory and the LINK contract address on the LINK token contracts page. For Avalanche Fuji:

The router address is 0xF694E193200268f9a4868e4Aa017A0118C9a8177,
The LINK contract address is 0x0b9d5D9136855f6FEc3c0993feE6E9CE8a297846.

Click the transact button. After you confirm the transaction, the contract address appears on the Deployed Contracts list.
Note your contract address.
Open MetaMask and fund your contract with CCIP-BnM tokens. You can transfer 0.002 CCIP-BnM to your contract.
Enable your contract to send CCIP messages to Ethereum Sepolia:

In Remix IDE, under Deploy & Run Transactions, open the list of functions of your smart contract deployed on Avalanche Fuji.
Call the allowlistDestinationChain with 16015286601757825753 as the destination chain selector, and true as allowed. Each chain selector is found on the CCIP Directory.
4. Deploy your receiver contract on Ethereum Sepolia and enable receiving messages from your sender contract:

Open MetaMask and select the network Ethereum Sepolia.
In Remix IDE, under Deploy & Run Transactions, make sure the environment is still Injected Provider - MetaMask.
Fill in your blockchain's router and LINK contract addresses. The router address can be found on the CCIP Directory and the LINK contract address on the LINK token contracts page. For Ethereum Sepolia:

The router address is 0x0BF3dE8c5D3e8A2B34D2BEeB17ABfCeBaf363A59,
The LINK contract address is 0x779877A7B0D9E8603169DdbD7836e478b4624789.

Click the transact button. After you confirm the transaction, the contract address appears on the Deployed Contracts list.
Note your contract address.
Enable your contract to receive CCIP messages from Avalanche Fuji:

In Remix IDE, under Deploy & Run Transactions, open the list of functions of your smart contract deployed on Ethereum Sepolia.
Call the allowlistSourceChain with 14767482510784806043 as the source chain selector, and true as allowed. Each chain selector is found on the CCIP Directory.

Enable your contract to receive CCIP messages from the contract that you deployed on Avalanche Fuji:

In Remix IDE, under Deploy & Run Transactions, open the list of functions of your smart contract deployed on Ethereum Sepolia.
Call the allowlistSender with the contract address of the contract that you deployed on Avalanche Fuji, and true as allowed.

Call the setSimRevert function, passing true as a parameter, then wait for the transaction to confirm. Setting s_simRevert to true simulates a failure when processing the received message. Read the explanation section for more details.

At this point, you have one sender contract on Avalanche Fuji and one receiver contract on Ethereum Sepolia. As security measures, you enabled the sender contract to send CCIP messages to Ethereum Sepolia and the receiver contract to receive CCIP messages from the sender on Avalanche Fuji. The receiver contract cannot process the message, and therefore, instead of throwing an exception, it will lock the received tokens, enabling the owner to recover them.

Note: Another security measure enforces that only the router can call the _ccipReceive function. Read the explanation section for more details.

### Recover the locked tokens
You will transfer 0.001 CCIP-BnM and a text. The CCIP fees for using CCIP will be paid in LINK.

1. Open MetaMask and connect to Avalanche Fuji. Fund your contract with LINK tokens. You can transfer 70 LINK to your contract. In this example, LINK is used to pay the CCIP fees.
Note: This transaction fee is significantly higher than normal due to gas spikes on Sepolia. To run this example, you can get additional testnet LINK
from faucets.chain.link or use a supported testnet other than Sepolia.
2. Send a string data with tokens from Avalanche Fuji:

Open MetaMask and select the network Avalanche Fuji.

In Remix IDE, under Deploy & Run Transactions, open the list of functions of your smart contract deployed on Avalanche Fuji.

Fill in the arguments of the sendMessagePayLINK function:

ArgumentValue and Description_destinationChainSelector16015286601757825753  CCIP Chain identifier of the destination blockchain (Ethereum Sepolia in this example). You can find each chain selector on the CCIP Directory._receiverYour receiver contract address at Ethereum Sepolia.  The destination contract address._textHello World!Any string_token0xD21341536c5cF5EB1bcb58f6723cE26e8D8E90e4 The CCIP-BnM contract address at the source chain (Avalanche Fuji in this example). You can find all the addresses for each supported blockchain on the CCIP Directory._amount1000000000000000  The token amount (0.001 CCIP-BnM).

Click on transact and confirm the transaction on MetaMask.

After the transaction is successful, record the transaction hash. Here is an example of a transaction on Avalanche Fuji.
      Gas price spikes  Under normal circumstances, transactions on the Ethereum Sepolia network require significantly fewer tokens to pay for gas. However, during exceptional periods of high gas price spikes, your transactions may fail if not sufficiently funded. In such cases, you may need to fund your contract with additional tokens. We recommend paying for your CCIP transactions in LINK tokens (rather than native tokens) as you can obtain extra LINK testnet tokens from faucets.chain.link. If you encounter a transaction failure due to these gas price spikes, please add additional LINK tokens to your contract and try again.
Alternatively, you can use a supported testnet other than Sepolia.
3. Open the CCIP explorer and search your cross-chain transaction using the transaction hash.
4. The CCIP transaction is completed once the status is marked as "Success". In this example, the CCIP message ID is 0x120367995ef71f83d64a05bd7793862afda9d04049da4cb32851934490d03ae4.
5. Check the receiver contract on the destination chain:

Open MetaMask and select the network Ethereum Sepolia.

In Remix IDE, under Deploy & Run Transactions, open the list of functions of your smart contract deployed on Ethereum Sepolia.

Call the getFailedMessages function with an offset of 0 and a limit of 1 to retrieve the first failed message.

  

Notice the returned values are: 0x120367995ef71f83d64a05bd7793862afda9d04049da4cb32851934490d03ae4 (the message ID) and 1 (the error code indicating failure).
6. To recover the locked tokens, call the retryFailedMessage function:
ArgumentDescriptionmessageIdThe unique identifier of the failed message.tokenReceiverThe address to which the tokens will be sent.
7. After confirming the transaction, you can open it in a block explorer. Notice that the locked funds were transferred to the tokenReceiver address.
8. Call again the getFailedMessages function with an offset of 0 and a limit of 1 to retrieve the first failed message. Notice that the error code is now 0, indicating that the message was resolved.

Note: These example contracts are designed to work bi-directionally. As an exercise, you can use them to transfer tokens with data from Avalanche Fuji to Ethereum Sepolia and from Ethereum Sepolia back to Avalanche Fuji.

## Explanation
[Image: note]Integrate Chainlink CCIP v1.6.0 into your project

(()=>{var a=(s,i,o)=>{let r=async()=>{await(await s())()},t=typeof i.value=="object"?i.value:void 0,c={rootMargin:t==null?void 0:t.rootMargin},n=new IntersectionObserver(e=>{for(let l of e)if(l.isIntersecting){n.disconnect(),r();break}},c);for(let e of o.children)n.observe(e)};(self.Astro||(self.Astro={})).visible=a;window.dispatchEvent(new Event("astro:visible"));})();npmyarnfoundryIf you use NPM, install the @chainlink/contracts-ccip NPM package:

[Image: copy to clipboard]
```shell
npm install @chainlink/contracts-ccip@1.6.0
```

If you use Yarn, install the @chainlink/contracts-ccip NPM package:

[Image: copy to clipboard]
```shell
yarn add @chainlink/contracts-ccip@1.6.0
```

If you use Foundry, install the package:

[Image: copy to clipboard]
```shell
forge install smartcontractkit/chainlink-ccip@2114b90f39c82c052e05af7c33d42c1ae98f4180
```

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }The smart contract featured in this tutorial is designed to interact with CCIP to transfer and receive tokens and data. The contract code is similar to the Transfer Tokens with Data tutorial. Hence, you can refer to its code explanation. We will only explain the main differences.

### Sending messages
[Image: caution]Best Practices

This example is simplified for educational purposes. For production code, please adhere to the following best practices:

• Do Not Hardcode extraArgs: In this example, extraArgs are hardcoded within the contract for simplicity. It is recommended to make extraArgs mutable. For instance, you can construct extraArgs off-chain and pass them into your function calls, or store them in a storage variable that can be updated as needed. This approach ensures that extraArgs remain backward compatible with future CCIP upgrades. Refer to the Best Practices guide for more information.
• Validate the Destination Chain: Always ensure that the destination chain is valid and supported before sending messages.
• Understand allowOutOfOrderExecution Usage: This example sets allowOutOfOrderExecution to true (see GenericExtraArgsV2). Read the Best Practices: Setting allowOutOfOrderExecution to learn more about this parameter.
• Understand CCIP Service Limits: Review the CCIP Service Limits for constraints on message data size, execution gas, and the number of tokens per transaction. If your requirements exceed these limits, you may need to contact the Chainlink Labs Team.

Following these best practices ensures that your contract is robust, future-proof, and compliant with CCIP standards.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }The sendMessagePayLINK function is similar to the sendMessagePayLINK function in the Transfer Tokens with Data tutorial. The main difference is the increased gas limit to account for the additional gas required to process the error-handling logic.

### Receiving and processing messages
Upon receiving a message on the destination blockchain, the ccipReceive function is called by the CCIP router. This function serves as the entry point to the contract for processing incoming CCIP messages, enforcing crucial security checks through the onlyRouter, and onlyAllowlisted modifiers.

Here's the step-by-step breakdown of the process:

1. Entrance through ccipReceive:

The ccipReceive function is invoked with an Any2EVMMessage struct containing the message to be processed.
Security checks ensure the call is from the authorized router, an allowlisted source chain, and an allowlisted sender.
2. Processing Message:

ccipReceive calls the processMessage function, which is external to leverage Solidity's try/catch error handling mechanism. Note: The onlySelf modifier ensures that only the contract can call this function.
Inside processMessage, a check is performed for a simulated revert condition using the s_simRevert state variable. This simulation is toggled by the setSimRevert function, callable only by the contract owner.
If s_simRevert is false, processMessage calls the _ccipReceive function for further message processing.
3. Message Processing in _ccipReceive:

_ccipReceive extracts and stores various information from the message, such as the messageId, decoded sender address, token amounts, and data.
It then emits a MessageReceived event, signaling the successful processing of the message.
4. Error Handling:

If an error occurs during the processing (or a simulated revert is triggered), the catch block within ccipReceive is executed.
The messageId of the failed message is added to s_failedMessages, and the message content is stored in s_messageContents.
A MessageFailed event is emitted, which allows for later identification and reprocessing of failed messages.

### Reprocessing of failed messages
The retryFailedMessage function provides a mechanism to recover assets if a CCIP message processing fails. It's specifically designed to handle scenarios where message data issues prevent entire processing yet allow for token recovery:

1. Initiation:

Only the contract owner can call this function, providing the messageId of the failed message and the tokenReceiver address for token recovery.
2. Validation:

It checks if the message has failed using s_failedMessages.get(messageId). If not, it reverts the transaction.
3. Status Update:

The error code for the message is updated to RESOLVED to prevent reentry and multiple retries.
4. Token Recovery:

Retrieves the failed message content using s_messageContents[messageId].
Transfers the locked tokens associated with the failed message to the specified tokenReceiver as an escape hatch without processing the entire message again.
5. Event Emission:

An event MessageRecovered is emitted to signal the successful recovery of the tokens.

This function showcases a graceful asset recovery solution, protecting user values even when message processing encounters issues.

[Image: caution]Educational Example Disclaimer

This page includes an educational example to use a Chainlink system, product, or service and is provided to
demonstrate how to interact with Chainlink's systems, products, and services to integrate them into your own. This
template is provided "AS IS" and "AS AVAILABLE" without warranties of any kind, it has not been audited, and it may be
missing key checks or error handling to make the usage of the system, product or service more clear. Do not use the
code in this example in a production environment without completing your own audits and application of best practices.
Neither Chainlink Labs, the Chainlink Foundation, nor Chainlink node operators are responsible for unintended outputs
that are generated due to errors in code.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }

================================================================================

# Send Arbitrary Data

Source: https://docs.chain.link/ccip/tutorials/send-arbitrary-data
Extraction Method: playwright
Components: code_block(4), table(2)

# Send Arbitrary Data
In this tutorial, you will use Chainlink CCIP to send data between smart contracts on different blockchains. First, you will pay for the CCIP fees on the source blockchain using LINK. Then, you will use the same contract to pay CCIP fees in native gas tokens. For example, you would use ETH on Ethereum or AVAX on Avalanche.

[Image: note]Node Operator Rewards

CCIP rewards the oracle node and Risk Management node operators in LINK.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
## Before you begin

• You should understand how to write, compile, deploy, and fund a smart contract. If you need to brush up on the basics, read this tutorial, which will guide you through using the Solidity programming language, interacting with the MetaMask wallet and working within the Remix Development Environment.
• Your account must have some AVAX tokens on Avalanche Fuji and ETH tokens on Ethereum Sepolia.
• Learn how to Acquire testnet LINK and Fund your contract with LINK.

## Tutorial
[Image: note]Optimize your development with the CCIP local simulator

Enhance your development workflow using the Chainlink CCIP local
simulator, an installable package designed to simulate Chainlink
CCIP locally within your Hardhat and Foundry projects. It provides a robust smart contracts and scripts suite,
enabling you to build, deploy, and execute CCIP token transfers and arbitrary messages on a local Hardhat or Anvil
development node. With Chainlink Local, you can also work on forked nodes, ensuring a seamless transition of your
contracts to test networks without modifications. Start integrating Chainlink Local today to streamline your
development process and validate your CCIP implementations effectively.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }In this tutorial, you will send a string text between smart contracts on Avalanche Fuji and Ethereum Sepolia using CCIP. First, you will pay CCIP fees in LINK, then you will pay CCIP fees in native gas.

[Image: copy to clipboard]
```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import {IRouterClient} from "@chainlink/contracts-ccip/contracts/interfaces/IRouterClient.sol";
import {OwnerIsCreator} from "@chainlink/contracts/src/v0.8/shared/access/OwnerIsCreator.sol";
import {Client} from "@chainlink/contracts-ccip/contracts/libraries/Client.sol";
import {CCIPReceiver} from "@chainlink/contracts-ccip/contracts/applications/CCIPReceiver.sol";
import {IERC20} from "@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/utils/SafeERC20.sol";

/**
 * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
 * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

/// @title - A simple messenger contract for sending/receiving string data across chains.
contract Messenger is CCIPReceiver, OwnerIsCreator {
    using SafeERC20 for IERC20;

    // Custom errors to provide more descriptive revert messages.
    error NotEnoughBalance(uint256 currentBalance, uint256 calculatedFees); // Used to make sure contract has enough balance.
    error NothingToWithdraw(); // Used when trying to withdraw Ether but there's nothing to withdraw.
    error FailedToWithdrawEth(address owner, address target, uint256 value); // Used when the withdrawal of Ether fails.
    error DestinationChainNotAllowlisted(uint64 destinationChainSelector); // Used when the destination chain has not been allowlisted by the contract owner.
    error SourceChainNotAllowlisted(uint64 sourceChainSelector); // Used when the source chain has not been allowlisted by the contract owner.
    error SenderNotAllowlisted(address sender); // Used when the sender has not been allowlisted by the contract owner.
    error InvalidReceiverAddress(); // Used when the receiver address is 0.

    // Event emitted when a message is sent to another chain.
    event MessageSent(
        bytes32 indexed messageId, // The unique ID of the CCIP message.
        uint64 indexed destinationChainSelector, // The chain selector of the destination chain.
        address receiver, // The address of the receiver on the destination chain.
        string text, // The text being sent.
        address feeToken, // the token address used to pay CCIP fees.
        uint256 fees // The fees paid for sending the CCIP message.
    );

    // Event emitted when a message is received from another chain.
    event MessageReceived(
        bytes32 indexed messageId, // The unique ID of the CCIP message.
        uint64 indexed sourceChainSelector, // The chain selector of the source chain.
        address sender, // The address of the sender from the source chain.
        string text // The text that was received.
    );

    bytes32 private s_lastReceivedMessageId; // Store the last received messageId.
    string private s_lastReceivedText; // Store the last received text.

    // Mapping to keep track of allowlisted destination chains.
    mapping(uint64 => bool) public allowlistedDestinationChains;

    // Mapping to keep track of allowlisted source chains.
    mapping(uint64 => bool) public allowlistedSourceChains;

    // Mapping to keep track of allowlisted senders.
    mapping(address => bool) public allowlistedSenders;

    IERC20 private s_linkToken;

    /// @notice Constructor initializes the contract with the router address.
    /// @param _router The address of the router contract.
    /// @param _link The address of the link contract.
    constructor(address _router, address _link) CCIPReceiver(_router) {
        s_linkToken = IERC20(_link);
    }

    /// @dev Modifier that checks if the chain with the given destinationChainSelector is allowlisted.
    /// @param _destinationChainSelector The selector of the destination chain.
    modifier onlyAllowlistedDestinationChain(uint64 _destinationChainSelector) {
        if (!allowlistedDestinationChains[_destinationChainSelector])
            revert DestinationChainNotAllowlisted(_destinationChainSelector);
        _;
    }

    /// @dev Modifier that checks if the chain with the given sourceChainSelector is allowlisted and if the sender is allowlisted.
    /// @param _sourceChainSelector The selector of the destination chain.
    /// @param _sender The address of the sender.
    modifier onlyAllowlisted(uint64 _sourceChainSelector, address _sender) {
        if (!allowlistedSourceChains[_sourceChainSelector])
            revert SourceChainNotAllowlisted(_sourceChainSelector);
        if (!allowlistedSenders[_sender]) revert SenderNotAllowlisted(_sender);
        _;
    }

    /// @dev Modifier that checks the receiver address is not 0.
    /// @param _receiver The receiver address.
    modifier validateReceiver(address _receiver) {
        if (_receiver == address(0)) revert InvalidReceiverAddress();
        _;
    }

    /// @dev Updates the allowlist status of a destination chain for transactions.
    function allowlistDestinationChain(
        uint64 _destinationChainSelector,
        bool allowed
    ) external onlyOwner {
        allowlistedDestinationChains[_destinationChainSelector] = allowed;
    }

    /// @dev Updates the allowlist status of a source chain for transactions.
    function allowlistSourceChain(
        uint64 _sourceChainSelector,
        bool allowed
    ) external onlyOwner {
        allowlistedSourceChains[_sourceChainSelector] = allowed;
    }

    /// @dev Updates the allowlist status of a sender for transactions.
    function allowlistSender(address _sender, bool allowed) external onlyOwner {
        allowlistedSenders[_sender] = allowed;
    }

    /// @notice Sends data to receiver on the destination chain.
    /// @notice Pay for fees in LINK.
    /// @dev Assumes your contract has sufficient LINK.
    /// @param _destinationChainSelector The identifier (aka selector) for the destination blockchain.
    /// @param _receiver The address of the recipient on the destination blockchain.
    /// @param _text The text to be sent.
    /// @return messageId The ID of the CCIP message that was sent.
    function sendMessagePayLINK(
        uint64 _destinationChainSelector,
        address _receiver,
        string calldata _text
    )
        external
        onlyOwner
        onlyAllowlistedDestinationChain(_destinationChainSelector)
        validateReceiver(_receiver)
        returns (bytes32 messageId)
    {
        // Create an EVM2AnyMessage struct in memory with necessary information for sending a cross-chain message
        Client.EVM2AnyMessage memory evm2AnyMessage = _buildCCIPMessage(
            _receiver,
            _text,
            address(s_linkToken)
        );

        // Initialize a router client instance to interact with cross-chain router
        IRouterClient router = IRouterClient(this.getRouter());

        // Get the fee required to send the CCIP message
        uint256 fees = router.getFee(_destinationChainSelector, evm2AnyMessage);

        if (fees > s_linkToken.balanceOf(address(this)))
            revert NotEnoughBalance(s_linkToken.balanceOf(address(this)), fees);

        // approve the Router to transfer LINK tokens on contract's behalf. It will spend the fees in LINK
        s_linkToken.approve(address(router), fees);

        // Send the CCIP message through the router and store the returned CCIP message ID
        messageId = router.ccipSend(_destinationChainSelector, evm2AnyMessage);

        // Emit an event with message details
        emit MessageSent(
            messageId,
            _destinationChainSelector,
            _receiver,
            _text,
            address(s_linkToken),
            fees
        );

        // Return the CCIP message ID
        return messageId;
    }

    /// @notice Sends data to receiver on the destination chain.
    /// @notice Pay for fees in native gas.
    /// @dev Assumes your contract has sufficient native gas tokens.
    /// @param _destinationChainSelector The identifier (aka selector) for the destination blockchain.
    /// @param _receiver The address of the recipient on the destination blockchain.
    /// @param _text The text to be sent.
    /// @return messageId The ID of the CCIP message that was sent.
    function sendMessagePayNative(
        uint64 _destinationChainSelector,
        address _receiver,
        string calldata _text
    )
        external
        onlyOwner
        onlyAllowlistedDestinationChain(_destinationChainSelector)
        validateReceiver(_receiver)
        returns (bytes32 messageId)
    {
        // Create an EVM2AnyMessage struct in memory with necessary information for sending a cross-chain message
        Client.EVM2AnyMessage memory evm2AnyMessage = _buildCCIPMessage(
            _receiver,
            _text,
            address(0)
        );

        // Initialize a router client instance to interact with cross-chain router
        IRouterClient router = IRouterClient(this.getRouter());

        // Get the fee required to send the CCIP message
        uint256 fees = router.getFee(_destinationChainSelector, evm2AnyMessage);

        if (fees > address(this).balance)
            revert NotEnoughBalance(address(this).balance, fees);

        // Send the CCIP message through the router and store the returned CCIP message ID
        messageId = router.ccipSend{value: fees}(
            _destinationChainSelector,
            evm2AnyMessage
        );

        // Emit an event with message details
        emit MessageSent(
            messageId,
            _destinationChainSelector,
            _receiver,
            _text,
            address(0),
            fees
        );

        // Return the CCIP message ID
        return messageId;
    }

    /// handle a received message
    function _ccipReceive(
        Client.Any2EVMMessage memory any2EvmMessage
    )
        internal
        override
        onlyAllowlisted(
            any2EvmMessage.sourceChainSelector,
            abi.decode(any2EvmMessage.sender, (address))
        ) // Make sure source chain and sender are allowlisted
    {
        s_lastReceivedMessageId = any2EvmMessage.messageId; // fetch the messageId
        s_lastReceivedText = abi.decode(any2EvmMessage.data, (string)); // abi-decoding of the sent text

        emit MessageReceived(
            any2EvmMessage.messageId,
            any2EvmMessage.sourceChainSelector, // fetch the source chain identifier (aka selector)
            abi.decode(any2EvmMessage.sender, (address)), // abi-decoding of the sender address,
            abi.decode(any2EvmMessage.data, (string))
        );
    }

    /// @notice Construct a CCIP message.
    /// @dev This function will create an EVM2AnyMessage struct with all the necessary information for sending a text.
    /// @param _receiver The address of the receiver.
    /// @param _text The string data to be sent.
    /// @param _feeTokenAddress The address of the token used for fees. Set address(0) for native gas.
    /// @return Client.EVM2AnyMessage Returns an EVM2AnyMessage struct which contains information for sending a CCIP message.
    function _buildCCIPMessage(
        address _receiver,
        string calldata _text,
        address _feeTokenAddress
    ) private pure returns (Client.EVM2AnyMessage memory) {
        // Create an EVM2AnyMessage struct in memory with necessary information for sending a cross-chain message
        return
            Client.EVM2AnyMessage({
                receiver: abi.encode(_receiver), // ABI-encoded receiver address
                data: abi.encode(_text), // ABI-encoded string
                tokenAmounts: new Client.EVMTokenAmount[](0), // Empty array as no tokens are transferred
                extraArgs: Client._argsToBytes(
                    // Additional arguments, setting gas limit and allowing out-of-order execution.
                    // Best Practice: For simplicity, the values are hardcoded. It is advisable to use a more dynamic approach
                    // where you set the extra arguments off-chain. This allows adaptation depending on the lanes, messages,
                    // and ensures compatibility with future CCIP upgrades. Read more about it here: https://docs.chain.link/ccip/concepts/best-practices/evm#using-extraargs
                    Client.GenericExtraArgsV2({
                        gasLimit: 200_000, // Gas limit for the callback on the destination chain
                        allowOutOfOrderExecution: true // Allows the message to be executed out of order relative to other messages from the same sender
                    })
                ),
                // Set the feeToken to a feeTokenAddress, indicating specific asset will be used for fees
                feeToken: _feeTokenAddress
            });
    }

    /// @notice Fetches the details of the last received message.
    /// @return messageId The ID of the last received message.
    /// @return text The last received text.
    function getLastReceivedMessageDetails()
        external
        view
        returns (bytes32 messageId, string memory text)
    {
        return (s_lastReceivedMessageId, s_lastReceivedText);
    }

    /// @notice Fallback function to allow the contract to receive Ether.
    /// @dev This function has no function body, making it a default function for receiving Ether.
    /// It is automatically called when Ether is sent to the contract without any data.
    receive() external payable {}

    /// @notice Allows the contract owner to withdraw the entire balance of Ether from the contract.
    /// @dev This function reverts if there are no funds to withdraw or if the transfer fails.
    /// It should only be callable by the owner of the contract.
    /// @param _beneficiary The address to which the Ether should be sent.
    function withdraw(address _beneficiary) public onlyOwner {
        // Retrieve the balance of this contract
        uint256 amount = address(this).balance;

        // Revert if there is nothing to withdraw
        if (amount == 0) revert NothingToWithdraw();

        // Attempt to send the funds, capturing the success status and discarding any return data
        (bool sent, ) = _beneficiary.call{value: amount}("");

        // Revert if the send failed, with information about the attempted transfer
        if (!sent) revert FailedToWithdrawEth(msg.sender, _beneficiary, amount);
    }

    /// @notice Allows the owner of the contract to withdraw all tokens of a specific ERC20 token.
    /// @dev This function reverts with a 'NothingToWithdraw' error if there are no tokens to withdraw.
    /// @param _beneficiary The address to which the tokens will be sent.
    /// @param _token The contract address of the ERC20 token to be withdrawn.
    function withdrawToken(
        address _beneficiary,
        address _token
    ) public onlyOwner {
        // Retrieve the balance of this contract
        uint256 amount = IERC20(_token).balanceOf(address(this));

        // Revert if there is nothing to withdraw
        if (amount == 0) revert NothingToWithdraw();

        IERC20(_token).safeTransfer(_beneficiary, amount);
    }
}
```

[Open in Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/CCIP/Messenger.sol&autoCompile=true)[What is Remix?](/getting-started/conceptual-overview#what-is-remix)
### Deploy your contracts
To use this contract:

1. Open the contract in Remix.
2. Compile your contract.
3. Deploy your sender contract on Avalanche Fuji and enable sending messages to Ethereum Sepolia:

Open MetaMask and select the network Avalanche Fuji.
In Remix IDE, click on Deploy & Run Transactions and select Injected Provider - MetaMask from the environment list. Remix will then interact with your MetaMask wallet to communicate with Avalanche Fuji.
Fill in the router address and the link address for your network. You can find the router address on the CCIP Directory and the LINK token address on the LINK Token contracts page. For Avalanche Fuji:

The router address is 0xF694E193200268f9a4868e4Aa017A0118C9a8177,
The LINK contract address is 0x0b9d5D9136855f6FEc3c0993feE6E9CE8a297846.

Click on transact. After you confirm the transaction, the contract address appears on the Deployed Contracts list.
Note your contract address.
Enable your contract to send CCIP messages to Ethereum Sepolia:

In Remix IDE, under Deploy & Run Transactions, open the list of transactions of your smart contract deployed on Avalanche Fuji.
Call the allowlistDestinationChain with 16015286601757825753 as the destination chain selector, and true as allowed. Each chain selector is found on the CCIP Directory.
4. Deploy your receiver contract on Ethereum Sepolia and enable receiving messages from your sender contract:

Open MetaMask and select the network Ethereum Sepolia.
In Remix IDE, under Deploy & Run Transactions, make sure the environment is still Injected Provider - MetaMask.
Fill in the router address and the LINK address for your network. You can find the router address on the CCIP Directory and the LINK contract address on the LINK token contracts page. For Ethereum Sepolia:

The router address is 0x0BF3dE8c5D3e8A2B34D2BEeB17ABfCeBaf363A59,
The LINK contract address is 0x779877A7B0D9E8603169DdbD7836e478b4624789.

Click on transact. After you confirm the transaction, the contract address appears on the Deployed Contracts list.
Note your contract address.
Enable your contract to receive CCIP messages from Avalanche Fuji:

In Remix IDE, under Deploy & Run Transactions, open the list of transactions of your smart contract deployed on Ethereum Sepolia.
Call the allowlistSourceChain with 14767482510784806043 as the source chain selector, and true as allowed. Each chain selector is found on the CCIP Directory.

Enable your contract to receive CCIP messages from the contract that you deployed on Avalanche Fuji:

In Remix IDE, under Deploy & Run Transactions, open the list of transactions of your smart contract deployed on Ethereum Sepolia.
Call the allowlistSender with the contract address of the contract that you deployed on Avalanche Fuji, and true as allowed.

At this point, you have one sender contract on Avalanche Fuji and one receiver contract on Ethereum Sepolia. As security measures, you enabled the sender contract to send CCIP messages to Ethereum Sepolia and the receiver contract to receive CCIP messages from the sender and Avalanche Fuji. Note: Another security measure enforces that only the router can call the _ccipReceive function. Read the explanation section for more details.

### Send data and pay in LINK
You will use CCIP to send a text. The CCIP fees for using CCIP will be paid in LINK. Read this explanation for a detailed description of the code example.

1. Open MetaMask and connect to Avalanche Fuji. Fund your contract with LINK tokens. You can transfer 70 LINK to your contract. In this example, LINK is used to pay the CCIP fees.
Note: This transaction fee is significantly higher than normal due to gas spikes on Sepolia. To run this example, you can get additional testnet LINK
from faucets.chain.link or use a supported testnet other than Sepolia.
2. Send "Hello World!" from Avalanche Fuji:

Open MetaMask and select the network Avalanche Fuji.

In Remix IDE, under Deploy & Run Transactions, open the list of transactions of your smart contract deployed on Avalanche Fuji.

Fill in the arguments of the sendMessagePayLINK function:

ArgumentDescriptionValue (Ethereum Sepolia)_destinationChainSelectorCCIP Chain identifier of the target blockchain. You can find each network's chain selector on the CCIP Directory16015286601757825753_receiverThe destination smart contract addressYour deployed receiver contract address_textany stringHello World!

Click on transact and confirm the transaction on MetaMask.

Once the transaction is successful, note the transaction hash. Here is an example of a transaction on Avalanche Fuji.
      Gas price spikes  Under normal circumstances, transactions on the Ethereum Sepolia network require significantly fewer tokens to pay for gas. However, during exceptional periods of high gas price spikes, your transactions may fail if not sufficiently funded. In such cases, you may need to fund your contract with additional tokens. We recommend paying for your CCIP transactions in LINK tokens (rather than native tokens) as you can obtain extra LINK testnet tokens from faucets.chain.link. If you encounter a transaction failure due to these gas price spikes, please add additional LINK tokens to your contract and try again.
Alternatively, you can use a supported testnet other than Sepolia.
3. Open the CCIP explorer and search your cross-chain transaction using the transaction hash.
4. The CCIP transaction is completed once the status is marked as "Success". Note: In this example, the CCIP message ID is 0x28a804fa891bde8fb4f6617931187e1033a128c014aa76465911613588bc306f.
5. Check the receiver contract on the destination chain:

Open MetaMask and select the network Ethereum Sepolia.

In Remix IDE, under Deploy & Run Transactions, open the list of transactions of your smart contract deployed on Ethereum Sepolia.

Call the getLastReceivedMessageDetails.

  

Notice the received text is the one you sent, "Hello World!" and the message ID is the one you expect 0x28a804fa891bde8fb4f6617931187e1033a128c014aa76465911613588bc306f.

Note: These example contracts are designed to work bi-directionally. As an exercise, you can use them to send data from Avalanche Fuji to Ethereum Sepolia and from Ethereum Sepolia back to Avalanche Fuji.

### Send data and pay in native
You will use CCIP to send a text. The CCIP fees for using CCIP will be paid in native gas. Read this explanation for a detailed description of the code example.

1. Open MetaMask and connect to Avalanche Fuji. Fund your contract with AVAX. You can transfer 1 AVAX to your contract. In this example, AVAX is used to pay the CCIP fees.
2. Send "Hello World!" from Avalanche Fuji:

Open MetaMask and select the network Avalanche Fuji.

In Remix IDE, under Deploy & Run Transactions, open the list of transactions of your smart contract deployed on Avalanche Fuji.

Fill in the arguments of the sendMessagePayNative function:

ArgumentDescriptionValue (Ethereum Sepolia)_destinationChainSelectorCCIP Chain identifier of the target blockchain. You can find each network's chain selector on the CCIP Directory16015286601757825753_receiverThe destination smart contract addressYour deployed receiver contract address_textany stringHello World!

Click on transact and confirm the transaction on MetaMask.

Once the transaction is successful, note the transaction hash. Here is an example of a transaction on Avalanche Fuji.
      Gas price spikes  Under normal circumstances, transactions on the Ethereum Sepolia network require significantly fewer tokens to pay for gas. However, during exceptional periods of high gas price spikes, your transactions may fail if not sufficiently funded. In such cases, you may need to fund your contract with additional tokens. We recommend paying for your CCIP transactions in LINK tokens (rather than native tokens) as you can obtain extra LINK testnet tokens from faucets.chain.link. If you encounter a transaction failure due to these gas price spikes, please add additional LINK tokens to your contract and try again.
Alternatively, you can use a supported testnet other than Sepolia.
3. Open the CCIP explorer and search your cross-chain transaction using the transaction hash.
4. The CCIP transaction is completed once the status is marked as "Success". In this example, the CCIP message ID is 0xb8cb414128f440e115dcd5d6ead50e14d250f9a47577c38af4f70deb14191457. Note that CCIP fees are denominated in LINK. Even if CCIP fees are paid using native gas tokens, node operators will be paid in LINK.
5. Check the receiver contract on the destination chain:

Open MetaMask and select the network Ethereum Sepolia.

In Remix IDE, under Deploy & Run Transactions, open the list of transactions of your smart contract deployed on Ethereum Sepolia.

Call the getLastReceivedMessageDetails.

  

Notice the received text is the one you sent, "Hello World!" and the message ID is the one you expect 0xb8cb414128f440e115dcd5d6ead50e14d250f9a47577c38af4f70deb14191457.

Note: These example contracts are designed to work bi-directionally. As an exercise, you can use them to send data from Avalanche Fuji to Ethereum Sepolia and from Ethereum Sepolia back to Avalanche Fuji.

## Explanation
[Image: note]Integrate Chainlink CCIP v1.6.0 into your project

(()=>{var a=(s,i,o)=>{let r=async()=>{await(await s())()},t=typeof i.value=="object"?i.value:void 0,c={rootMargin:t==null?void 0:t.rootMargin},n=new IntersectionObserver(e=>{for(let l of e)if(l.isIntersecting){n.disconnect(),r();break}},c);for(let e of o.children)n.observe(e)};(self.Astro||(self.Astro={})).visible=a;window.dispatchEvent(new Event("astro:visible"));})();npmyarnfoundryIf you use NPM, install the @chainlink/contracts-ccip NPM package:

[Image: copy to clipboard]
```shell
npm install @chainlink/contracts-ccip@1.6.0
```

If you use Yarn, install the @chainlink/contracts-ccip NPM package:

[Image: copy to clipboard]
```shell
yarn add @chainlink/contracts-ccip@1.6.0
```

If you use Foundry, install the package:

[Image: copy to clipboard]
```shell
forge install smartcontractkit/chainlink-ccip@2114b90f39c82c052e05af7c33d42c1ae98f4180
```

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }The smart contract featured in this tutorial is designed to interact with CCIP to send and receive messages. The contract code contains supporting comments clarifying the functions, events, and underlying logic. Here we will further explain initializing the contract and sending and receiving data.

### Initializing of the contract
When deploying the contract, we define the router address and LINK contract address of the blockchain we deploy the contract on.
Defining the router address is useful for the following:

• Sender part:

Calls the router's getFee function to estimate the CCIP fees.
Calls the router's ccipSend function to send CCIP messages.
• Receiver part:

The contract inherits from CCIPReceiver, which serves as a base contract for receiver contracts. This contract requires that child contracts implement the _ccipReceive function. _ccipReceive is called by the ccipReceive function, which ensures that only the router can deliver CCIP messages to the receiver contract.

### Sending data and pay in LINK
The sendMessagePayLINK function undertakes five primary operations:

1. Call the _buildCCIPMessage private function to construct a CCIP-compatible message using the EVM2AnyMessage struct:

The _receiver address is encoded in bytes to accommodate non-EVM destination blockchains with distinct address formats. The encoding is achieved through abi.encode.

The data is encoded from a string to bytes using abi.encode.

The tokenAmounts is an empty EVMTokenAmount struct array as no tokens are transferred.

The extraArgs specifies the gasLimit for relaying the message to the recipient contract on the destination blockchain. In this example, the gasLimit is set to 200000.

The _feeTokenAddress designates the token address used for CCIP fees. Here, address(linkToken) signifies payment in LINK.
      Best Practices  This example is simplified for educational purposes. For production code, please adhere to the following best practices:

Do Not Hardcode extraArgs: In this example, extraArgs are hardcoded within the contract for simplicity. It is recommended to make extraArgs mutable. For instance, you can construct extraArgs off-chain and pass them into your function calls, or store them in a storage variable that can be updated as needed. This approach ensures that extraArgs remain backward compatible with future CCIP upgrades. Refer to the Best Practices guide for more information.

Validate the Destination Chain: Always ensure that the destination chain is valid and supported before sending messages.

Understand allowOutOfOrderExecution Usage: This example sets allowOutOfOrderExecution to true (see GenericExtraArgsV2). Read the Best Practices: Setting allowOutOfOrderExecution to learn more about this parameter.

Understand CCIP Service Limits: Review the CCIP Service Limits for constraints on message data size, execution gas, and the number of tokens per transaction. If your requirements exceed these limits, you may need to contact the Chainlink Labs Team.

Following these best practices ensures that your contract is robust, future-proof, and compliant with CCIP standards.
2. Computes the fees by invoking the router's getFee function.
3. Ensures your contract balance in LINK is enough to cover the fees.
4. Grants the router contract permission to deduct the fees from the contract's LINK balance.
5. Dispatches the CCIP message to the destination chain by executing the router's ccipSend function.

Note: As a security measure, the sendMessagePayLINK function is protected by the onlyAllowlistedDestinationChain, ensuring the contract owner has allowlisted a destination chain.

### Sending data and pay in native
The sendMessagePayNative function undertakes four primary operations:

1. Call the _buildCCIPMessage private function to construct a CCIP-compatible message using the EVM2AnyMessage struct:

The _receiver address is encoded in bytes to accommodate non-EVM destination blockchains with distinct address formats. The encoding is achieved through abi.encode.

The data is encoded from a string to bytes using abi.encode.

The tokenAmounts is an empty EVMTokenAmount struct array as no tokens are transferred.

The extraArgs specifies the gasLimit for relaying the message to the recipient contract on the destination blockchain. In this example, the gasLimit is set to 200000.

The _feeTokenAddress designates the token address used for CCIP fees. Here, address(0) signifies payment in native gas tokens (ETH).
      Best Practices  This example is simplified for educational purposes. For production code, please adhere to the following best practices:

Do Not Hardcode extraArgs: In this example, extraArgs are hardcoded within the contract for simplicity. It is recommended to make extraArgs mutable. For instance, you can construct extraArgs off-chain and pass them into your function calls, or store them in a storage variable that can be updated as needed. This approach ensures that extraArgs remain backward compatible with future CCIP upgrades. Refer to the Best Practices guide for more information.

Validate the Destination Chain: Always ensure that the destination chain is valid and supported before sending messages.

Understand allowOutOfOrderExecution Usage: This example sets allowOutOfOrderExecution to true (see GenericExtraArgsV2). Read the Best Practices: Setting allowOutOfOrderExecution to learn more about this parameter.

Understand CCIP Service Limits: Review the CCIP Service Limits for constraints on message data size, execution gas, and the number of tokens per transaction. If your requirements exceed these limits, you may need to contact the Chainlink Labs Team.

Following these best practices ensures that your contract is robust, future-proof, and compliant with CCIP standards.
2. Computes the fees by invoking the router's getFee function.
3. Ensures your contract balance in native gas is enough to cover the fees.
4. Dispatches the CCIP message to the destination chain by executing the router's ccipSend function. Note: msg.value is set because you pay in native gas.

Note: As a security measure, the sendMessagePayNative function is protected by the onlyAllowlistedDestinationChain, ensuring the contract owner has allowlisted a destination chain.

### Receiving data
On the destination blockchain, the router invokes the ccipReceive function which expects an Any2EVMMessage struct that contains:

• The CCIP messageId.
• The sourceChainSelector.
• The sender address in bytes format. Given that the sender is known to be a contract deployed on an EVM-compatible blockchain, the address is decoded from bytes to an Ethereum address using the ABI specifications.
• The data, which is also in bytes format. Given a string is expected, the data is decoded from bytes to a string using the ABI specifications.

This example applies three important security measures:

• _ccipReceive is called by the ccipReceive function, which ensures that only the router can deliver CCIP messages to the receiver contract. See the onlyRouter modifier for more information.
• The modifier onlyAllowlisted ensures that only a call from an allowlisted source chain and sender is accepted.

[Image: caution]Educational Example Disclaimer

This page includes an educational example to use a Chainlink system, product, or service and is provided to
demonstrate how to interact with Chainlink's systems, products, and services to integrate them into your own. This
template is provided "AS IS" and "AS AVAILABLE" without warranties of any kind, it has not been audited, and it may be
missing key checks or error handling to make the usage of the system, product or service more clear. Do not use the
code in this example in a production environment without completing your own audits and application of best practices.
Neither Chainlink Labs, the Chainlink Foundation, nor Chainlink node operators are responsible for unintended outputs
that are generated due to errors in code.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }

================================================================================

# Transfer Tokens Between Chains from Smart Contracts

Source: https://docs.chain.link/ccip/tutorials/transfer-tokens-from-contract
Extraction Method: playwright
Components: code_block(4), table(2)

# Transfer Tokens Between Chains from Smart Contracts
In this tutorial, you will use Chainlink CCIP to transfer tokens from a smart contract to an account on a different blockchain. First, you will pay for the CCIP fees on the source blockchain using LINK. Then, you will use the same contract to pay CCIP fees in native gas tokens. For example, you would use ETH on Ethereum or AVAX on Avalanche.

[Image: note]Node Operator Rewards

CCIP rewards the oracle node and Risk Management node operators in LINK.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }[Image: caution]Transferring tokens

This tutorial uses the term "transferring tokens" even though the tokens are not technically transferred. Instead,
they are locked or burned on the source chain and then unlocked or minted on the destination chain. Read the Token
Pools section to understand the various mechanisms that are used to
transfer value across chains.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
## Before you begin

1. You should understand how to write, compile, deploy, and fund a smart contract. If you need to brush up on the basics, read this tutorial, which will guide you through using the Solidity programming language, interacting with the MetaMask wallet and working within the Remix Development Environment.
2. Your account must have some AVAX and LINK tokens on Avalanche Fuji. Learn how to Acquire testnet LINK.
3. Check the CCIP Directory to confirm that the tokens you will transfer are supported for your lane. In this example, you will transfer tokens from Avalanche Fuji to Ethereum Sepolia so check the list of supported tokens here.
4. Learn how to acquire CCIP test tokens. Following this guide, you should have CCIP-BnM tokens, and CCIP-BnM should appear in the list of your tokens in MetaMask.
5. Learn how to fund your contract. This guide shows how to fund your contract in LINK, but you can use the same guide to fund your contract with any ERC20 tokens as long as they appear in the list of tokens in MetaMask.

## Tutorial
[Image: note]Optimize your development with the CCIP local simulator

Enhance your development workflow using the Chainlink CCIP local
simulator, an installable package designed to simulate Chainlink
CCIP locally within your Hardhat and Foundry projects. It provides a robust smart contracts and scripts suite,
enabling you to build, deploy, and execute CCIP token transfers and arbitrary messages on a local Hardhat or Anvil
development node. With Chainlink Local, you can also work on forked nodes, ensuring a seamless transition of your
contracts to test networks without modifications. Start integrating Chainlink Local today to streamline your
development process and validate your CCIP implementations effectively.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }In this tutorial, you will transfer CCIP-BnM tokens from a contract on Avalanche Fuji to an account on Ethereum Sepolia. First, you will pay CCIP fees in LINK, then you will pay CCIP fees in native gas. The destination account can be an EOA (Externally Owned Account) or a smart contract. Moreover, the example shows how to transfer CCIP-BnM tokens, but you can re-use the same example to transfer other tokens as long as they are supported for your lane.

[Image: copy to clipboard]
```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import {IRouterClient} from "@chainlink/contracts-ccip/contracts/interfaces/IRouterClient.sol";
import {OwnerIsCreator} from "@chainlink/contracts/src/v0.8/shared/access/OwnerIsCreator.sol";
import {Client} from "@chainlink/contracts-ccip/contracts/libraries/Client.sol";
import {IERC20} from "@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/utils/SafeERC20.sol";

/**
 * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
 * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

/// @title - A simple contract for transferring tokens across chains.
contract TokenTransferor is OwnerIsCreator {
    using SafeERC20 for IERC20;

    // Custom errors to provide more descriptive revert messages.
    error NotEnoughBalance(uint256 currentBalance, uint256 requiredBalance); // Used to make sure contract has enough token balance
    error NothingToWithdraw(); // Used when trying to withdraw Ether but there's nothing to withdraw.
    error FailedToWithdrawEth(address owner, address target, uint256 value); // Used when the withdrawal of Ether fails.
    error DestinationChainNotAllowlisted(uint64 destinationChainSelector); // Used when the destination chain has not been allowlisted by the contract owner.
    error InvalidReceiverAddress(); // Used when the receiver address is 0.
    // Event emitted when the tokens are transferred to an account on another chain.
    event TokensTransferred(
        bytes32 indexed messageId, // The unique ID of the message.
        uint64 indexed destinationChainSelector, // The chain selector of the destination chain.
        address receiver, // The address of the receiver on the destination chain.
        address token, // The token address that was transferred.
        uint256 tokenAmount, // The token amount that was transferred.
        address feeToken, // the token address used to pay CCIP fees.
        uint256 fees // The fees paid for sending the message.
    );

    // Mapping to keep track of allowlisted destination chains.
    mapping(uint64 => bool) public allowlistedChains;

    IRouterClient private s_router;

    IERC20 private s_linkToken;

    /// @notice Constructor initializes the contract with the router address.
    /// @param _router The address of the router contract.
    /// @param _link The address of the link contract.
    constructor(address _router, address _link) {
        s_router = IRouterClient(_router);
        s_linkToken = IERC20(_link);
    }

    /// @dev Modifier that checks if the chain with the given destinationChainSelector is allowlisted.
    /// @param _destinationChainSelector The selector of the destination chain.
    modifier onlyAllowlistedChain(uint64 _destinationChainSelector) {
        if (!allowlistedChains[_destinationChainSelector])
            revert DestinationChainNotAllowlisted(_destinationChainSelector);
        _;
    }

    /// @dev Modifier that checks the receiver address is not 0.
    /// @param _receiver The receiver address.
    modifier validateReceiver(address _receiver) {
        if (_receiver == address(0)) revert InvalidReceiverAddress();
        _;
    }

    /// @dev Updates the allowlist status of a destination chain for transactions.
    /// @notice This function can only be called by the owner.
    /// @param _destinationChainSelector The selector of the destination chain to be updated.
    /// @param allowed The allowlist status to be set for the destination chain.
    function allowlistDestinationChain(
        uint64 _destinationChainSelector,
        bool allowed
    ) external onlyOwner {
        allowlistedChains[_destinationChainSelector] = allowed;
    }

    /// @notice Transfer tokens to receiver on the destination chain.
    /// @notice pay in LINK.
    /// @notice the token must be in the list of supported tokens.
    /// @notice This function can only be called by the owner.
    /// @dev Assumes your contract has sufficient LINK tokens to pay for the fees.
    /// @param _destinationChainSelector The identifier (aka selector) for the destination blockchain.
    /// @param _receiver The address of the recipient on the destination blockchain.
    /// @param _token token address.
    /// @param _amount token amount.
    /// @return messageId The ID of the message that was sent.
    function transferTokensPayLINK(
        uint64 _destinationChainSelector,
        address _receiver,
        address _token,
        uint256 _amount
    )
        external
        onlyOwner
        onlyAllowlistedChain(_destinationChainSelector)
        validateReceiver(_receiver)
        returns (bytes32 messageId)
    {
        // Create an EVM2AnyMessage struct in memory with necessary information for sending a cross-chain message
        //  address(linkToken) means fees are paid in LINK
        Client.EVM2AnyMessage memory evm2AnyMessage = _buildCCIPMessage(
            _receiver,
            _token,
            _amount,
            address(s_linkToken)
        );

        // Get the fee required to send the message
        uint256 fees = s_router.getFee(
            _destinationChainSelector,
            evm2AnyMessage
        );

        uint256 requiredLinkBalance;
        if (_token == address(s_linkToken)) {
            // Required LINK Balance is the sum of fees and amount to transfer, if the token to transfer is LINK
            requiredLinkBalance = fees + _amount;
        } else {
            requiredLinkBalance = fees;
        }

        uint256 linkBalance = s_linkToken.balanceOf(address(this));

        if (requiredLinkBalance > linkBalance) {
            revert NotEnoughBalance(linkBalance, requiredLinkBalance);
        }

        // approve the Router to transfer LINK tokens on contract's behalf. It will spend the requiredLinkBalance
        s_linkToken.approve(address(s_router), requiredLinkBalance);

        // If sending a token other than LINK, approve it separately
        if (_token != address(s_linkToken)) {
            uint256 tokenBalance = IERC20(_token).balanceOf(address(this));
            if (_amount > tokenBalance) {
                revert NotEnoughBalance(tokenBalance, _amount);
            }
            // approve the Router to spend tokens on contract's behalf. It will spend the amount of the given token
            IERC20(_token).approve(address(s_router), _amount);
        }

        // Send the message through the router and store the returned message ID
        messageId = s_router.ccipSend(
            _destinationChainSelector,
            evm2AnyMessage
        );

        // Emit an event with message details
        emit TokensTransferred(
            messageId,
            _destinationChainSelector,
            _receiver,
            _token,
            _amount,
            address(s_linkToken),
            fees
        );

        // Return the message ID
        return messageId;
    }

    /// @notice Transfer tokens to receiver on the destination chain.
    /// @notice Pay in native gas such as ETH on Ethereum or POL on Polygon.
    /// @notice the token must be in the list of supported tokens.
    /// @notice This function can only be called by the owner.
    /// @dev Assumes your contract has sufficient native gas like ETH on Ethereum or POL on Polygon.
    /// @param _destinationChainSelector The identifier (aka selector) for the destination blockchain.
    /// @param _receiver The address of the recipient on the destination blockchain.
    /// @param _token token address.
    /// @param _amount token amount.
    /// @return messageId The ID of the message that was sent.
    function transferTokensPayNative(
        uint64 _destinationChainSelector,
        address _receiver,
        address _token,
        uint256 _amount
    )
        external
        onlyOwner
        onlyAllowlistedChain(_destinationChainSelector)
        validateReceiver(_receiver)
        returns (bytes32 messageId)
    {
        // Create an EVM2AnyMessage struct in memory with necessary information for sending a cross-chain message
        // address(0) means fees are paid in native gas
        Client.EVM2AnyMessage memory evm2AnyMessage = _buildCCIPMessage(
            _receiver,
            _token,
            _amount,
            address(0)
        );

        // Get the fee required to send the message
        uint256 fees = s_router.getFee(
            _destinationChainSelector,
            evm2AnyMessage
        );

        if (fees > address(this).balance)
            revert NotEnoughBalance(address(this).balance, fees);

        // approve the Router to spend tokens on contract's behalf. It will spend the amount of the given token
        IERC20(_token).approve(address(s_router), _amount);

        // Send the message through the router and store the returned message ID
        messageId = s_router.ccipSend{value: fees}(
            _destinationChainSelector,
            evm2AnyMessage
        );

        // Emit an event with message details
        emit TokensTransferred(
            messageId,
            _destinationChainSelector,
            _receiver,
            _token,
            _amount,
            address(0),
            fees
        );

        // Return the message ID
        return messageId;
    }

    /// @notice Construct a CCIP message.
    /// @dev This function will create an EVM2AnyMessage struct with all the necessary information for tokens transfer.
    /// @param _receiver The address of the receiver.
    /// @param _token The token to be transferred.
    /// @param _amount The amount of the token to be transferred.
    /// @param _feeTokenAddress The address of the token used for fees. Set address(0) for native gas.
    /// @return Client.EVM2AnyMessage Returns an EVM2AnyMessage struct which contains information for sending a CCIP message.
    function _buildCCIPMessage(
        address _receiver,
        address _token,
        uint256 _amount,
        address _feeTokenAddress
    ) private pure returns (Client.EVM2AnyMessage memory) {
        // Set the token amounts
        Client.EVMTokenAmount[]
            memory tokenAmounts = new Client.EVMTokenAmount[](1);
        tokenAmounts[0] = Client.EVMTokenAmount({
            token: _token,
            amount: _amount
        });

        // Create an EVM2AnyMessage struct in memory with necessary information for sending a cross-chain message
        return
            Client.EVM2AnyMessage({
                receiver: abi.encode(_receiver), // ABI-encoded receiver address
                data: "", // No data
                tokenAmounts: tokenAmounts, // The amount and type of token being transferred
                extraArgs: Client._argsToBytes(
                    // Additional arguments, setting gas limit and allowing out-of-order execution.
                    // Best Practice: For simplicity, the values are hardcoded. It is advisable to use a more dynamic approach
                    // where you set the extra arguments off-chain. This allows adaptation depending on the lanes, messages,
                    // and ensures compatibility with future CCIP upgrades. Read more about it here: https://docs.chain.link/ccip/concepts/best-practices/evm#using-extraargs
                    Client.GenericExtraArgsV2({
                        gasLimit: 0, // Gas limit for the callback on the destination chain
                        allowOutOfOrderExecution: true // Allows the message to be executed out of order relative to other messages from the same sender
                    })
                ),
                // Set the feeToken to a feeTokenAddress, indicating specific asset will be used for fees
                feeToken: _feeTokenAddress
            });
    }

    /// @notice Fallback function to allow the contract to receive Ether.
    /// @dev This function has no function body, making it a default function for receiving Ether.
    /// It is automatically called when Ether is transferred to the contract without any data.
    receive() external payable {}

    /// @notice Allows the contract owner to withdraw the entire balance of Ether from the contract.
    /// @dev This function reverts if there are no funds to withdraw or if the transfer fails.
    /// It should only be callable by the owner of the contract.
    /// @param _beneficiary The address to which the Ether should be transferred.
    function withdraw(address _beneficiary) public onlyOwner {
        // Retrieve the balance of this contract
        uint256 amount = address(this).balance;

        // Revert if there is nothing to withdraw
        if (amount == 0) revert NothingToWithdraw();

        // Attempt to send the funds, capturing the success status and discarding any return data
        (bool sent, ) = _beneficiary.call{value: amount}("");

        // Revert if the send failed, with information about the attempted transfer
        if (!sent) revert FailedToWithdrawEth(msg.sender, _beneficiary, amount);
    }

    /// @notice Allows the owner of the contract to withdraw all tokens of a specific ERC20 token.
    /// @dev This function reverts with a 'NothingToWithdraw' error if there are no tokens to withdraw.
    /// @param _beneficiary The address to which the tokens will be sent.
    /// @param _token The contract address of the ERC20 token to be withdrawn.
    function withdrawToken(
        address _beneficiary,
        address _token
    ) public onlyOwner {
        // Retrieve the balance of this contract
        uint256 amount = IERC20(_token).balanceOf(address(this));

        // Revert if there is nothing to withdraw
        if (amount == 0) revert NothingToWithdraw();

        IERC20(_token).safeTransfer(_beneficiary, amount);
    }
}
```

[Open in Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/CCIP/TokenTransferor.sol&autoCompile=true)[What is Remix?](/getting-started/conceptual-overview#what-is-remix)
### Deploy your contracts
To use this contract:

1. Open the contract in Remix.
2. Compile your contract.
3. Deploy and fund your sender contract on Avalanche Fuji:

Open MetaMask and select the Avalanche Fuji network.

In Remix IDE, click Deploy & Run Transactions and select Injected Provider - MetaMask from the environment list. Remix will then interact with your MetaMask wallet to communicate with Avalanche Fuji.

Fill in your blockchain's router and LINK contract addresses. The router address can be found on the CCIP Directory and the LINK contract address on the LINK token contracts page. For Avalanche Fuji:

The router address is 0xF694E193200268f9a4868e4Aa017A0118C9a8177,
The LINK contract address is 0x0b9d5D9136855f6FEc3c0993feE6E9CE8a297846.

Click the transact button. After you confirm the transaction, the contract address appears on the Deployed Contracts list.
Note your contract address.

Open MetaMask and fund your contract with CCIP-BnM tokens. You can transfer 0.002 CCIP-BnM to your contract.
4. Enable your contract to transfer tokens to Ethereum Sepolia:

In Remix IDE, under Deploy & Run Transactions, open the list of functions for your smart contract deployed on Avalanche Fuji.
Call the allowlistDestinationChain function with 16015286601757825753 as the destination chain selector, and true as allowed. Each chain selector is found on the CCIP Directory.

### Transfer tokens and pay in LINK
You will transfer 0.001 CCIP-BnM. The CCIP fees for using CCIP will be paid in LINK. Read this explanation for a detailed description of the code example.

1. Open MetaMask and connect to Avalanche Fuji. Fund your contract with LINK tokens. You can transfer 70 LINK to your contract. Note: The LINK tokens are used to pay for CCIP fees.
Note: This transaction fee is significantly higher than normal due to gas spikes on Sepolia. To run this example, you can get additional testnet LINK
from faucets.chain.link or use a supported testnet other than Sepolia.
2. Transfer CCIP-BnM from Avalanche Fuji:

Open MetaMask and select the network Avalanche Fuji.

In Remix IDE, under Deploy & Run Transactions, open the list of functions for your smart contract deployed on Avalanche Fuji.

Fill in the arguments of the transferTokensPayLINK function:

ArgumentValue and Description_destinationChainSelector16015286601757825753  CCIP Chain identifier of the destination blockchain (Ethereum Sepolia in this example). You can find each chain selector on the CCIP Directory._receiverYour account address on Ethereum Sepolia.  The destination account address. It could be a smart contract or an EOA._token0xD21341536c5cF5EB1bcb58f6723cE26e8D8E90e4 The CCIP-BnM contract address at the source chain (Avalanche Fuji in this example). You can find all the addresses for each supported blockchain on the CCIP Directory._amount1000000000000000  The token amount (0.001 CCIP-BnM).

Click the transact button and confirm the transaction on MetaMask.

Once the transaction is successful, note the transaction hash. Here is an example of a transaction on Avalanche Fuji.
      Gas price spikes  Under normal circumstances, transactions on the Ethereum Sepolia network require significantly fewer tokens to pay for gas. However, during exceptional periods of high gas price spikes, your transactions may fail if not sufficiently funded. In such cases, you may need to fund your contract with additional tokens. We recommend paying for your CCIP transactions in LINK tokens (rather than native tokens) as you can obtain extra LINK testnet tokens from faucets.chain.link. If you encounter a transaction failure due to these gas price spikes, please add additional LINK tokens to your contract and try again.
Alternatively, you can use a supported testnet other than Sepolia.
3. Open the CCIP explorer and search your cross-chain transaction using the transaction hash.
4. The CCIP transaction is completed once the status is marked as "Success". The data field is empty because you are only transferring tokens.
5. Check the receiver account on the destination chain:

Note the destination transaction hash from the CCIP explorer. 0x083fc1a79ffcfd617426fd71dff87ca16db2e4333e62a28cdd13d4bec0926bcb in this example.

Open the block explorer for your destination chain. For Ethereum Sepolia, open etherscan.

Search the transaction hash.

  

Notice in the Tokens Transferred section that CCIP-BnM tokens have been transferred to your account (0.001 CCIP-BnM).

### Transfer tokens and pay in native
You will transfer 0.001 CCIP-BnM. The CCIP fees for using CCIP will be paid in Avalanche Fuji's native AVAX. Read this explanation for a detailed description of the code example.

1. Open MetaMask and connect to Avalanche Fuji. Fund your contract with native gas tokens. You can transfer 0.2 AVAX to your contract. Note: The native gas tokens are used to pay for CCIP fees.
2. Transfer CCIP-BnM from Avalanche Fuji:

Open MetaMask and select the network Avalanche Fuji.

In Remix IDE, under Deploy & Run Transactions, open the list of transactions of your smart contract deployed on Avalanche Fuji.

Fill in the arguments of the transferTokensPayNative function:

ArgumentValue and Description_destinationChainSelector16015286601757825753  CCIP Chain identifier of the destination blockchain (Ethereum Sepolia in this example). You can find each chain selector on the CCIP Directory._receiverYour account address on Ethereum Sepolia.  The destination account address. It could be a smart contract or an EOA._token0xD21341536c5cF5EB1bcb58f6723cE26e8D8E90e4 The CCIP-BnM contract address at the source chain (Avalanche Fuji in this example). You can find all the addresses for each supported blockchain on the CCIP Directory.._amount1000000000000000  The token amount (0.001 CCIP-BnM).

Click the transact button and confirm the transaction on MetaMask.

Once the transaction is successful, note the transaction hash. Here is an example of a transaction on Avalanche Fuji.
      Gas price spikes  Under normal circumstances, transactions on the Ethereum Sepolia network require significantly fewer tokens to pay for gas. However, during exceptional periods of high gas price spikes, your transactions may fail if not sufficiently funded. In such cases, you may need to fund your contract with additional tokens. We recommend paying for your CCIP transactions in LINK tokens (rather than native tokens) as you can obtain extra LINK testnet tokens from faucets.chain.link. If you encounter a transaction failure due to these gas price spikes, please add additional LINK tokens to your contract and try again.
Alternatively, you can use a supported testnet other than Sepolia.
3. Open the CCIP explorer and search your cross-chain transaction using the transaction hash.
4. The CCIP transaction is completed once the status is marked as "Success". The data field is empty because you only transfer tokens. Note that CCIP fees are denominated in LINK. Even if CCIP fees are paid using native gas tokens, node operators will be paid in LINK.
5. Check the receiver account on the destination chain:

Note the destination transaction hash from the CCIP explorer. 0xf403d828fa377d657af67f12e99ff435974299c27ba2d57c53494d29bbbfc938 in this example.

Open the block explorer for your destination chain. For Ethereum Sepolia, open etherscan.

Search the transaction hash.

  

Notice in the Tokens Transferred section that CCIP-BnM tokens have been transferred to your account (0.001 CCIP-BnM).

## Explanation
[Image: note]Integrate Chainlink CCIP v1.6.0 into your project

(()=>{var a=(s,i,o)=>{let r=async()=>{await(await s())()},t=typeof i.value=="object"?i.value:void 0,c={rootMargin:t==null?void 0:t.rootMargin},n=new IntersectionObserver(e=>{for(let l of e)if(l.isIntersecting){n.disconnect(),r();break}},c);for(let e of o.children)n.observe(e)};(self.Astro||(self.Astro={})).visible=a;window.dispatchEvent(new Event("astro:visible"));})();npmyarnfoundryIf you use NPM, install the @chainlink/contracts-ccip NPM package:

[Image: copy to clipboard]
```shell
npm install @chainlink/contracts-ccip@1.6.0
```

If you use Yarn, install the @chainlink/contracts-ccip NPM package:

[Image: copy to clipboard]
```shell
yarn add @chainlink/contracts-ccip@1.6.0
```

If you use Foundry, install the package:

[Image: copy to clipboard]
```shell
forge install smartcontractkit/chainlink-ccip@2114b90f39c82c052e05af7c33d42c1ae98f4180
```

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }The smart contract featured in this tutorial is designed to interact with CCIP to transfer a supported token to an account on a destination chain. The contract code contains supporting comments clarifying the functions, events, and underlying logic. This section further explains initializing the contract and transferring tokens.

### Initializing of the contract
When you deploy the contract, you define the router address and LINK contract address of the blockchain where you deploy the contract. The contract uses the router address to interact with the router to estimate the CCIP fees and the transmission of CCIP messages.

### Transferring tokens and pay in LINK
The transferTokensPayLINK function undertakes six primary operations:

1. Call the _buildCCIPMessage private function to construct a CCIP-compatible message using the EVM2AnyMessage struct:

The _receiver address is encoded in bytes to accommodate non-EVM destination blockchains with distinct address formats. The encoding is achieved through abi.encode.

The data is empty because you only transfer tokens.

The tokenAmounts is an array, with each element comprising a EVMTokenAmount struct that contains the token address and amount. The array contains one element where the _token (token address) and _amount (token amount) are passed by the user when calling the transferTokensPayLINK function.

The extraArgs specifies the gasLimit for relaying the message to the recipient contract on the destination blockchain. In this example, the gasLimit is set to 0 because the contract only transfers tokens and does not expect function calls on the destination blockchain.

The _feeTokenAddress designates the token address used for CCIP fees. Here, address(linkToken) signifies payment in LINK.
      Best Practices  This example is simplified for educational purposes. For production code, please adhere to the following best practices:

Do Not Hardcode extraArgs: In this example, extraArgs are hardcoded within the contract for simplicity. It is recommended to make extraArgs mutable. For instance, you can construct extraArgs off-chain and pass them into your function calls, or store them in a storage variable that can be updated as needed. This approach ensures that extraArgs remain backward compatible with future CCIP upgrades. Refer to the Best Practices guide for more information.

Validate the Destination Chain: Always ensure that the destination chain is valid and supported before sending messages.

Understand allowOutOfOrderExecution Usage: This example sets allowOutOfOrderExecution to true (see GenericExtraArgsV2). Read the Best Practices: Setting allowOutOfOrderExecution to learn more about this parameter.

Understand CCIP Service Limits: Review the CCIP Service Limits for constraints on message data size, execution gas, and the number of tokens per transaction. If your requirements exceed these limits, you may need to contact the Chainlink Labs Team.

Following these best practices ensures that your contract is robust, future-proof, and compliant with CCIP standards.
2. Computes the fees by invoking the router's getFee function.
3. Ensures your contract balance in LINK is enough to cover the fees.
4. Grants the router contract permission to deduct the fees from the contract's LINK balance.
5. Grants the router contract permission to deduct the amount from the contract's CCIP-BnM balance.
6. Dispatches the CCIP message to the destination chain by executing the router's ccipSend function.

Note: As a security measure, the transferTokensPayLINK function is protected by the onlyAllowlistedChain to ensure the contract owner has allowlisted a destination chain.

### Transferring tokens and pay in native
The transferTokensPayNative function undertakes five primary operations:

1. Call the _buildCCIPMessage private function to construct a CCIP-compatible message using the EVM2AnyMessage struct:

The _receiver address is encoded in bytes to accommodate non-EVM destination blockchains with distinct address formats. The encoding is achieved through abi.encode.

The data is empty because you only transfer tokens.

The tokenAmounts is an array, with each element comprising an EVMTokenAmount struct containing the token address and amount. The array contains one element where the _token (token address) and _amount (token amount) are passed by the user when calling the transferTokensPayNative function.

The extraArgs specifies the gasLimit for relaying the message to the recipient contract on the destination blockchain. In this example, the gasLimit is set to 0 because the contract only transfers tokens and does not expect function calls on the destination blockchain.

The _feeTokenAddress designates the token address used for CCIP fees. Here, address(0) signifies payment in native gas tokens (ETH).
      Best Practices  This example is simplified for educational purposes. For production code, please adhere to the following best practices:

Do Not Hardcode extraArgs: In this example, extraArgs are hardcoded within the contract for simplicity. It is recommended to make extraArgs mutable. For instance, you can construct extraArgs off-chain and pass them into your function calls, or store them in a storage variable that can be updated as needed. This approach ensures that extraArgs remain backward compatible with future CCIP upgrades. Refer to the Best Practices guide for more information.

Validate the Destination Chain: Always ensure that the destination chain is valid and supported before sending messages.

Understand allowOutOfOrderExecution Usage: This example sets allowOutOfOrderExecution to true (see GenericExtraArgsV2). Read the Best Practices: Setting allowOutOfOrderExecution to learn more about this parameter.

Understand CCIP Service Limits: Review the CCIP Service Limits for constraints on message data size, execution gas, and the number of tokens per transaction. If your requirements exceed these limits, you may need to contact the Chainlink Labs Team.

Following these best practices ensures that your contract is robust, future-proof, and compliant with CCIP standards.
2. Computes the fees by invoking the router's getFee function.
3. Ensures your contract balance in native gas is enough to cover the fees.
4. Grants the router contract permission to deduct the amount from the contract's CCIP-BnM balance.
5. Dispatches the CCIP message to the destination chain by executing the router's ccipSend function. Note: msg.value is set because you pay in native gas.

Note: As a security measure, the transferTokensPayNative function is protected by the onlyAllowlistedChain, ensuring the contract owner has allowlisted a destination chain.

[Image: caution]Educational Example Disclaimer

This page includes an educational example to use a Chainlink system, product, or service and is provided to
demonstrate how to interact with Chainlink's systems, products, and services to integrate them into your own. This
template is provided "AS IS" and "AS AVAILABLE" without warranties of any kind, it has not been audited, and it may be
missing key checks or error handling to make the usage of the system, product or service more clear. Do not use the
code in this example in a production environment without completing your own audits and application of best practices.
Neither Chainlink Labs, the Chainlink Foundation, nor Chainlink node operators are responsible for unintended outputs
that are generated due to errors in code.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }

================================================================================

# Transfer USDC with Data

Source: https://docs.chain.link/ccip/tutorials/usdc
Extraction Method: playwright
Components: code_block(6), table(4)

# Transfer USDC with Data
USDC is a digital dollar backed 100% and is always redeemable 1:1 for US dollars. The stablecoin is issued by Circle on multiple blockchain platforms.

This guide will first explain how Chainlink CCIP enables native USDC transfers when both the source and destination blockchains support Circle's Cross-Chain Transfer Protocol (CCTP).

Additionally, it will outline how CCIP also supports transferring Bridged USDC on blockchains that are not CCTP-enabled, allowing projects to later migrate to CCTP-enabled transfers if approved by Circle.

The hands-on tutorial at the end demonstrates how to use Chainlink CCIP to transfer USDC and arbitrary data from a smart contract on Avalanche Fuji to a smart contract on Ethereum Sepolia.

Note: In addition to programmable token transfers, you can also use CCIP to transfer USDC tokens without data. Check the Mainnets and Testnets configuration pages to learn on which blockchains CCIP supports USDC transfers.

## Architecture

### Native USDC vs. Bridged USDC
New blockchains frequently encounter the cold start problem—a scarcity of initial liquidity and limited user adoption that hampers the development and functionality of decentralized applications (dApps). Without sufficient stablecoin liquidity, essential use cases such as borrowing, lending, and trading remain constrained.

To overcome this challenge, Circle introduced the Bridged USDC Standard. This standard facilitates the seamless issuance of Bridged USDC on any EVM-compatible blockchain, enabling third-party teams to deploy USDC without awaiting native support from Circle. By standardizing bridged token issuance, Circle aims to:

• Reduce Liquidity Fragmentation: Ensure a unified and efficient USDC supply across multiple blockchains.
• Enhance User Experience: Minimize complexities and inconsistencies in managing multiple bridged USDC versions.
• Facilitate Seamless Upgrades: Enable projects to transition smoothly to Native USDC once their blockchain is approved for native issuance via the Cross-Chain Transfer Protocol (CCTP).

Projects using Bridged USDC can easily migrate to Native USDC once their blockchain is approved for CCTP by Circle. This migration ensures that user balances, contract addresses, and integrations remain intact, eliminating the need for complex token swaps or liquidity migrations. For more detailed information, refer to Circle's Bridged USDC Standard.

### How CCIP Works with USDC
Chainlink CCIP maintains a consistent API regardless of whether the transfer involves Native USDC or Bridged USDC. Here's how it operates in both scenarios:

• The sender has to interact with the CCIP router to initiate a cross-chain transaction, similar to the process for any other token transfers. See the Transfer Tokens guide to learn more.
• The process uses the same onchain components including the Router, OnRamp, Commit Store, OffRamp, and Token Pool.
• The process uses the same offchain components including the Committing DON, Executing DON, and the Risk Management Network.
• USDC transfers also benefit from CCIP additional security provided by the Risk Management Network.

#### Native USDC (CCTP-enabled)
The diagram below shows that the USDC token pools and Executing DON handle the integration with Circle's contracts and offchain CCTP Attestation API. As with any other supported ERC-20 token, USDC has a linked token pool on each supported blockchain to facilitate OnRamp and OffRamp operations. To learn more about these components, read the architecture page.

astro-island,astro-slot,astro-static-slot{display:contents}(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).only=e;window.dispatchEvent(new Event("astro:only"));})();(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();[Image: Chainlink CCIP Detailed Architecture for usdc]The following describes the operational process:

1. On the source blockchain:

When the sender initiates a transfer of USDC, the USDC token pool interacts with CCTP's contract to burn USDC tokens and specifies the USDC token pool address on the destination blockchain as the authorized caller to mint them.
CCTP burns the specified USDC tokens and emits an associated CCTP event.
2. Offchain:

The Circle attestation service listens to CCTP events on the source blockchain.
The CCIP Executing DON listens to relevant CCTP events on the source blockchain. When it captures such an event, it calls the Circle Attestation service API to request an attestation. An attestation is a signed authorization to mint the specified amount of USDC on the destination blockchain.
3. On the destination blockchain:

The Executing DON provides the attestation to the OffRamp contract.
The OffRamp contract calls the USDC token pool with the USDC amount to be minted, the Receiver address, and the Circle attestation.
The USDC token pool calls the CCTP contract. The CCTP contract verifies the attestation signature before minting the specified USDC amount into the Receiver.
If there is data in the CCIP message and the Receiver is not an EOA, then the OffRamp contract transmits the CCIP message via the Router contract to the Receiver.

#### Bridged USDC (non-CCTP-enabled)
[Image: note]note

Are you a blockchain team interested in having CCIP support Bridged USDC on your network? If your implementation
follows the Circle Bridged USDC Standard, use this
form to discuss integration options.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }To facilitate USDC transfers between a blockchain that issues native USDC and another that only supports Bridged USDC, Chainlink CCIP employs the Lock and Mint mechanism. This approach ensures that each Bridged USDC token on the destination blockchain is fully backed by an equivalent amount of native USDC locked on the source blockchain. Accounting for Non-CCTP-Enabled USDC is isolated on a per-blockchain basis for security and risk mitigation.

1. Lock native USDC on Source: The Lock and Release token pool locks the specified USDC tokens.
2. Mint Bridged USDC on Destination: This Bridged USDC serves as a proxy for the original USDC, enabling liquidity and user adoption without direct integration with CCTP. A Burn and Mint token pool is recommended for the Destination Chain; it will mint Bridged USDC for incoming transfers and burn Bridged USDC for outgoing transfers. Other token pools are also supported, depending on the preferences and constraints of the Destination Chain.

## Example
In this tutorial, you will learn how to send USDC tokens from a smart contract on Avalanche Fuji to a smart contract on Ethereum Sepolia using Chainlink CCIP and pay CCIP fees in LINK tokens.
The process uses the following steps:

1. Transfer USDC and Data: Initiate a transfer of USDC tokens and associated data from the Sender contract on Avalanche Fuji. The data includes the required arguments and the signature of the stake function from the Staker contract.
2. Receive and Stake: The Receiver contract on Ethereum Sepolia receives the tokens and data. Then, it uses this data to make a low-level call to the Staker contract, executing the stake function to stake USDC on behalf of a beneficiary.
3. Redeem Staked Tokens: The beneficiary can redeem the staked tokens for USDC later.

The purpose of including the function signature and arguments in the data is to demonstrate how arbitrary data can support a variety of scenarios and use cases. By sending specific instructions within the data, you can define various interactions between smart contracts across different blockchain networks and make your decentralized application more flexible and powerful.

[Image: Chainlink CCIP usdc tutorial][Image: note]note

After you followed the tutorial:

• You can read the Explanation section to understand the smart
contracts' logic and how they interact with CCIP.
• Explore the CCIP USDC masterclass to find other examples of cross-chain transfers with USDC.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
### Before you begin

1. You should understand how to write, compile, deploy, and fund a smart contract. If you need to brush up on the basics, read this tutorial, which will guide you through using the Solidity programming language, interacting with the MetaMask wallet and working within the Remix Development Environment.
2. Your account must have some AVAX and LINK tokens on Avalanche Fuji and ETH tokens on Ethereum Sepolia. You can use the Chainlink faucet to acquire testnet tokens.
3. Check the CCIP Directory to confirm that USDC are supported for your lane. In this example, you will transfer tokens from Avalanche Fuji to Ethereum Sepolia so check the list of supported tokens here.
4. Use the Circle faucet to acquire USDC tokens on Avalanche Fuji.
5. Learn how to fund your contract. This guide shows how to fund your contract in LINK, but you can use the same guide for funding your contract with any ERC-20 tokens as long as they appear in the list of tokens in MetaMask.

### Tutorial

#### Deploy your contracts
Deploy the Sender contract on Avalanche Fuji:

1. Open the Sender contract in Remix.
2. Compile your contract.
3. Deploy, fund your sender contract on Avalanche Fuji and enable sending messages to Ethereum Sepolia:

Open MetaMask and select the network Avalanche Fuji.

In Remix IDE, click on Deploy & Run Transactions and select Injected Provider - MetaMask from the environment list. Remix will then interact with your MetaMask wallet to communicate with Avalanche Fuji.

Fill in your blockchain's router, LINK, and USDC contract addresses. The router and USDC addresses can be found on the CCIP Directory and the LINK contract address on the LINK token contracts page. For Avalanche Fuji, the addresses are:

Router address: 0xf694e193200268f9a4868e4aa017a0118c9a8177
LINK contract address: 0x0b9d5D9136855f6FEc3c0993feE6E9CE8a297846
USDC contract address: 0x5425890298aed601595a70AB815c96711a31Bc65

Click the transact button. After you confirm the transaction, the contract address appears on the Deployed Contracts list.
Note your contract address.

Open MetaMask and fund your contract with USDC tokens. You can transfer 1 USDC to your contract.

Fund your contract with LINK tokens. You can transfer 70 LINK to your contract. In this example, LINK is used to pay the CCIP fees.
Note: This transaction fee is significantly higher than normal due to gas spikes on Sepolia. To run this tutorial, you can get additional testnet LINK
from faucets.chain.link or use a supported testnet other than Sepolia.

Deploy the Staker and Receiver contracts on Ethereum Sepolia. Configure the Receiver contract to receive CCIP messages from the Sender contract:

1. Deploy the Staker contract:

Open MetaMask and select the network Ethereum Sepolia.

Open the Staker contract in Remix.

Compile your contract.

In Remix IDE, under Deploy & Run Transactions, make sure the environment is still Injected Provider - MetaMask.

Fill in the usdc contract address. The usdc contract address can be found on the CCIP Directory. For Ethereum Sepolia, the usdc contract address is:

0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238.

Click the transact button. After you confirm the transaction, the contract address appears on the Deployed Contracts list.

Note your contract address.
2. Deploy the Receiver contract:

Open the Receiver contract in Remix.

Compile your contract.

In Remix IDE, under Deploy & Run Transactions, make sure the environment is still Injected Provider - MetaMask and that you are still connected to Ethereum Sepolia.

Fill in your blockchain's router, LINK, and Staker contract addresses. The router and usdc addresses can be found on the CCIP Directory and the Staker contract address from the previous step. For Ethereum Sepolia, the addresses are:

Router address: 0x0BF3dE8c5D3e8A2B34D2BEeB17ABfCeBaf363A59
USDC contract address: 0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238
Staker address: Copied from the previous step
3. Configure the Receiver contract to receive CCIP messages from the Sender contract:

In Remix IDE, under Deploy & Run Transactions, open the list of transactions of your Receiver contract deployed on Ethereum Sepolia.

Fill in the arguments of the setSenderForSourceChain function:

ArgumentValue and Description_sourceChainSelector14767482510784806043  The chain selector of Avalanche Fuji. You can find it on the CCIP Directory._senderYour sender contract address at Avalanche Fuji.  The sender contract address.

Click on transact and confirm the transaction on MetaMask.
4. Configure the Sender contract on Avalanche Fuji:

Open MetaMask and select the network Avalanche Fuji.

In Remix IDE, under Deploy & Run Transactions, open the list of transactions of your Sender contract deployed on Avalanche Fuji.

Fill in the arguments of the setReceiverForDestinationChain function:

ArgumentValue and Description_destinationChainSelector16015286601757825753  The chain selector of Ethereum Sepolia. You can find it on the CCIP Directory._receiverYour receiver contract address at Ethereum Sepolia.  The receiver contract address.

Fill in the arguments of the setGasLimitForDestinationChain: function:

ArgumentValue and Description_destinationChainSelector16015286601757825753  The chain selector of Ethereum Sepolia. You can find it on the CCIP Directory._gasLimit200000  The gas limit for the execution of the CCIP message on the destination chain.

At this point:

• You have one sender contract on Avalanche Fuji, one staker contract and one receiver contract on Ethereum Sepolia.
• You enabled the sender contract to send messages to the receiver contract on Ethereum Sepolia.
• You set the gas limit for the execution of the CCIP message on Ethereum Sepolia.
• You enabled the receiver contract to receive messages from the sender contract on Avalanche Fuji.
• You funded the sender contract with USDC and LINK tokens on Avalanche Fuji.

#### Transfer and Receive tokens and data and pay in LINK
You will transfer 1 USDC and arbitrary data, which contains the encoded stake function name and parameters for calling Staker's stake function on the destination chain. The parameters contain the amount of staked tokens and the beneficiary address. The CCIP fees for using CCIP will be paid in LINK.

1. Transfer tokens and data from Avalanche Fuji:

Open MetaMask and select the network Avalanche Fuji.

In Remix IDE, under Deploy & Run Transactions, open the list of transactions of your smart contract deployed on Avalanche Fuji.

Fill in the arguments of the sendMessagePayLINK function:
ArgumentValue and Description_destinationChainSelector16015286601757825753  CCIP Chain identifier of the destination blockchain (Ethereum Sepolia in this example). You can find each chain selector on the CCIP Directory._beneficiaryThe beneficiary of the Staker tokens on Ethereum Sepolia. You can set your own EOA (Externally Owned Account) so you can redeem the Staker tokens in exchange for USDC tokens._amount1000000  The token amount (1 USDC).

Click on transact and confirm the transaction on MetaMask.

After the transaction is successful, record the transaction hash. Here is an example of a transaction on Avalanche Fuji.
      Gas price spikes  Under normal circumstances, transactions on the Ethereum Sepolia network require significantly fewer tokens to pay for gas. However, during exceptional periods of high gas price spikes, your transactions may fail if not sufficiently funded. In such cases, you may need to fund your contract with additional tokens. We recommend paying for your CCIP transactions in LINK tokens (rather than native tokens) as you can obtain extra LINK testnet tokens from faucets.chain.link. If you encounter a transaction failure due to these gas price spikes, please add additional LINK tokens to your contract and try again.
Alternatively, you can use a supported testnet other than Sepolia.
2. Open the CCIP explorer and search your cross-chain transaction using the transaction hash.
3. The CCIP transaction is completed once the status is marked as "Success". In this example, the CCIP message ID is 0xcb0fad9eec6664ad959f145cc4eb023924faded08baefc29952205ee37da7f13.
4. Check the balance of the beneficiary on the destination chain:

Open MetaMask and select the network Ethereum Sepolia.

In Remix IDE, under Deploy & Run Transactions, open the list of transactions of your Staker contract deployed on Ethereum Sepolia.

Call the balanceOf function with the beneficiary address.

  

Notice that the balance of the beneficiary is 1,000,000 Staker tokens. The Staker contract has the same number of decimals as the USDC token, which is 6. This means the beneficiary has 1 USDC staked and can redeem it by providing the same amount of Staker tokens.
5. Redeem the staked tokens:

Open MetaMask and make sure the network is Ethereum Sepolia.

Make sure you are connected with the beneficiary account.

In Remix IDE, under Deploy & Run Transactions, open the list of transactions of your Staker contract deployed on Ethereum Sepolia.

Call the redeem function with the amount of Staker tokens to redeem. In this example, the beneficiary will redeem 1,000,000 Staker tokens. When confirming, MetaMask will confirm that you will transfer the Staker tokens in exchange for USDC tokens.

  

Confirm the transaction on MetaMask. After the transaction is successful, the beneficiary will receive 1 USDC tokens.

## Explanation
[Image: note]Integrate Chainlink CCIP v1.6.0 into your project

(()=>{var a=(s,i,o)=>{let r=async()=>{await(await s())()},t=typeof i.value=="object"?i.value:void 0,c={rootMargin:t==null?void 0:t.rootMargin},n=new IntersectionObserver(e=>{for(let l of e)if(l.isIntersecting){n.disconnect(),r();break}},c);for(let e of o.children)n.observe(e)};(self.Astro||(self.Astro={})).visible=a;window.dispatchEvent(new Event("astro:visible"));})();npmyarnfoundryIf you use NPM, install the @chainlink/contracts-ccip NPM package:

[Image: copy to clipboard]
```shell
npm install @chainlink/contracts-ccip@1.6.0
```

If you use Yarn, install the @chainlink/contracts-ccip NPM package:

[Image: copy to clipboard]
```shell
yarn add @chainlink/contracts-ccip@1.6.0
```

If you use Foundry, install the package:

[Image: copy to clipboard]
```shell
forge install smartcontractkit/chainlink-ccip@2114b90f39c82c052e05af7c33d42c1ae98f4180
```

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }The smart contracts featured in this tutorial are designed to interact with CCIP to send and receive USDC tokens and data across different blockchains. The contract code contains supporting comments clarifying the functions, events, and underlying logic. We will explain the Sender, Staker, and Receiver contracts further.

### Sender Contract
[Image: copy to clipboard]
```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import {IRouterClient} from "@chainlink/contracts-ccip/contracts/interfaces/IRouterClient.sol";
import {OwnerIsCreator} from "@chainlink/contracts/src/v0.8/shared/access/OwnerIsCreator.sol";
import {Client} from "@chainlink/contracts-ccip/contracts/libraries/Client.sol";
import {IERC20} from "@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/utils/SafeERC20.sol";

/**
 * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
 * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

interface IStaker {
    function stake(address beneficiary, uint256 amount) external;

    function redeem() external;
}

/// @title - A simple messenger contract for transferring tokens to a receiver  that calls a staker contract.
contract Sender is OwnerIsCreator {
    using SafeERC20 for IERC20;

    // Custom errors to provide more descriptive revert messages.
    error InvalidRouter(); // Used when the router address is 0
    error InvalidLinkToken(); // Used when the link token address is 0
    error InvalidUsdcToken(); // Used when the usdc token address is 0
    error NotEnoughBalance(uint256 currentBalance, uint256 calculatedFees); // Used to make sure contract has enough balance to cover the fees.
    error NothingToWithdraw(); // Used when trying to withdraw Ether but there's nothing to withdraw.
    error InvalidDestinationChain(); // Used when the destination chain selector is 0.
    error InvalidReceiverAddress(); // Used when the receiver address is 0.
    error NoReceiverOnDestinationChain(uint64 destinationChainSelector); // Used when the receiver address is 0 for a given destination chain.
    error AmountIsZero(); // Used if the amount to transfer is 0.
    error InvalidGasLimit(); // Used if the gas limit is 0.
    error NoGasLimitOnDestinationChain(uint64 destinationChainSelector); // Used when the gas limit is 0.

    // Event emitted when a message is sent to another chain.
    event MessageSent(
        bytes32 indexed messageId, // The unique ID of the CCIP message.
        uint64 indexed destinationChainSelector, // The chain selector of the destination chain.
        address indexed receiver, // The address of the receiver contract on the destination chain.
        address beneficiary, // The beneficiary of the staked tokens on the destination chain.
        address token, // The token address that was transferred.
        uint256 tokenAmount, // The token amount that was transferred.
        address feeToken, // the token address used to pay CCIP fees.
        uint256 fees // The fees paid for sending the message.
    );

    IRouterClient private immutable i_router;
    IERC20 private immutable i_linkToken;
    IERC20 private immutable i_usdcToken;

    // Mapping to keep track of the receiver contract per destination chain.
    mapping(uint64 => address) public s_receivers;
    // Mapping to store the gas limit per destination chain.
    mapping(uint64 => uint256) public s_gasLimits;

    modifier validateDestinationChain(uint64 _destinationChainSelector) {
        if (_destinationChainSelector == 0) revert InvalidDestinationChain();
        _;
    }

    /// @notice Constructor initializes the contract with the router address.
    /// @param _router The address of the router contract.
    /// @param _link The address of the link contract.
    /// @param _usdcToken The address of the usdc contract.
    constructor(address _router, address _link, address _usdcToken) {
        if (_router == address(0)) revert InvalidRouter();
        if (_link == address(0)) revert InvalidLinkToken();
        if (_usdcToken == address(0)) revert InvalidUsdcToken();
        i_router = IRouterClient(_router);
        i_linkToken = IERC20(_link);
        i_usdcToken = IERC20(_usdcToken);
    }

    /// @dev Set the receiver contract for a given destination chain.
    /// @notice This function can only be called by the owner.
    /// @param _destinationChainSelector The selector of the destination chain.
    /// @param _receiver The receiver contract on the destination chain .
    function setReceiverForDestinationChain(
        uint64 _destinationChainSelector,
        address _receiver
    ) external onlyOwner validateDestinationChain(_destinationChainSelector) {
        if (_receiver == address(0)) revert InvalidReceiverAddress();
        s_receivers[_destinationChainSelector] = _receiver;
    }

    /// @dev Set the gas limit for a given destination chain.
    /// @notice This function can only be called by the owner.
    /// @param _destinationChainSelector The selector of the destination chain.
    /// @param _gasLimit The gas limit on the destination chain .
    function setGasLimitForDestinationChain(
        uint64 _destinationChainSelector,
        uint256 _gasLimit
    ) external onlyOwner validateDestinationChain(_destinationChainSelector) {
        if (_gasLimit == 0) revert InvalidGasLimit();
        s_gasLimits[_destinationChainSelector] = _gasLimit;
    }

    /// @dev Delete the receiver contract for a given destination chain.
    /// @notice This function can only be called by the owner.
    /// @param _destinationChainSelector The selector of the destination chain.
    function deleteReceiverForDestinationChain(
        uint64 _destinationChainSelector
    ) external onlyOwner validateDestinationChain(_destinationChainSelector) {
        if (s_receivers[_destinationChainSelector] == address(0))
            revert NoReceiverOnDestinationChain(_destinationChainSelector);
        delete s_receivers[_destinationChainSelector];
    }

    /// @notice Sends data and transfer tokens to receiver on the destination chain.
    /// @notice Pay for fees in LINK.
    /// @dev Assumes your contract has sufficient LINK to pay for CCIP fees.
    /// @param _destinationChainSelector The identifier (aka selector) for the destination blockchain.
    /// @param _beneficiary The address of the beneficiary of the staked tokens on the destination blockchain.
    /// @param _amount token amount.
    /// @return messageId The ID of the CCIP message that was sent.
    function sendMessagePayLINK(
        uint64 _destinationChainSelector,
        address _beneficiary,
        uint256 _amount
    )
        external
        onlyOwner
        validateDestinationChain(_destinationChainSelector)
        returns (bytes32 messageId)
    {
        address receiver = s_receivers[_destinationChainSelector];
        if (receiver == address(0))
            revert NoReceiverOnDestinationChain(_destinationChainSelector);
        if (_amount == 0) revert AmountIsZero();
        uint256 gasLimit = s_gasLimits[_destinationChainSelector];
        if (gasLimit == 0)
            revert NoGasLimitOnDestinationChain(_destinationChainSelector);
        // Create an EVM2AnyMessage struct in memory with necessary information for sending a cross-chain message
        // address(linkToken) means fees are paid in LINK
        Client.EVMTokenAmount[]
            memory tokenAmounts = new Client.EVMTokenAmount[](1);
        tokenAmounts[0] = Client.EVMTokenAmount({
            token: address(i_usdcToken),
            amount: _amount
        });
        // Create an EVM2AnyMessage struct in memory with necessary information for sending a cross-chain message
        Client.EVM2AnyMessage memory evm2AnyMessage = Client.EVM2AnyMessage({
            receiver: abi.encode(receiver), // ABI-encoded receiver address
            data: abi.encodeWithSelector(
                IStaker.stake.selector,
                _beneficiary,
                _amount
            ), // Encode the function selector and the arguments of the stake function
            tokenAmounts: tokenAmounts, // The amount and type of token being transferred
            extraArgs: Client._argsToBytes(
                // Additional arguments, setting gas limit and allowing out-of-order execution.
                // Best Practice: For simplicity, the values are hardcoded. It is advisable to use a more dynamic approach
                // where you set the extra arguments off-chain. This allows adaptation depending on the lanes, messages,
                // and ensures compatibility with future CCIP upgrades. Read more about it here: https://docs.chain.link/ccip/concepts/best-practices/evm#using-extraargs
                Client.GenericExtraArgsV2({
                    gasLimit: gasLimit, // Gas limit for the callback on the destination chain
                    allowOutOfOrderExecution: true // Allows the message to be executed out of order relative to other messages from the same sender
                })
            ),
            // Set the feeToken to a feeTokenAddress, indicating specific asset will be used for fees
            feeToken: address(i_linkToken)
        });

        // Get the fee required to send the CCIP message
        uint256 fees = i_router.getFee(
            _destinationChainSelector,
            evm2AnyMessage
        );

        if (fees > i_linkToken.balanceOf(address(this)))
            revert NotEnoughBalance(i_linkToken.balanceOf(address(this)), fees);

        // approve the Router to transfer LINK tokens on contract's behalf. It will spend the fees in LINK
        i_linkToken.approve(address(i_router), fees);

        // approve the Router to spend usdc tokens on contract's behalf. It will spend the amount of the given token
        i_usdcToken.approve(address(i_router), _amount);

        // Send the message through the router and store the returned message ID
        messageId = i_router.ccipSend(
            _destinationChainSelector,
            evm2AnyMessage
        );

        // Emit an event with message details
        emit MessageSent(
            messageId,
            _destinationChainSelector,
            receiver,
            _beneficiary,
            address(i_usdcToken),
            _amount,
            address(i_linkToken),
            fees
        );

        // Return the message ID
        return messageId;
    }

    /// @notice Allows the owner of the contract to withdraw all LINK tokens in the contract and transfer them to a beneficiary.
    /// @dev This function reverts with a 'NothingToWithdraw' error if there are no tokens to withdraw.
    /// @param _beneficiary The address to which the tokens will be sent.
    function withdrawLinkToken(address _beneficiary) public onlyOwner {
        // Retrieve the balance of this contract
        uint256 amount = i_linkToken.balanceOf(address(this));

        // Revert if there is nothing to withdraw
        if (amount == 0) revert NothingToWithdraw();

        i_linkToken.safeTransfer(_beneficiary, amount);
    }

    /// @notice Allows the owner of the contract to withdraw all usdc tokens in the contract and transfer them to a beneficiary.
    /// @dev This function reverts with a 'NothingToWithdraw' error if there are no tokens to withdraw.
    /// @param _beneficiary The address to which the tokens will be sent.
    function withdrawUsdcToken(address _beneficiary) public onlyOwner {
        // Retrieve the balance of this contract
        uint256 amount = i_usdcToken.balanceOf(address(this));

        // Revert if there is nothing to withdraw
        if (amount == 0) revert NothingToWithdraw();

        i_usdcToken.safeTransfer(_beneficiary, amount);
    }
}
```

[Open in Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/CCIP/usdc/Sender.sol&autoCompile=true)[What is Remix?](/getting-started/conceptual-overview#what-is-remix)The Sender contract is responsible for initiating the transfer of USDC tokens and data. Here's how it works:

1. Initializing the contract:

When deploying the contract, you define the router address, LINK contract address, and USDC contract address.
These addresses are essential for interacting with the CCIP router and handling token transfers.
2. sendMessagePayLINK function:

This function sends USDC tokens, the encoded function signature of the stake function, and arguments (beneficiary address and amount) to the Receiver contract on the destination chain.
Constructs a CCIP message using the EVM2AnyMessage struct.
Computes the necessary fees using the router's getFee function.
Ensures the contract has enough LINK to cover the fees and approves the router transfer of LINK on its behalf.
Dispatches the CCIP message to the destination chain by executing the router's ccipSend function.
Emits a MessageSent event.

      Best Practices  This example is simplified for educational purposes. For production code, please adhere to the following best practices:

Do Not Hardcode extraArgs: In this example, extraArgs are hardcoded within the contract for simplicity. It is recommended to make extraArgs mutable. For instance, you can construct extraArgs off-chain and pass them into your function calls, or store them in a storage variable that can be updated as needed. This approach ensures that extraArgs remain backward compatible with future CCIP upgrades. Refer to the Best Practices guide for more information.

Validate the Destination Chain: Always ensure that the destination chain is valid and supported before sending messages.

Understand allowOutOfOrderExecution Usage: This example sets allowOutOfOrderExecution to true (see GenericExtraArgsV2). Read the Best Practices: Setting allowOutOfOrderExecution to learn more about this parameter.

Understand CCIP Service Limits: Review the CCIP Service Limits for constraints on message data size, execution gas, and the number of tokens per transaction. If your requirements exceed these limits, you may need to contact the Chainlink Labs Team.

Following these best practices ensures that your contract is robust, future-proof, and compliant with CCIP standards.

### Staker Contract
[Image: copy to clipboard]
```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import {ERC20} from "@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/ERC20.sol";
import {SafeERC20} from "@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/utils/SafeERC20.sol";

/**
 * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
 * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

interface IStaker {
    function stake(address beneficiary, uint256 amount) external;

    function redeem() external;
}

/// @title - A simple Staker contract for staking usc tokens and redeeming the staker contracts
contract Staker is IStaker, ERC20 {
    using SafeERC20 for ERC20;

    error InvalidUsdcToken(); // Used when the usdc token address is 0
    error InvalidNumberOfDecimals(); // Used when the number of decimals is 0
    error InvalidBeneficiary(); // Used when the beneficiary address is 0
    error InvalidAmount(); // Used when the amount is 0
    error NothingToRedeem(); // Used when the balance of Staker tokens is 0

    event UsdcStaked(address indexed beneficiary, uint256 amount);
    event UsdcRedeemed(address indexed beneficiary, uint256 amount);

    ERC20 private immutable i_usdcToken;
    uint8 private immutable i_decimals;

    /// @notice Constructor initializes the contract with the usdc token address.
    /// @param _usdcToken The address of the usdc contract.
    constructor(address _usdcToken) ERC20("Simple Staker", "STK") {
        if (_usdcToken == address(0)) revert InvalidUsdcToken();
        i_usdcToken = ERC20(_usdcToken);
        i_decimals = i_usdcToken.decimals();
        if (i_decimals == 0) revert InvalidNumberOfDecimals();
    }

    function stake(address _beneficiary, uint256 _amount) external {
        if (_beneficiary == address(0)) revert InvalidBeneficiary();
        if (_amount == 0) revert InvalidAmount();

        i_usdcToken.safeTransferFrom(msg.sender, address(this), _amount);
        _mint(_beneficiary, _amount);
        emit UsdcStaked(_beneficiary, _amount);
    }

    function redeem() external {
        uint256 balance = balanceOf(msg.sender);
        if (balance == 0) revert NothingToRedeem();
        _burn(msg.sender, balance);
        i_usdcToken.safeTransfer(msg.sender, balance);
        emit UsdcRedeemed(msg.sender, balance);
    }

    function decimals() public view override returns (uint8) {
        return i_decimals;
    }
}
```

[Open in Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/CCIP/usdc/Staker.sol&autoCompile=true)[What is Remix?](/getting-started/conceptual-overview#what-is-remix)The Staker contract manages the staking and redemption of USDC tokens. Here's how it works:

1. Initializing the contract:

When deploying the contract, you define the USDC token address.
This address is essential for interacting with the USDC token contract.
2. stake function:

Allows staking of USDC tokens on behalf of a beneficiary.
Transfers USDC from the caller (msg.sender) to the contract, then mints an equivalent amount of staking tokens to the beneficiary.
3. redeem function:

Allows beneficiaries to redeem their staked tokens for USDC.
Burns the staked tokens and transfers the equivalent USDC to the beneficiary.

### Receiver Contract
[Image: copy to clipboard]
```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import {OwnerIsCreator} from "@chainlink/contracts/src/v0.8/shared/access/OwnerIsCreator.sol";
import {Client} from "@chainlink/contracts-ccip/contracts/libraries/Client.sol";
import {CCIPReceiver} from "@chainlink/contracts-ccip/contracts/applications/CCIPReceiver.sol";
import {IERC20} from "@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/utils/SafeERC20.sol";
import {EnumerableMap} from "@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/utils/structs/EnumerableMap.sol";

/**
 * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
 * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

/// @title - A simple receiver contract for receiving usdc tokens then calling a staking contract.
contract Receiver is CCIPReceiver, OwnerIsCreator {
    using SafeERC20 for IERC20;
    using EnumerableMap for EnumerableMap.Bytes32ToUintMap;

    error InvalidUsdcToken(); // Used when the usdc token address is 0
    error InvalidStaker(); // Used when the staker address is 0
    error InvalidSourceChain(); // Used when the source chain is 0
    error InvalidSenderAddress(); // Used when the sender address is 0
    error NoSenderOnSourceChain(uint64 sourceChainSelector); // Used when there is no sender for a given source chain
    error WrongSenderForSourceChain(uint64 sourceChainSelector); // Used when the sender contract is not the correct one
    error OnlySelf(); // Used when a function is called outside of the contract itself
    error WrongReceivedToken(address usdcToken, address receivedToken); // Used if the received token is different than usdc token
    error CallToStakerFailed(); // Used when the call to the stake function of the staker contract is not successful
    error NoReturnDataExpected(); // Used if the call to the stake function of the staker contract returns data. This is not expected
    error MessageNotFailed(bytes32 messageId); // Used if you try to retry a message that has no failed

    // Event emitted when a message is received from another chain.
    event MessageReceived(
        bytes32 indexed messageId, // The unique ID of the CCIP message.
        uint64 indexed sourceChainSelector, // The chain selector of the source chain.
        address indexed sender, // The address of the sender from the source chain.
        bytes data, // The data that was received.
        address token, // The token address that was transferred.
        uint256 tokenAmount // The token amount that was transferred.
    );

    event MessageFailed(bytes32 indexed messageId, bytes reason);
    event MessageRecovered(bytes32 indexed messageId);

    // Example error code, could have many different error codes.
    enum ErrorCode {
        // RESOLVED is first so that the default value is resolved.
        RESOLVED,
        // Could have any number of error codes here.
        FAILED
    }

    struct FailedMessage {
        bytes32 messageId;
        ErrorCode errorCode;
    }

    IERC20 private immutable i_usdcToken;
    address private immutable i_staker;

    // Mapping to keep track of the sender contract per source chain.
    mapping(uint64 => address) public s_senders;

    // The message contents of failed messages are stored here.
    mapping(bytes32 => Client.Any2EVMMessage) public s_messageContents;

    // Contains failed messages and their state.
    EnumerableMap.Bytes32ToUintMap internal s_failedMessages;

    modifier validateSourceChain(uint64 _sourceChainSelector) {
        if (_sourceChainSelector == 0) revert InvalidSourceChain();
        _;
    }

    /// @dev Modifier to allow only the contract itself to execute a function.
    /// Throws an exception if called by any account other than the contract itself.
    modifier onlySelf() {
        if (msg.sender != address(this)) revert OnlySelf();
        _;
    }

    /// @notice Constructor initializes the contract with the router address.
    /// @param _router The address of the router contract.
    /// @param _usdcToken The address of the usdc contract.
    /// @param _staker The address of the staker contract.
    constructor(
        address _router,
        address _usdcToken,
        address _staker
    ) CCIPReceiver(_router) {
        if (_usdcToken == address(0)) revert InvalidUsdcToken();
        if (_staker == address(0)) revert InvalidStaker();
        i_usdcToken = IERC20(_usdcToken);
        i_staker = _staker;
        i_usdcToken.safeApprove(_staker, type(uint256).max);
    }

    /// @dev Set the sender contract for a given source chain.
    /// @notice This function can only be called by the owner.
    /// @param _sourceChainSelector The selector of the source chain.
    /// @param _sender The sender contract on the source chain .
    function setSenderForSourceChain(
        uint64 _sourceChainSelector,
        address _sender
    ) external onlyOwner validateSourceChain(_sourceChainSelector) {
        if (_sender == address(0)) revert InvalidSenderAddress();
        s_senders[_sourceChainSelector] = _sender;
    }

    /// @dev Delete the sender contract for a given source chain.
    /// @notice This function can only be called by the owner.
    /// @param _sourceChainSelector The selector of the source chain.
    function deleteSenderForSourceChain(
        uint64 _sourceChainSelector
    ) external onlyOwner validateSourceChain(_sourceChainSelector) {
        if (s_senders[_sourceChainSelector] == address(0))
            revert NoSenderOnSourceChain(_sourceChainSelector);
        delete s_senders[_sourceChainSelector];
    }

    /// @notice The entrypoint for the CCIP router to call. This function should
    /// never revert, all errors should be handled internally in this contract.
    /// @param any2EvmMessage The message to process.
    /// @dev Extremely important to ensure only router calls this.
    function ccipReceive(
        Client.Any2EVMMessage calldata any2EvmMessage
    ) external override onlyRouter {
        // validate the sender contract
        if (
            abi.decode(any2EvmMessage.sender, (address)) !=
            s_senders[any2EvmMessage.sourceChainSelector]
        ) revert WrongSenderForSourceChain(any2EvmMessage.sourceChainSelector);
        /* solhint-disable no-empty-blocks */
        try this.processMessage(any2EvmMessage) {
            // Intentionally empty in this example; no action needed if processMessage succeeds
        } catch (bytes memory err) {
            // Could set different error codes based on the caught error. Each could be
            // handled differently.
            s_failedMessages.set(
                any2EvmMessage.messageId,
                uint256(ErrorCode.FAILED)
            );
            s_messageContents[any2EvmMessage.messageId] = any2EvmMessage;
            // Don't revert so CCIP doesn't revert. Emit event instead.
            // The message can be retried later without having to do manual execution of CCIP.
            emit MessageFailed(any2EvmMessage.messageId, err);
            return;
        }
    }

    /// @notice Serves as the entry point for this contract to process incoming messages.
    /// @param any2EvmMessage Received CCIP message.
    /// @dev Transfers specified token amounts to the owner of this contract. This function
    /// must be external because of the  try/catch for error handling.
    /// It uses the `onlySelf`: can only be called from the contract.
    function processMessage(
        Client.Any2EVMMessage calldata any2EvmMessage
    ) external onlySelf {
        _ccipReceive(any2EvmMessage); // process the message - may revert
    }

    function _ccipReceive(
        Client.Any2EVMMessage memory any2EvmMessage
    ) internal override {
        if (any2EvmMessage.destTokenAmounts[0].token != address(i_usdcToken))
            revert WrongReceivedToken(
                address(i_usdcToken),
                any2EvmMessage.destTokenAmounts[0].token
            );

        (bool success, bytes memory returnData) = i_staker.call(
            any2EvmMessage.data
        ); // low level call to the staker contract using the encoded function selector and arguments
        if (!success) revert CallToStakerFailed();
        if (returnData.length > 0) revert NoReturnDataExpected();
        emit MessageReceived(
            any2EvmMessage.messageId,
            any2EvmMessage.sourceChainSelector, // fetch the source chain identifier (aka selector)
            abi.decode(any2EvmMessage.sender, (address)), // abi-decoding of the sender address,
            any2EvmMessage.data, // received data
            any2EvmMessage.destTokenAmounts[0].token,
            any2EvmMessage.destTokenAmounts[0].amount
        );
    }

    /// @notice Allows the owner to retry a failed message in order to unblock the associated tokens.
    /// @param messageId The unique identifier of the failed message.
    /// @param beneficiary The address to which the tokens will be sent.
    /// @dev This function is only callable by the contract owner. It changes the status of the message
    /// from 'failed' to 'resolved' to prevent reentry and multiple retries of the same message.
    function retryFailedMessage(
        bytes32 messageId,
        address beneficiary
    ) external onlyOwner {
        // Check if the message has failed; if not, revert the transaction.
        if (s_failedMessages.get(messageId) != uint256(ErrorCode.FAILED))
            revert MessageNotFailed(messageId);

        // Set the error code to RESOLVED to disallow reentry and multiple retries of the same failed message.
        s_failedMessages.set(messageId, uint256(ErrorCode.RESOLVED));

        // Retrieve the content of the failed message.
        Client.Any2EVMMessage memory message = s_messageContents[messageId];

        // This example expects one token to have been sent.
        // Transfer the associated tokens to the specified receiver as an escape hatch.
        IERC20(message.destTokenAmounts[0].token).safeTransfer(
            beneficiary,
            message.destTokenAmounts[0].amount
        );

        // Emit an event indicating that the message has been recovered.
        emit MessageRecovered(messageId);
    }

    /// @notice Retrieves a paginated list of failed messages.
    /// @dev This function returns a subset of failed messages defined by `offset` and `limit` parameters. It ensures that the pagination parameters are within the bounds of the available data set.
    /// @param offset The index of the first failed message to return, enabling pagination by skipping a specified number of messages from the start of the dataset.
    /// @param limit The maximum number of failed messages to return, restricting the size of the returned array.
    /// @return failedMessages An array of `FailedMessage` struct, each containing a `messageId` and an `errorCode` (RESOLVED or FAILED), representing the requested subset of failed messages. The length of the returned array is determined by the `limit` and the total number of failed messages.
    function getFailedMessages(
        uint256 offset,
        uint256 limit
    ) external view returns (FailedMessage[] memory) {
        uint256 length = s_failedMessages.length();

        // Calculate the actual number of items to return (can't exceed total length or requested limit)
        uint256 returnLength = (offset + limit > length)
            ? length - offset
            : limit;
        FailedMessage[] memory failedMessages = new FailedMessage[](
            returnLength
        );

        // Adjust loop to respect pagination (start at offset, end at offset + limit or total length)
        for (uint256 i = 0; i < returnLength; i++) {
            (bytes32 messageId, uint256 errorCode) = s_failedMessages.at(
                offset + i
            );
            failedMessages[i] = FailedMessage(messageId, ErrorCode(errorCode));
        }
        return failedMessages;
    }
}
```

[Open in Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/CCIP/usdc/Receiver.sol&autoCompile=true)[What is Remix?](/getting-started/conceptual-overview#what-is-remix)The Receiver contract handles incoming cross-chain messages, processes them, and interacts with the Staker contract to stake USDC on behalf of the beneficiary. Here's how it works:

1. Initializing the Contract:

When deploying the contract, you define the router address, USDC token address, and staker contract address.
These addresses are essential for interacting with the CCIP router, USDC token, and Staker contracts.
2. ccipReceive function:

The entry point for the CCIP router to deliver messages to the contract.
Validates the sender and processes the message, ensuring it comes from the correct sender contract on the source chain.
3. Processing Message:

Calls the processMessage function, which is external to leverage Solidity's try/catch error handling mechanism.
Inside processMessage, it calls the _ccipReceive function for further message processing.
4. _ccipReceive function:

Checks if the received token is USDC. If not, it reverts.
Makes a low-level call to the stake function of the Staker contract using the encoded function signature and arguments from the received data.
Emits a MessageReceived event upon successful processing.
5. Error Handling:

If an error occurs during processing, the catch block within ccipReceive is executed.
The messageId of the failed message is added to s_failedMessages, and the message content is stored in s_messageContents.
A MessageFailed event is emitted, allowing for later identification and reprocessing of failed messages.
6. retryFailedMessage function:

Allows the contract owner to retry a failed message and recover the associated tokens.
Updates the error code for the message to RESOLVED to prevent multiple retries.
Transfers the locked tokens associated with the failed message to the specified beneficiary as an escape hatch.
7. getFailedMessages function:

Retrieves a paginated list of failed messages for inspection.

[Image: caution]Educational Example Disclaimer

This page includes an educational example to use a Chainlink system, product, or service and is provided to
demonstrate how to interact with Chainlink's systems, products, and services to integrate them into your own. This
template is provided "AS IS" and "AS AVAILABLE" without warranties of any kind, it has not been audited, and it may be
missing key checks or error handling to make the usage of the system, product or service more clear. Do not use the
code in this example in a production environment without completing your own audits and application of best practices.
Neither Chainlink Labs, the Chainlink Foundation, nor Chainlink node operators are responsible for unintended outputs
that are generated due to errors in code.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }

================================================================================

# Chainlink Data Feeds

Source: https://docs.chain.link/data-feeds
Extraction Method: playwright

# Chainlink Data Feeds
[Image: note]Talk to an expert

Contact us to talk to an expert about integrating Chainlink
Data Feeds with your applications.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }Chainlink Data Feeds are the quickest way to connect your smart contracts to real-world data such as asset prices, reserve balances, and L2 sequencer health.

If you already started a project and need to integrate Chainlink, you can add Chainlink to your existing project with the @chainlink/contracts NPM package.

## Types of data feeds
Data feeds provide many different types of data for your applications.

• Price Feeds
• SmartData Feeds

Multiple-Variable Response (MVR) Feeds
• Smart Value Recapture (SVR) Feeds
• Rate and Volatility Feeds
• L2 sequencer uptime feeds

### Price Feeds
Smart contracts often act in real-time on data such as prices of assets. This is especially true in DeFi.

For example, lending and borrowing platforms like Aave utilize Data Feeds to assess collateral value accurately, while perpetual platforms such as GMX rely on these feeds to validate offchain data and ensure that each deposit or withdrawal executes at the correct market value.

Data Feeds aggregate many data sources and publish them onchain using a combination of the Decentralized Data Model and Offchain Reporting.

• To learn how to use Price Feeds, see the Price Feeds documentation.
• See the Data Feeds Contract Addresses page for a list of available networks and addresses.

### SmartData Feeds
Chainlink SmartData is a suite of onchain data offerings designed to unlock the utility, accessibility, and reliability of tokenized real-world assets (RWAs). By providing secure minting assurances alongside essential real-world data such as reserves, Net Asset Value (NAV), and Assets Under Management (AUM) data, the SmartData suite embeds security and enriches data into tokenized RWA offerings.

• To learn more about the broader SmartData suite, see the SmartData documentation.
• See the SmartData Contract Addresses page for a list of available networks and addresses.

#### Multiple-Variable Response (MVR) Feeds
The SmartData suite includes Multiple-Variable Response (MVR) Feeds, which bundle multiple data points of various types into a single onchain update. Unlike traditional feeds that provide only one numeric value, MVR feeds can return multiple values of different types (both numeric and non-numeric) in a single transaction.

• To learn more about MVR Feeds, see the Multiple-Variable Response (MVR) Feeds documentation.
• See the SmartData Contract Addresses page for a list of available networks and addresses. Use the Show Multiple-Variable Response (MVR) feeds checkbox to filter the list.

### Smart Value Recapture (SVR) Feeds
Smart Value Recapture (SVR) Feeds introduce a mechanism to recapture Oracle Extractable Value (OEV), a form of MEV associated with oracle updates, often observed during liquidations.

• To learn more, see the Smart Value Recapture (SVR) Feeds documentation.
• Find SVR-enabled addresses on the Price Feed Addresses page by filtering for SVR feeds.

### Rate and Volatility Feeds
Several feeds provide interest rate curve data, APY data, and realized asset price volatility.

• To learn more, see the Rate and Volatility Feeds documentation.
• See the Rate and Volatility Contract Addresses page for a list of available networks and addresses.

### L2 sequencer uptime feeds
L2 sequencer feeds track the last known status of the sequencer on an L2 network at a given point in time. This helps you prevent mass liquidations by providing a grace period to allow customers to react to these events.

To learn how to use L2 sequencer uptime feeds, see the L2 Sequencer Uptime Feeds documentation.

## Components of a data feed
Data Feeds are examples of decentralized oracle networks with different interfaces depending on the type of data they provide. Each feed type includes specific components:

### Single-value Feed Components
Data feeds that deliver a single numeric value (such as price feeds or single-value SmartData feeds) include the following components:

• Consumer: A consumer is an onchain or offchain application that uses Data Feeds. Consumer contracts use the AggregatorV3Interface to call functions on the proxy contract and retrieve information from the aggregator contract. For a complete list of functions available in the AggregatorV3Interface, see the Data Feeds API Reference.
• Proxy contract: Proxy contracts are onchain proxies that point to the aggregator for a particular data feed. Using proxies enables the underlying aggregator to be upgraded without any service interruption to consuming contracts. Proxy contracts can vary from one data feed to another, but the EACAggregatorProxy.sol contract on Github is a common example.
• Aggregator contract: An aggregator is a contract that receives periodic data updates from the oracle network. Aggregators store aggregated data onchain so that consumers can retrieve it and act upon it within the same transaction. For a complete list of functions and variables available on most aggregator contracts, see the Data Feeds API Reference.

To learn how to create a consumer contract that uses an existing price feed, read the Using Data Feeds documentation.

### MVR Feed Components
Multiple-Variable Response (MVR) Feeds, which deliver multiple data points of various types in a single bundle, include the following components:

• Consumer: A consumer is an onchain or offchain application that uses MVR Feeds. Consumer contracts use the IBundleAggregatorProxy interface to call functions on the proxy contract and retrieve bundle data.
• Bundle Aggregator Proxy: This proxy contract points to the underlying bundle aggregator. Using proxies enables the underlying aggregator to be upgraded without service interruption to consuming contracts. The proxy exposes functions like latestBundle(), bundleDecimals(), and latestBundleTimestamp() for consumers to access the bundled data.

To learn how to create a consumer contract that uses an existing MVR feed, read the Using MVR Feeds on EVM Chains (Solidity) guide.

## Reading proxy and aggregator configurations
Because the proxy and aggregator contracts are all onchain, you can see the current configuration by reading the variables through an ABI or using a blockchain explorer for your network. For example, you can see the BTC/USD proxy configuration on the Ethereum network using Etherscan.

If you read the BTC/USD proxy configuration, you can query all of the functions and variables that are publicly accessible for that contract including the aggregator address, latestRoundData() function, latestAnswer variable, owner address, latestTimestamp variable, and several others. To see descriptions for the proxy contract variables and functions, see the source code for your specific data feed on Etherscan.

The proxy contract points to an aggregator. This allows you to retrieve data through the proxy even if the aggregator is upgraded. If you view the aggregator address defined in the proxy configuration, you can see the aggregator and its configuration. For example, see the BTC/USD aggregator contract in Etherscan. This contract includes several variables and functions, including another latestRoundData(). To see descriptions for the aggregator variables and functions, see the source code on GitHub or Etherscan.

You can call the latestRoundData() function directly on the aggregator, but it is a best practice to use the proxy instead so that changes to the aggregator do not affect your application. Similar to the proxy contract, the aggregator contract has a latestAnswer variable, owner address, latestTimestamp variable, and several others.

## Components of an aggregator
The aggregator contract has several variables and functions that might be useful for your application. Although aggregator contracts are similar for each data feed, some aggregators have different variables. Use the typeAndVersion() function on the aggregator to identify what type of aggregator it is and what version it is running.

Always check the contract source code and configuration to understand how specific data feeds operate. For example, the aggregator contract for BTC/USD on Arbitrum is different from the aggregators on other networks.

For examples of the contracts that are typically used in aggregator deployments, see the libocr repository on GitHub.

For a complete list of functions and variables available on most aggregator contracts, see the Data Feeds API Reference.

## Updates to proxy and aggregator contracts
To accommodate the dynamic nature of offchain environments, Chainlink Data Feeds are updated from time to time to add new features and capabilities as well as respond to externalities such as token migrations, protocol rebrands, extreme market events, and upstream issues with data or node operations.

These updates include changes to the aggregator configuration or a complete replacement of the aggregator that the proxy uses. If you consume data feeds through the proxy, your applications can continue to operate during these changes.

Proxy and aggregator contracts all have an owner address that has permission to change variables and functions. For example, if you read the BTC/USD proxy contract in Etherscan, you can see the owner address. This address is a multi-signature safe (multisig) that you can also inspect.

If you view the multisig contract in Etherscan using the Read as Proxy feature, you can see the full details of the multisig including the list of addresses that can sign and the number of signers required for the multisig to approve actions on any contracts that it owns.

The multisig-coordinated upgradability of Chainlink Data Feeds involves time-tested processes that balance collusion-resistance with the flexibility required to implement improvements and swiftly react to external conditions. The approach taken to upgradability will continue to evolve over time to meet user requirements.

## Monitoring data feeds
When you build applications and protocols that depend on data feeds, include monitoring and safeguards to protect against the negative impact of extreme market events, possible malicious activity on third-party venues or contracts, potential delays, and outages.

Create your own monitoring alerts based on deviations in the answers that data feeds provide. This will notify you when potential issues occur so you can respond to them.

### Check the latest answer against reasonable limits
The data feed aggregator includes both minAnswer and maxAnswer values. On most data feeds, these values are no longer used and they do not stop your application from reading the most recent answer. For monitoring purposes, you must decide what limits are acceptable for your application.

Configure your application to detect when the reported answer is close to reaching reasonable minimum and maximum limits so it can alert you to potential market events. Separately, configure your application to detect and respond to extreme price volatility or prices that are outside of your acceptable limits.

### Check the timestamp of the latest answer
Chainlink Data Feeds do not provide streaming data. Rather, the aggregator updates its latestAnswer when the value deviates beyond a specified threshold or when the heartbeat idle time has passed. You can find the heartbeat and deviation values for each data feed at data.chain.link or in the Contract Addresses lists.

Your application should track the latestTimestamp variable or use the updatedAt value from the latestRoundData() function to make sure that the latest answer is recent enough for your application to use it. If your application detects that the reported answer is not updated within the heartbeat or within time limits that you determine are acceptable for your application, pause operation or switch to an alternate operation mode while identifying the cause of the delay.

When the node detects that the heartbeat is reached, it initiates the latest round. Depending on congestion and network conditions, there may be a slight delay for the latest round to get onchain.

During periods of low volatility, the heartbeat triggers updates to the latest answer. Some heartbeats are configured to last several hours, so your application should check the timestamp and verify that the latest answer is recent enough for your application.

Users should build applications with the understanding that data feeds for wrapped or liquid staking assets might have different heartbeat and deviation thresholds than that of the underlying asset. Heartbeat and deviation thresholds can also differ for the same asset across different blockchains. Combining data from multiple feeds, even those with a common denominator, might result in a margin of error that users must account for in their risk mitigation practices.

To learn more about the heartbeat and deviation threshold, read the Decentralized Data Model page.

================================================================================

# Data Feeds API Reference

Source: https://docs.chain.link/data-feeds/api-reference
Extraction Method: playwright
Components: code_block(22), table(3)

# Data Feeds API Reference
When you use data feeds, retrieve the feeds through the AggregatorV3Interface and the proxy address. Optionally, you can call variables and functions in the AccessControlledOffchainAggregator contract to get information about the aggregator behind the proxy.

## AggregatorV3Interface
Import this interface to your contract and use it to run functions in the proxy contract. Create the interface object by pointing to the proxy address. For example, on Sepolia you could create the interface object in the constructor of your contract using the following example:

[Image: copy to clipboard]
```solidity
/**
 * Network: Sepolia
 * Data Feed: ETH/USD
 * Address: 0x694AA1769357215DE4FAC081bf1f309aDC325306
 */
constructor() {
  priceFeed = AggregatorV3Interface(0x694AA1769357215DE4FAC081bf1f309aDC325306);
}
```

To see examples for how to use this interface, read the Using Data Feeds guide.

You can see the code for the AggregatorV3Interface contract on GitHub.

### Functions in AggregatorV3Interface

Name | Description
--- | ---
decimals | The number of decimals in the response.
description | The description of the aggregator that the proxy points to.
getRoundData | Get data from a specific round.
latestRoundData | Get data from the latest round.
version | The version representing the type of aggregator the proxy points to.

#### decimals
Get the number of decimals present in the response value.

[Image: copy to clipboard]
```solidity
function decimals() external view returns (uint8);
```

• RETURN: The number of decimals.

#### description
Get the description of the underlying aggregator that the proxy points to.

[Image: copy to clipboard]
```solidity
function description() external view returns (string memory);
```

• RETURN: The description of the underlying aggregator.

#### getRoundData
Get data about a specific round, using the roundId.

[Image: copy to clipboard]
```solidity
function getRoundData(
  uint80 _roundId
) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);
```

Parameters:

• _roundId: The round ID

Return values:

• roundId: The round ID
• answer: The answer for this round
• startedAt: Timestamp of when the round started
• updatedAt: Timestamp of when the round was updated
• answeredInRound:     Deprecated - Previously used when answers could take multiple rounds to be computed

#### latestRoundData
Get the data from the latest round.

[Image: copy to clipboard]
```solidity
function latestRoundData() external view
    returns (
        uint80 roundId,
        int256 answer,
        uint256 startedAt,
        uint256 updatedAt,
        uint80 answeredInRound
    )
```

Return values:

• roundId: The round ID.
• answer: The data that this specific feed provides. Depending on the feed you selected, this answer provides asset prices, reserves, and other types of data.
• startedAt: Timestamp of when the round started.
• updatedAt: Timestamp of when the round was updated.
• answeredInRound:     Deprecated - Previously used when answers could take multiple rounds to be computed

#### version
The version representing the type of aggregator the proxy points to.

[Image: copy to clipboard]
```solidity
function version() external view returns (uint256)
```

• RETURN: The version number.

## AccessControlledOffchainAggregator
This is the contract for the aggregator. You can call functions on the aggregator directly, but it is a best practice to use the AggregatorV3Interface to run functions on the proxy instead so that changes to the aggregator do not affect your application. Read the aggregator contract only if you need functions that are not available in the proxy.

The aggregator contract has several variables and functions that might be useful for your application. Although aggregator contracts are similar for each data feed, some aggregators have different variables. Use the typeAndVersion() function on the aggregator to identify what type of aggregator it is and what version it is running.

Always check the contract source code and configuration to understand how specific data feeds operate. For example, the aggregator contract for BTC/USD on Arbitrum is different from the aggregators on other networks.

For examples of the contracts that are typically used in aggregator deployments, see the libocr repository on GitHub.

### Variables and functions in AccessControlledOffchainAggregator
This contract imports OffchainAggregator and SimpleReadAccessController, which also include their own imports. The variables and functions lists include the publicly accessible items from these imported contracts.

A simple way to read the variables or functions is to get the ABI from a blockchain explorer and point the ABI to the aggregator address. To do this in Remix, follow the Using the ABI with AtAddress guide in the Remix documentation. As an example, you can find the ABI for the BTC/USD aggregator by viewing the contract code in Etherscan.

Variables:

Name | Description
--- | ---
LINK | The address for the LINK token contract on a specific network.
billingAccessController | The address for the billingAccessController, which limits access to the billing configuration for the aggregator.
checkEnabled | A boolean that indicates if access is limited to addresses on the internal access list.
maxAnswer | This value is no longer used on most Data Feeds. Evaluate if your use case for Data Feeds requires a custom circuit breaker and implement it to meet the needs of your application. See the Risk Mitigation page for more information.
minAnswer | This value is no longer used on most Data Feeds. Evaluate if your use case for Data Feeds requires a custom circuit breaker and implement it to meet the needs of your application. See the Risk Mitigation page for more information.
owner | The address that owns this aggregator contract. This controls which address can execute specific functions.

Functions:

Name | Description
--- | ---
decimals | Return the number of digits of precision for the stored answer. Answers are stored in fixed-point format.
description | Return a description for this data feed. This is different depending on which feed you select.
getAnswer | Deprecated - Do not use this function.
getBilling | Retrieve the current billing configuration.
getRoundData | Get the full information for a specific aggregator round including the answer and update timestamps. Use this to get the full historical data for a round.
getTimestamp | Deprecated - Do not use this function.
hasAccess | Check if an address has internal access.
latestAnswer | Deprecated - Do not use this function.
latestConfigDetails | Return information about the current offchain reporting protocol configuration.
latestRound | Deprecated - Do not use this function.
latestRoundData | Get the full information for the most recent round including the answer and update timestamps.
latestTimestamp | Deprecated - Do not use this function.
latestTransmissionDetails | Get information about the most recent answer.
linkAvailableForPayment | Get the amount of LINK on this contract that is available to make payments to oracles. This value can be negative if there are outstanding payment obligations.
oracleObservationCount | Returns the number of observations that oracle is due to be reimbursed for.
owedPayment | Returns how much LINK an oracle is owed for its observations.
requesterAccessController | Returns the address for the access controller contract.
transmitters | The oracle addresses that can report answers to this aggregator.
typeAndVersion | Returns the aggregator type and version. Many aggregators are AccessControlledOffchainAggregator 3.0.0, but there are other variants in production. The version is for the type of aggregator, and different from the contract version.
validatorConfig | Returns the address and the gas limit for the validator contract.
version | Returns the contract version. This is different from the typeAndVersion for the aggregator.

#### decimals
Return the number of digits of precision for the stored answer. Answers are stored in fixed-point format.

[Image: copy to clipboard]
```solidity
function decimals() external view returns (uint8 decimalPlaces);
```

#### description
Return a description for this data feed. Usually this is an asset pair for a price feed.

[Image: copy to clipboard]
```solidity
function description() public view override checkAccess returns (string memory) {
  return super.description();
}
```

#### getAnswer
[Image: caution]This function is deprecated. Do not use this function.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
#### getBilling
Retrieve the current billing configuration.

[Image: copy to clipboard]
```solidity
function getBilling()
  external
  view
  returns (
    uint32 maximumGasPrice,
    uint32 reasonableGasPrice,
    uint32 microLinkPerEth,
    uint32 linkGweiPerObservation,
    uint32 linkGweiPerTransmission
  )
{
  Billing memory billing = s_billing;
  return (
    billing.maximumGasPrice,
    billing.reasonableGasPrice,
    billing.microLinkPerEth,
    billing.linkGweiPerObservation,
    billing.linkGweiPerTransmission
  );
}
```

#### getRoundData
Get the full information for a specific aggregator round including the answer and update timestamps. Use this to get the full historical data for a round.

[Image: copy to clipboard]
```solidity
function getRoundData(
  uint80 _roundId
)
  public
  view
  override
  checkAccess
  returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)
{
  return super.getRoundData(_roundId);
}
```

#### getTimestamp
[Image: caution]This function is deprecated. Do not use this function.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
#### hasAccess
Check if an address has internal access.

[Image: copy to clipboard]
```solidity
function hasAccess(address _user, bytes memory _calldata) public view virtual override returns (bool) {
  return super.hasAccess(_user, _calldata) || _user == tx.origin;
}
```

#### latestAnswer
[Image: caution]This function is deprecated. Do not use this function.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
#### latestConfigDetails
Return information about the current offchain reporting protocol configuration.

[Image: copy to clipboard]
```solidity
function latestConfigDetails() external view returns (uint32 configCount, uint32 blockNumber, bytes16 configDigest) {
  return (s_configCount, s_latestConfigBlockNumber, s_hotVars.latestConfigDigest);
}
```

#### latestRound
[Image: caution]This function is deprecated. Do not use this function.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
#### latestRoundData
Get the full information for the most recent round including the answer and update timestamps.

[Image: copy to clipboard]
```solidity
function latestRoundData()
  public
  view
  override
  checkAccess
  returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)
{
  return super.latestRoundData();
}
```

#### latestTimestamp
[Image: caution]This function is deprecated. Do not use this function.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
#### latestTransmissionDetails
Get information about the most recent answer.

[Image: copy to clipboard]
```solidity
function latestTransmissionDetails()
  external
  view
  returns (bytes16 configDigest, uint32 epoch, uint8 round, int192 latestAnswer, uint64 latestTimestamp)
{
  require(msg.sender == tx.origin, "Only callable by EOA");
  return (
    s_hotVars.latestConfigDigest,
    uint32(s_hotVars.latestEpochAndRound >> 8),
    uint8(s_hotVars.latestEpochAndRound),
    s_transmissions[s_hotVars.latestAggregatorRoundId].answer,
    s_transmissions[s_hotVars.latestAggregatorRoundId].timestamp
  );
}
```

#### linkAvailableForPayment
Get the amount of LINK on this contract that is available to make payments to oracles. This value can be negative if there are outstanding payment obligations.

[Image: copy to clipboard]
```solidity
function linkAvailableForPayment() external view returns (int256 availableBalance) {
  // there are at most one billion LINK, so this cast is safe
  int256 balance = int256(LINK.balanceOf(address(this)));
  // according to the argument in the definition of totalLINKDue,
  // totalLINKDue is never greater than 2**172, so this cast is safe
  int256 due = int256(totalLINKDue());
  // safe from overflow according to above sizes
  return int256(balance) - int256(due);
}
```

#### oracleObservationCount
Returns the number of observations that oracle is due to be reimbursed for.

[Image: copy to clipboard]
```solidity
function oracleObservationCount(address _signerOrTransmitter) external view returns (uint16) {
  Oracle memory oracle = s_oracles[_signerOrTransmitter];
  if (oracle.role == Role.Unset) {
    return 0;
  }
  return s_oracleObservationsCounts[oracle.index] - 1;
}
```

#### owedPayment
Returns how much LINK an oracle is owed for its observations.

[Image: copy to clipboard]
```solidity
function owedPayment(address _transmitter) public view returns (uint256) {
  Oracle memory oracle = s_oracles[_transmitter];
  if (oracle.role == Role.Unset) {
    return 0;
  }
  Billing memory billing = s_billing;
  uint256 linkWeiAmount = uint256(s_oracleObservationsCounts[oracle.index] - 1) *
    uint256(billing.linkGweiPerObservation) *
    (1 gwei);
  linkWeiAmount += s_gasReimbursementsLinkWei[oracle.index] - 1;
  return linkWeiAmount;
}
```

#### requesterAccessController
Returns the address for the access controller contract.

[Image: copy to clipboard]
```solidity
function requesterAccessController() external view returns (AccessControllerInterface) {
  return s_requesterAccessController;
}
```

#### transmitters
The oracle addresses that can report answers to this aggregator.

[Image: copy to clipboard]
```solidity
function transmitters() external view returns (address[] memory) {
  return s_transmitters;
}
```

#### typeAndVersion
Returns the aggregator type and version. Many aggregators are AccessControlledOffchainAggregator 2.0.0, but there are other variants in production. The version is for the type of aggregator, and different from the contract version.

[Image: copy to clipboard]
```solidity
function typeAndVersion() external pure virtual override returns (string memory) {
  return "AccessControlledOffchainAggregator 2.0.0";
}
```

#### validatorConfig
Returns the address and the gas limit for the validator contract.

[Image: copy to clipboard]
```solidity
function validatorConfig() external view returns (AggregatorValidatorInterface validator, uint32 gasLimit) {
  ValidatorConfig memory vc = s_validatorConfig;
  return (vc.validator, vc.gasLimit);
}
```

#### version
Returns the contract version. This is different from the typeAndVersion for the aggregator.

[Image: copy to clipboard]
```solidity
function version() external view returns (uint256);
```

================================================================================

# Developer Responsibilities: Market Integrity and Application Code Risks

Source: https://docs.chain.link/data-feeds/developer-responsibilities
Extraction Method: playwright

# Developer Responsibilities: Market Integrity and Application Code Risks
Chainlink Data Feeds provide access to highly secure, reliable, and decentralized real-world data published onchain. The assets priced by Chainlink Data Feeds are subject to market conditions beyond the ability of Chainlink node operators to control, as such developers are responsible for ensuring that the operation and performance of Chainlink Data Feeds match expectations.

When integrating Chainlink Data Feeds, developers must understand that the performance of feeds is subject to risks associated with both market integrity and application code.

• Market Integrity Risks are those associated with external market conditions impacting price behavior and data quality in unanticipated ways. Developers are solely responsible for monitoring and mitigating any potential market integrity risks.
• Application Code Risks are those associated with the quality, reliability, and dependencies of the code on which an application operates. Developers are solely responsible for monitoring and mitigating any potential application code risks.

Please refer to this guide for additional information about market integrity risks and how developers can protect their applications.

## Developer Responsibilities
Developers are responsible for maintaining the security and user experience of their applications. They must also securely manage all interactions between their applications and third-party services.

In particular, developers implementing Chainlink Data Feeds in their code and applications are responsible for their application's market integrity and code risks that may cause unanticipated pricing data behavior. These are described below in more detail.

### Market Integrity Risks
Market conditions can impact the pricing behavior of assets in ways beyond the ability of Chainlink node operators to predict or control.

Market integrity risk factors can include but are not limited to, market manipulation such as Spoofing, Ramping, Bear Raids, Cross-Market Manipulation, Washtrading, and Frontrunning. All assets are susceptible to market risk, but in particular, assets with high market risk, such as those with low liquidity, are the most vulnerable to market manipulation. Developers are solely responsible for accounting for such risk factors when integrating Chainlink Data Feeds into their applications. Developers should understand the market risks around the assets they intend their application to support before integrating associated Chainlink Data Feeds and inform their end users about applicable market risks.

Developers should reference the following additional information when implementing Chainlink Data Feeds:

• Data Feed Categories to evaluate market integrity risks associated with specific Chainlink Data Feeds Developers intend to integrate.
• Evaluating Data Source Risks to evaluate risk mitigation techniques associated with Chainlink Data Feeds broadly.

### Application Code Risks
Developers implementing Chainlink Data Feeds are solely responsible for instituting the requisite risk mitigation processes including, but not limited to, data quality checks, circuit breakers, and appropriate contingency logic for their use case.

• Code quality and reliability: Developers must execute code using Chainlink Data Feeds only if the code meets the quality and reliability requirements for their use case and application.
• Code and application audits: Developers are responsible for auditing their code and applications before deploying to production. Developers must determine the quality of any audits and ensure that they meet the requirements for their application.
• Code dependencies and imports: Developers are responsible for ensuring the quality, reliability, and security of any dependencies or imported packages that they use with Chainlink Data Feeds, and review and audit these dependencies and packages.

astro-island,astro-slot,astro-static-slot{display:contents}(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).only=e;window.dispatchEvent(new Event("astro:only"));})();(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();

================================================================================

# Consuming Data Feeds

Source: https://docs.chain.link/data-feeds/getting-started
Extraction Method: playwright
Components: code_block(1)

# Consuming Data Feeds
You can use Chainlink Data Feeds to connect your smart contracts to asset pricing data like the ETH / USD feed. These data feeds use data aggregated from many independent Chainlink node operators. Each price feed has an onchain address and functions that enable contracts to read pricing data from that address.

This guide shows you how to read Data Feeds and store the value onchain using Solidity. To learn how to read feeds offchain or use different languages, see the Using Data Feeds on EVM Chains guide. Alternatively, you can also learn how to use Data Feeds on Solana or StarkNet.

The code for reading Data Feeds on Ethereum or other EVM-compatible blockchains is the same for each chain and each Data Feed types. You choose different types of feeds for different uses, but the request and response format are the same. The answer decimal length and expected value ranges might change depending on what feed you use.

[Image: caution]Using Data Feeds on L2 networks

If you are using Chainlink Data Feeds on L2 networks like Arbitrum, OP, and Metis, you must also check the latest
answer from the L2 Sequencer Uptime Feed to ensure that the data is accurate in the event of an L2 sequencer outage.
See the L2 Sequencer Uptime Feeds page to learn how to use Data Feeds on L2
networks.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
## Before you begin
If you are new to smart contract development, learn how to Deploy Your First Smart Contract before you start this guide.

## Examine the sample contract
This example contract obtains the latest price answer from the BTC / USD feed on the Sepolia testnet, but you can modify it to read any of the different Types of Data Feeds.

[Image: copy to clipboard]
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import {AggregatorV3Interface} from "@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol";

/**
 * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED
 * VALUES FOR CLARITY.
 * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

/**
 * If you are reading data feeds on L2 networks, you must
 * check the latest answer from the L2 Sequencer Uptime
 * Feed to ensure that the data is accurate in the event
 * of an L2 sequencer outage. See the
 * https://docs.chain.link/data-feeds/l2-sequencer-feeds
 * page for details.
 */

contract DataConsumerV3 {
    AggregatorV3Interface internal dataFeed;

    /**
     * Network: Sepolia
     * Aggregator: BTC/USD
     * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
     */
    constructor() {
        dataFeed = AggregatorV3Interface(
            0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
        );
    }

    /**
     * Returns the latest answer.
     */
    function getChainlinkDataFeedLatestAnswer() public view returns (int) {
        // prettier-ignore
        (
            /* uint80 roundId */,
            int256 answer,
            /*uint256 startedAt*/,
            /*uint256 updatedAt*/,
            /*uint80 answeredInRound*/
        ) = dataFeed.latestRoundData();
        return answer;
    }
}
```

[Open in Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/DataFeeds/DataConsumerV3.sol&autoCompile=true)[What is Remix?](/getting-started/conceptual-overview#what-is-remix)The contract has the following components:

• The import line imports an interface named AggregatorV3Interface. Interfaces define functions without their implementation, which leaves inheriting contracts to define the actual implementation themselves. In this case, AggregatorV3Interface defines that all v3 Aggregators have the function latestRoundData. You can see the complete code for the AggregatorV3Interface on GitHub.
• The constructor() {} initializes an interface object named dataFeed that uses AggregatorV3Interface and connects specifically to a proxy aggregator contract that is already deployed at 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43. The interface allows your contract to run functions on that deployed aggregator contract.
• The getChainlinkDataFeedLatestAnswer() function calls your dataFeed object and runs the latestRoundData() function. When you deploy the contract, it initializes the dataFeed object to point to the aggregator at 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43, which is the proxy address for the Sepolia BTC / USD data feed. Your contract connects to that address and executes the function. The aggregator connects with several oracle nodes and aggregates the pricing data from those nodes. The response from the aggregator includes several variables, but getChainlinkDataFeedLatestAnswer() returns only the answer variable.

## Compile, deploy, and run the contract
[Image: caution]Configure and fund your wallet

If you have not already configured your MetaMask wallet and funded it with testnet ETH, follow the instructions in Deploy Your First Smart Contract to set that up. You can get testnet ETH at one of the available Sepolia faucets.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }Deploy the DataConsumerV3 smart contract on the Sepolia testnet.

1. Open the example contract in Remix. Remix opens and shows the contents of the smart contract.
Open the contract in Remix
2. Because the code is already written, you can start the compile step. On the left side of Remix, click the Solidity Compiler tab to view the compiler settings.
3. Use the default compiler settings. Click the Compile DataConsumerV3.sol button to compile the contract. Remix automatically detects the correct compiler version depending on the pragma that you specify in the contract. You can ignore warnings about unused local variables in this example.
4. On the Deploy tab, select the Injected Provider environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.
5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the Contract section, select the DataConsumerV3 contract to make sure that Remix deploys the correct contract.
6. Click Deploy to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.
7. In the MetaMask prompt, click Confirm to approve the transaction and spend your testnet ETH required to deploy the contract.
8. After a few seconds, the transaction completes and your contract appears under the Deployed Contracts list in Remix. Click the contract dropdown to view its variables and functions.
9. Click getChainlinkDataFeedLatestAnswer to show the latest answer from the aggregator contract. In this example, the answer is the latest price, which appears just below the button. The returned answer is an integer, so it is missing its decimal point. You can find the correct number of decimal places for this answer on the Price Feed addresses page by clicking the Show more details checkbox. The answer on the BTC / USD feed uses 8 decimal places, so an answer of 3030914000000 indicates a BTC / USD price of 30309.14. Each feed uses a different number of decimal places for answers.

================================================================================

# Getting Historical Data

Source: https://docs.chain.link/data-feeds/historical-data
Extraction Method: playwright
Components: code_block(6), table(1)

# Getting Historical Data
The most common use case for Data Feeds is to Get the Latest Data from a feed. However, the AggregatorV3Interface.sol also has functions to retrieve data of a previous round IDs.

There are two parameters that can cause Chainlink nodes to update:

Name | Description
--- | ---
Deviation Threshold | Chainlink nodes are monitoring data offchain. The deviation of the real-world data beyond a certain interval triggers all the nodes to update.
Heartbeat Threshold | If the data values stay within the deviation parameters, it will only trigger an update every X minutes / hours.

You can find these parameters at data.chain.link on an example like ETH / USD.

To learn how data feeds update, see the Decentralized Data Model page.

## Historical rounds
As shown in the decentralized model, the consumer contracts call the proxy contract, which abstracts the underlying aggregator contract. The main advantage is to enable upgrades of the aggregator without impacting the consumer contracts. That also means that historical data can can be stored in different aggregators.

As shown in the following sequence diagram, to get historical data, call the getRoundData function and provide roundId as a parameter.

astro-island,astro-slot,astro-static-slot{display:contents}(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).only=e;window.dispatchEvent(new Event("astro:only"));})();(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();Note that roundIds have different meanings in proxy contracts and in aggregator contracts.

### roundId in Aggregator (aggregatorRoundId)
Oracles provide periodic data updates to the aggregators. Data feeds are updated in rounds. Rounds are identified by their roundId, which increases with each new round. This increase may not be monotonic. Knowing the roundId of a previous round allows contracts to consume historical data.

The examples in this document name the aggregator roundId as aggregatorRoundId to differentiate it from the proxy roundId.

### roundId in proxy
Because a proxy has references to current and all previous underlying aggregators, it needs a way to fetch data from the correct aggregator. The roundId is computed in the proxy contract as shown in the following example:

[Image: copy to clipboard]
```solidity
return uint80(uint256(_phase) << PHASE_OFFSET | _originalId);
```

where:

• _phase is incremented each time the underlying aggregator implementation is updated. It is used as a key to find the aggregator address.
• _originalId is the aggregator roundId. The ID starts at 1.

From the above formula, you can think of it as returning a large number containing the phase and the aggregator roundId.

[Image: note]Note

The example formula above ensures that no matter how many times the underlying aggregator changes, the proxy roundId
will always increase.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }Example:

When you query historical data, it is important to know when you reach the end of the history of the underlying aggregator. As an example, if the latestRoundData function of the LINK / USD Price Feed on Ethereum Mainnet returns roundId = 92233720368547771158, you can use this value to compute the phaseId and aggregatorRoundId:

• phaseId = 92233720368547771158 >> 64: Right shifting an integer by 64 bits is equivalent to dividing it by 2^64: phaseId = 92233720368547771158/ 2^64 = 5. The current phase id is 5 , which means that this proxy has had 5 underlying aggregators since its initial deployment.
• aggregatorRoundId = uint64(92233720368547771158): This retrieves the first 64 bits from the right. To calculate this offchain, you can use the following JavaScript example:

[Image: copy to clipboard]
```javascript
// First parse to BigInt to perform computation with big integers
const num = BigInt("92233720368547771158")
const num2 = BigInt("0xFFFFFFFFFFFFFFFF") // Largest 64bits integer

console.log(Number(num >> 64n)) // returns 5 (phaseId)
console.log(Number(num & num2)) // returns 13078 (aggregatorRoundId) . Use & (AND bitwise operator) which sets each bit to _1_ if both bits are _1_
```

Using 13078 as the current aggregator's round, get its historical data by looping over the getRoundData function:

• Start from the first round: 92233720368547758081 (result of 92233720368547771158 - 13078 + 1)
• Continue until the current round: 92233720368547771158

To get the historical data for previous aggregators, decrement the phaseId and start from round 1. For phase 4, get the starting roundId offchain using the following JavaScript example:

[Image: copy to clipboard]
```javascript
const phaseId = BigInt("4")
const aggregatorRoundId = BigInt("1")

roundId = (phaseId << 64n) | aggregatorRoundId // returns 73786976294838206465n
```

Loop over the getRoundData function. Start at 73786976294838206465 and increment it until you get a revert. This means that you reached the last round for the underlying aggregator. The same process could be repeated for previous phaseIds (3,2,1).

[Image: caution]Looping onchain

The examples showed how to loop offchain to fetch all historical data from a given proxy. You could also write a
similar code onchain, but be aware that this could cause very high gas prices if a state is changed within the
same function.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
### getRoundData return values
The getRoundData function returns the following values:

• roundId: The round in which the answer was updated
• answer: The answer reflects the data recorded for the specified round
• answeredInRound:     Deprecated - Previously used when answers could take multiple rounds to be computed
• startedAt: The timestamp when the round started
• updatedAt: The timestamp when the answer was computed

### Solidity
[Image: copy to clipboard]
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import {AggregatorV3Interface} from "@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol";

/**
 * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
 * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

contract HistoricalDataConsumerV3 {
    AggregatorV3Interface internal dataFeed;

    /**
     * Network: Sepolia
     * Aggregator: ETH/USD
     * Address:	0x694AA1769357215DE4FAC081bf1f309aDC325306
     */
    constructor() {
        dataFeed = AggregatorV3Interface(
            0x694AA1769357215DE4FAC081bf1f309aDC325306
        );
    }

    /**
     * Returns historical data for a round ID.
     * roundId is NOT incremental. Not all roundIds are valid.
     * You must know a valid roundId before consuming historical data.
     *
     * ROUNDID VALUES:
     *    InValid:      18446744073709562300
     *    Valid:        18446744073709554683
     *
     * @dev A timestamp with zero value means the round is not complete and should not be used.
     */
    function getHistoricalData(uint80 roundId) public view returns (int256) {
        // prettier-ignore
        (
            /*uint80 roundID*/,
            int answer,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) = dataFeed.getRoundData(roundId);
        return answer;
    }
}
```

[Open in Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/DataFeeds/HistoricalDataConsumer.sol&autoCompile=true)[What is Remix?](/getting-started/conceptual-overview#what-is-remix)
### Javascript
[Image: copy to clipboard]
```solidity
/**
 * THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
 * THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

const Web3 = require("web3") // for nodejs only
// Replace the provider URL with your own endpoint URL
const web3 = new Web3("https://rpc.ankr.com/eth_sepolia")
const aggregatorV3InterfaceABI = [
  {
    inputs: [],
    name: "decimals",
    outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "description",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [{ internalType: "uint80", name: "_roundId", type: "uint80" }],
    name: "getRoundData",
    outputs: [
      { internalType: "uint80", name: "roundId", type: "uint80" },
      { internalType: "int256", name: "answer", type: "int256" },
      { internalType: "uint256", name: "startedAt", type: "uint256" },
      { internalType: "uint256", name: "updatedAt", type: "uint256" },
      { internalType: "uint80", name: "answeredInRound", type: "uint80" },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "latestRoundData",
    outputs: [
      { internalType: "uint80", name: "roundId", type: "uint80" },
      { internalType: "int256", name: "answer", type: "int256" },
      { internalType: "uint256", name: "startedAt", type: "uint256" },
      { internalType: "uint256", name: "updatedAt", type: "uint256" },
      { internalType: "uint80", name: "answeredInRound", type: "uint80" },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "version",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function",
  },
]
const addr = "0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43"
const dataFeed = new web3.eth.Contract(aggregatorV3InterfaceABI, addr)

// Valid roundId must be known. They are NOT incremental.
let validId = BigInt("18446744073709554177")
dataFeed.methods
  .getRoundData(validId)
  .call()
  .then((historicalRoundData) => {
    document.getElementById("get-data-field").value = historicalRoundData.answer
  })
```

(()=>{var l=(n,t)=>{let i=async()=>{await(await n())()},e=typeof t.value=="object"?t.value:void 0,s={timeout:e==null?void 0:e.timeout};"requestIdleCallback"in window?window.requestIdleCallback(i,s):setTimeout(i,s.timeout||200)};(self.Astro||(self.Astro={})).idle=l;window.dispatchEvent(new Event("astro:idle"));})();Round 18446744073709551978:Historical Price

### Python
[Image: copy to clipboard]
```solidity
# THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
# THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
# DO NOT USE THIS CODE IN PRODUCTION.

from web3 import Web3

# Change this to use your own RPC URL
web3 = Web3(Web3.HTTPProvider('https://rpc.ankr.com/eth_sepolia'))
# AggregatorV3Interface ABI
abi = '[{"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"description","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint80","name":"_roundId","type":"uint80"}],"name":"getRoundData","outputs":[{"internalType":"uint80","name":"roundId","type":"uint80"},{"internalType":"int256","name":"answer","type":"int256"},{"internalType":"uint256","name":"startedAt","type":"uint256"},{"internalType":"uint256","name":"updatedAt","type":"uint256"},{"internalType":"uint80","name":"answeredInRound","type":"uint80"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"latestRoundData","outputs":[{"internalType":"uint80","name":"roundId","type":"uint80"},{"internalType":"int256","name":"answer","type":"int256"},{"internalType":"uint256","name":"startedAt","type":"uint256"},{"internalType":"uint256","name":"updatedAt","type":"uint256"},{"internalType":"uint80","name":"answeredInRound","type":"uint80"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"version","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}]'
# Feed address
addr = '0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43'

# Set up contract instance
contract = web3.eth.contract(address=addr, abi=abi)

#  Valid roundId must be known. They are NOT incremental.
# invalidRoundId = 18446744073709562300
validRoundId = 18446744073709554177

historicalData = contract.functions.getRoundData(validRoundId).call()
print(historicalData)
```

================================================================================

# L2 Sequencer Uptime Feeds

Source: https://docs.chain.link/data-feeds/l2-sequencer-feeds
Extraction Method: playwright
Components: code_block(1)

# L2 Sequencer Uptime Feeds
Optimistic rollups (e.g., Arbitrum, Optimism) and many ZK-rollups rely on sequencers to efficiently manage transaction ordering, execution, and batching before submitting them to Layer 1 (L1) blockchains like Ethereum. The sequencer plays a crucial role in optimizing transaction throughput, reducing fees, and ensuring fast transaction confirmations on L2 networks, making it a key component of their scalability and performance.

However, if the sequencer becomes unavailable, users will lose access to the standard read/write APIs, preventing them from interacting with applications on the L2 network. Although the L2 chain's security and state commitments remain enforced by Layer 1, no new batched blocks will be produced by the sequencer. Users with sufficient technical expertise can still interact directly with the network through the underlying rollup contracts on L1. However, this process is more complex and costly, creating an unfair advantage for those who can bypass the sequencer. This imbalance in access can lead to disruptions or distortions in applications, such as liquidations or market operations that rely on timely transactions.

To mitigate these risks, your applications can integrate a Sequencer Uptime Data Feed, which continuously monitors and records the last known status of the sequencer. By utilizing this feed, you can:

• Detect sequencer downtime in real time.
• Implement a grace period to prevent mass liquidations or unexpected disruptions.
• Ensure fair access to services by temporarily pausing operations during sequencer failures.

This proactive approach enhances the resilience and fairness of applications operating on L2 networks, ensuring a more stable and equitable user experience.

## Supported Networks
You can find proxy addresses for the L2 sequencer feeds at the following addresses:

### Arbitrum
Arbitrum Mainnet: 0xFdB631F5EE196F0ed6FAa767959853A9F217697D

### BASE
BASE Mainnet: 0xBCF85224fc0756B9Fa45aA7892530B47e10b6433

### Celo
Celo Mainnet: 0x4CD491Dc27C8B0BbD10D516A502856B786939d18

### Mantle
Mantle Mainnet: 0xaDE1b9AbB98c6A542E4B49db2588a3Ec4bF7Cdf0

### Metis
Andromeda Mainnet: 0x58218ea7422255EBE94e56b504035a784b7AA204

### OP
OP Mainnet: 0x371EAD81c9102C9BF4874A9075FFFf170F2Ee389

### Scroll
Scroll Mainnet: 0x45c2b8C204568A03Dc7A2E32B71D67Fe97F908A9

### Soneium
Soneium Mainnet: 0xaDE1b9AbB98c6A542E4B49db2588a3Ec4bF7Cdf0

### ZKsync
zkSync Mainnet: 0x0E6AC8B967393dcD3D36677c126976157F993940

## Real-time Monitoring Process

### Arbitrum
The diagram below shows how these feeds update and how a consumer retrieves the status of the Arbitrum sequencer.

astro-island,astro-slot,astro-static-slot{display:contents}(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).only=e;window.dispatchEvent(new Event("astro:only"));})();(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();
1. Chainlink nodes trigger an OCR round every 30s and update the sequencer status by calling the validate function in the ArbitrumValidator contract by calling it through the ValidatorProxy contract.
2. The ArbitrumValidator checks to see if the latest update is different from the previous update. If it detects a difference, it places a message in the Arbitrum inbox contract.
3. The inbox contract sends the message to the ArbitrumSequencerUptimeFeed contract. The message calls the updateStatus function in the ArbitrumSequencerUptimeFeed contract and updates the latest sequencer status to 0 if the sequencer is up and 1 if it is down. It also records the block timestamp to indicate when the message was sent from the L1 network.
4. A consumer contract on the L2 network can read these values from the ArbitrumUptimeFeedProxy contract, which reads values from the ArbitrumSequencerUptimeFeed contract.

#### Handling Arbitrum Outages
If the Arbitrum network becomes unavailable, the ArbitrumValidator contract continues to send messages to the L2 network through the delayed inbox on L1. This message stays there until the sequencer is back up again. When the sequencer comes back online after downtime, it processes all transactions from the delayed inbox before it accepts new transactions. The message that signals when the sequencer is down will be processed before any new messages with transactions that require the sequencer to be operational.

### Other Supported Networks
On BASE, Celo, Mantle, Metis, OP, Scroll, Soneium and zkSync, the sequencer's status is relayed from L1 to L2 where the consumer can retrieve it.

On the L1 network:

1. A network of node operators runs the external adapter to post the latest sequencer status to the AggregatorProxy contract and relays the status to the Aggregator contract. The Aggregator contract calls the validate function in the OptimismValidator contract.
2. The OptimismValidator contract calls the sendMessage function in the L1CrossDomainMessenger contract. This message contains instructions to call the updateStatus(bool status, uint64 timestamp) function in the sequencer uptime feed deployed on the L2 network.
3. The L1CrossDomainMessenger contract calls the enqueue function to enqueue a new message to the CanonicalTransactionChain.
4. The Sequencer processes the transaction enqueued in the CanonicalTransactionChain contract to send it to the L2 contract.

On the L2 network:

1. The Sequencer posts the message to the L2CrossDomainMessenger contract.
2. The L2CrossDomainMessenger contract relays the message to the OptimismSequencerUptimeFeed contract.
3. The message relayed by the L2CrossDomainMessenger contains instructions to call updateStatus in the OptimismSequencerUptimeFeed contract.
4. Consumers can then read from the AggregatorProxy contract, which fetches the latest round data from the OptimismSequencerUptimeFeed contract.

#### Handling Other Supported Network Outages
If the sequencer is down, messages cannot be transmitted from L1 to L2 and no L2 transactions are executed. Instead, messages are enqueued in the CanonicalTransactionChain on L1 and only processed in the order they arrived later when the sequencer comes back up. As long as the message from the validator on L1 is already enqueued in the CTC, the flag on the sequencer uptime feed on L2 will be guaranteed to be flipped prior to any subsequent transactions. The transaction that flips the flag on the uptime feed will be executed before transactions that were enqueued after it. This is further explained in the diagrams below.

When the Sequencer is down, all L2 transactions sent from the L1 network wait in the pending queue.

1. Transaction 3 contains Chainlink’s transaction to set the status of the sequencer as being down on L2.
2. Transaction 4 is a transaction made by a consumer that is dependent on the sequencer status.

After the sequencer comes back up, it moves all transactions in the pending queue to the processed queue.

1. Transactions are processed in the order they arrived so Transaction 3 is processed before Transaction 4.
2. Because Transaction 3 happens before Transaction 4, Transaction 4 will read the status of the Sequencer as being down and responds accordingly.

## Example Consumer Contract
This example code works on any network that supports Solidity. Create the consumer contract for sequencer uptime feeds similarly to the contracts that you use for other Chainlink Data Feeds. Configure the constructor using the following variables:

• Configure the sequencerUptimeFeed object with the sequencer uptime feed proxy address for your L2 network.
• Configure the dataFeed object with one of the Data Feed proxy addresses that are available for your network.

[Image: copy to clipboard]
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import {AggregatorV2V3Interface} from "@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV2V3Interface.sol";

/**
 * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
 * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

contract DataConsumerWithSequencerCheck {
    AggregatorV2V3Interface internal dataFeed;
    AggregatorV2V3Interface internal sequencerUptimeFeed;

    uint256 private constant GRACE_PERIOD_TIME = 3600;

    error SequencerDown();
    error GracePeriodNotOver();

    /**
     * Network: OP Mainnet
     * Data Feed: BTC/USD
     * Data Feed address: 0xD702DD976Fb76Fffc2D3963D037dfDae5b04E593
     * Uptime Feed address: 0x371EAD81c9102C9BF4874A9075FFFf170F2Ee389
     * For a list of available Sequencer Uptime Feed proxy addresses, see:
     * https://docs.chain.link/docs/data-feeds/l2-sequencer-feeds
     */
    constructor() {
        dataFeed = AggregatorV2V3Interface(
            0xD702DD976Fb76Fffc2D3963D037dfDae5b04E593
        );
        sequencerUptimeFeed = AggregatorV2V3Interface(
            0x371EAD81c9102C9BF4874A9075FFFf170F2Ee389
        );
    }

    // Check the sequencer status and return the latest data
    function getChainlinkDataFeedLatestAnswer() public view returns (int) {
        // prettier-ignore
        (
            /*uint80 roundID*/,
            int256 answer,
            uint256 startedAt,
            /*uint256 updatedAt*/,
            /*uint80 answeredInRound*/
        ) = sequencerUptimeFeed.latestRoundData();

        // Answer == 0: Sequencer is up
        // Answer == 1: Sequencer is down
        bool isSequencerUp = answer == 0;
        if (!isSequencerUp) {
            revert SequencerDown();
        }

        // Make sure the grace period has passed after the
        // sequencer is back up.
        uint256 timeSinceUp = block.timestamp - startedAt;
        if (timeSinceUp <= GRACE_PERIOD_TIME) {
            revert GracePeriodNotOver();
        }

        // prettier-ignore
        (
            /*uint80 roundID*/,
            int data,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) = dataFeed.latestRoundData();

        return data;
    }
}
```

[Open in Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/DataFeeds/DataConsumerWithSequencerCheck.sol&autoCompile=true)[What is Remix?](/getting-started/conceptual-overview#what-is-remix)The sequencerUptimeFeed object returns the following values:

• answer: A variable with a value of either 0 or 1

0: The sequencer is up
1: The sequencer is down
• startedAt: This timestamp indicates when the sequencer feed changed status. When the sequencer comes back up after an outage, wait for the GRACE_PERIOD_TIME to pass before accepting answers from the data feed. Subtract startedAt from block.timestamp and revert the request if the result is less than the GRACE_PERIOD_TIME.

The startedAt variable returns 0 only on Arbitrum when the Sequencer Uptime contract is not yet initialized. For L2 chains other than Arbitrum, startedAt is set to block.timestamp on construction and startedAt is never 0. After the feed begins rounds, the startedAt timestamp will always indicate when the sequencer feed last changed status.

If the sequencer is up and the GRACE_PERIOD_TIME has passed, the function retrieves the latest answer from the data feed using the dataFeed object.

================================================================================

# Price Feeds

Source: https://docs.chain.link/data-feeds/price-feeds
Extraction Method: playwright

# Price Feeds
Chainlink Data Feeds provide data that is aggregated from many data sources by a decentralized set of independent node operators. The Decentralized Data Model describes this in detail. However, there are some exceptions where data for a feed can come only from a single data source or where data values are calculated. Read the Selecting Quality Data Feeds to learn about the different data feed categories and how to identify them.

================================================================================

# Price Feed Contract Addresses

Source: https://docs.chain.link/data-feeds/price-feeds/addresses
Extraction Method: playwright
Components: table(2)

# Price Feed Contract Addresses
To learn how to use these feeds, see the Using Data Feeds guide.

For LINK token and Faucet details, see the LINK Token Contracts page.

[Image: note]Talk to an expert

Contact us to talk to an expert about integrating
              Chainlink Data Feeds with your applications.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
### Data Feed Best Practices
Before you use Data Feeds, read and understand the best practices on the Selecting Quality Data Feeds page. For best practices about data for specific asset types, see the following sections:

• Best Practices for ETF and Forex feeds
• Best Practices for Exchange Rate Feeds
• Risk Categories

[Image: caution]caution

Please be careful with the feeds used by your smart contracts. The feeds listed in our official documentation
          have been reviewed; feeds built for custom deployments by other community members might have additional risks.
          Please do close diligence on your feeds before implementing them in your contracts.  Learn more about making responsible data quality decisions.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
## Networks
AptosArbitrumAvalancheBaseBNB ChainBOBBotanixCeloEthereumFantomGnosis Chain (xDai)HederaKatanaLineaMantleMetisMonadOPPolygonPolygon zkEVMPlasmaRoninScrollSoneiumSolanaSonicStarknetTRONUnichainX LayerZKsyncTrack the status of this network at https://ethstats.dev/

### Ethereum Mainnet
Data Feed Categories
• Low Market Risk
• Medium Market Risk
• High Market Risk
• New Token
• Custom
• Deprecating

Show more detailsShow Smart Value Recapture (SVR) feeds
Pair | Deviation | Heartbeat | Dec | Address and info
--- | --- | --- | --- | ---
🟡1INCH / ETH | 2% | 86400s | 18 | 0x72AFAECF99C9d9C8215fF44C77B94B99C28741e8Asset name:1inchAsset type:CryptoMarket hours:Crypto
🟡1INCH / USD | 1% | 86400s | 8 | 0xc929ad75B72593967DE83E7F7Cda0493458261D9Asset name:1inchAsset type:CryptoMarket hours:Crypto
🟡AAVE / ETH | 2% | 86400s | 18 | 0x6Df09E975c830ECae5bd4eD9d90f3A95a4f88012Asset name:AaveAsset type:CryptoMarket hours:Crypto
🟢AAVE / USDAave SVR | 1% | 3600s | 8 | Standard Proxy:0xbd7F896e60B650C01caf2d7279a1148189A68884Asset name:AaveAsset type:CryptoMarket hours:CryptoAAVE SVR Proxy:0xF02C1e2A3B77c1cacC72f72B44f7d0a4c62e4a85⚠️ Aave Dedicated Feed: This SVR proxy feed is dedicated exclusively for use by the Aave protocol. Learn more about Aave SVR Feeds.
🟢AAVE / USD | 1% | 3600s | 8 | 0x547a514d5e3769680Ce22B2361c10Ea13619e8a9Asset name:AaveAsset type:CryptoMarket hours:Crypto
🔵AMPL / USD | 1000% | 172800s | 18 | 0xe20CA8D7546932360e37E9D72c1a47334af57706Asset name:AmpleforthAsset type:CryptoMarket hours:Crypto
🟡APE / ETH | 2% | 86400s | 18 | 0xc7de7f4d4C9c991fF62a07D18b3E31e349833A18Asset name:APECoinAsset type:CryptoMarket hours:Crypto
🟡APE / USD | 2% | 86400s | 8 | 0xD10aBbC76679a20055E167BB80A24ac851b37056Asset name:APECoinAsset type:CryptoMarket hours:Crypto

PrevShowing 1 to 8 of 165 entries

Next
### Sepolia Testnet
Show more details
Pair | Deviation | Heartbeat | Dec | Address and info
--- | --- | --- | --- | ---
AUD / USD | 0.15% | 86400s | 8 | 0xB0C712f98daE15264c8E26132BCC91C40aD4d5F9
BTC / ETH | 1% | 3600s | 18 | 0x5fb1616F78dA7aFC9FF79e0371741a747D2a7F22
BTC / USD | 1% | 3600s | 8 | 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
BTC / USD | 1% | 900s | 8 | 0x38c8b98A2Cb36a55234323D7eCCD36ad3bFC5954
CASH NAV | 1e-7% | 97200s | 6 | 0xd988B5d6E40A38D87d85491Da1110D2de904E245
CSPX / USD | 2% | 86400s | 8 | 0x4b531A318B0e44B549F3b2f824721b3D0d51930A
CZK / USD | 0.5% | 86400s | 8 | 0xC32f0A9D70A34B9E7377C10FDAd88512596f61EA
DAI / USD | 1% | 86400s | 8 | 0x14866185B1962B63C3Ea9E03Bc1da838bab34C19

PrevShowing 1 to 8 of 37 entries

Next

================================================================================

# SmartData

Source: https://docs.chain.link/data-feeds/proof-of-reserve
Extraction Method: playwright
Components: code_block(1)

# SmartData
Chainlink SmartData is a suite of onchain data offerings designed to unlock the utility, accessibility, and reliability of tokenized real-world assets (RWAs). By providing secure minting assurances alongside essential real-world data such as reserves, Net Asset Value (NAV), and Assets Under Management (AUM) data, the SmartData suite embeds security and enriches data into tokenized RWA offerings.

## SmartData Feed Types
SmartData offers two distinct types of data feeds:

1. Single-value SmartData Feeds: Similar to traditional price feeds, these provide a single numeric value per feed (like total reserves or NAV). These use the AggregatorV3Interface and are read the same way as other Data Feeds.
2. Multiple-Variable Response (MVR) Feeds: These bundle multiple data points of various types (both numeric and non-numeric) into a single onchain update. MVR feeds use the BundleAggregatorProxy interface and require a different approach to read and decode the data.

## SmartData Product Categories

• Proof of Reserve Feeds
• NAVLink Feeds
• SmartAUM Feeds

### Proof of Reserve Feeds
Proof of Reserves feeds provide the status of reserves for stablecoins, wrapped assets, and real world assets. Proof of Reserve Feeds operate similarly to Price Feeds, but provide answers in units of measurement such as ounces (oz) or number of tokens.

To find a list of available Proof of Reserve Feeds, see the SmartData Feed Addresses page.

#### Types of Proof of Reserve Feeds
Reserves are available for both offchain assets and cross-chain assets. This categorization describes the data reporting variations of Proof of Reserve feeds and helps highlight some of the inherent market risks surrounding the data quality of these feeds.

##### Offchain reserves
Offchain reserves are sourced from APIs through an external adapter.

astro-island,astro-slot,astro-static-slot{display:contents}(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).only=e;window.dispatchEvent(new Event("astro:only"));})();(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();Offchain reserves provide their data using the following methods:

• Third-party: An auditor, accounting firm, or other third party audits and verifies reserves. This is done by combining both fiat and investment assets into a numeric value that is reported against the token.
• Custodian: Reserves data are pulled directly from the bank or custodian. The custodian has direct access to the bank or vault holding the assets. Generally, this works when the underlying asset pulled requires no additional valuation and is simply reported onchain.
• ⚠️ Self-reported: Reserve data is read from an API that the token issuer hosts. Reserve data reported by an asset issuer's self-hosted API carries additional risks. Chainlink Labs is not responsible for the accuracy of self-reported reserves data. Users must do their own risk assessment for asset issuer risk.

##### Cross-chain reserves
Cross-chain reserves are sourced from the network where the reserves are held. Chainlink node operators can report cross-chain reserves by running an external adapter and querying the source-chain client directly. In some instances, the reserves are composed of a dynamic list of IDs or addresses using a composite adapter.

Cross-chain reserves provide their data using the following methods:

• Wallet address manager: The project uses the IPoRAddressList wallet address manager contract and self-reports which addresses they own. Reserve data reported by an asset issuer's self-reported addresses carries additional risks. Chainlink Labs is not responsible for the accuracy of self-reported reserves data. Users must do their own risk assessment for asset issuer risk.
• Wallet address: The project reports which addresses they own through a self-hosted API. Reserve data reported by an asset issuer's self-reported addresses carries additional risks. Chainlink Labs is not responsible for the accuracy of self-reported reserves data. Users must do their own risk assessment for asset issuer risk.

[Image: caution]Disclaimer

Proof of Reserve feeds can vary in their configurations. Please be careful with the configuration of the feeds used
by your smart contracts. You are solely responsible for reviewing the quality of the data (e.g., a Proof of Reserve
feed) that you integrate into your smart contracts and assume full responsibility for any damage, injury, or any
other loss caused by your use of the feeds used by your smart contracts.

[Learn more about making responsible data quality decisions.](/data-feeds/selecting-data-feeds#risk-mitigation).asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
### NAVLink Feeds
Chainlink NAVLink Feeds provide real-time, tamper-proof data on the Net Asset Value (NAV) of tokenized assets, funds, or portfolios. NAV is an essential metric in the financial industry for assessing the value of mutual funds, ETFs, and other investment vehicles. It is calculated by subtracting total liabilities from the total assets held within the vehicle.

By making NAV data available onchain, developers can build decentralized applications that require accurate and up-to-date valuation metrics. These applications include asset management platforms, DeFi protocols, and investment strategies that rely on NAV for operations such as rebalancing, minting, or redemption.

To find a list of available SmartNav Feeds, see the SmartData Feed Addresses page.

### SmartAUM Feeds
Chainlink SmartAUM Feeds provide current data on the total market value of assets managed by an entity on behalf of clients. Assets Under Management (AUM) is a crucial indicator used in financial analyses and decision-making processes.

By bringing AUM data onchain, decentralized applications can access information for activities such as risk assessment, performance benchmarking, and investment strategy development.

To find a list of available Assets Under Management Feeds, see the SmartData Feed Addresses page.

## Using SmartData Feeds

### Using Single-value SmartData Feeds
Read answers from single-value SmartData feeds the same way that you read other Data Feeds. Specify the SmartData feed address that you want to read instead of specifying a Price feed address. See the Using Data Feeds page to learn more.

Using Solidity, your smart contract should reference AggregatorV3Interface, which defines the external functions implemented by Data Feeds.

Example for reading a Proof of Reserve feed:

[Image: copy to clipboard]
```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import {AggregatorV3Interface} from "@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol";

contract ReserveConsumerV3 {
    AggregatorV3Interface internal reserveFeed;

    /**
     * Network: Ethereum Mainnet
     * Aggregator: WBTC PoR
     * Address: 0xa81FE04086865e63E12dD3776978E49DEEa2ea4e
     */
    constructor() {
        reserveFeed = AggregatorV3Interface(
            0xa81FE04086865e63E12dD3776978E49DEEa2ea4e
        );
    }

    /**
     * Returns the latest price
     */
    function getLatestReserve() public view returns (int) {
        // prettier-ignore
        (
            /*uint80 roundID*/,
            int reserve,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) = reserveFeed.latestRoundData();

        return reserve;
    }
}
```

[Open in Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/DataFeeds/ReserveConsumerV3.sol&autoCompile=true)[What is Remix?](/getting-started/conceptual-overview#what-is-remix)
### Using MVR Feeds
MVR feeds require a different approach compared to single-value SmartData feeds. Instead of returning a single numeric value, they return a bytes array that must be decoded into a specific data structure.

Your code needs to:

1. Call the latestBundle() function to get the raw data
2. Decode the bytes array into a struct that matches the feed's structure
3. Apply the appropriate decimal scaling to numeric fields

For detailed implementation guides, see:

• Using MVR Feeds on EVM Chains (Solidity)
• Using MVR Feeds with ethers.js (JS)
• Using MVR Feeds with Viem (TS)

================================================================================

# SmartData Feed Addresses

Source: https://docs.chain.link/data-feeds/proof-of-reserve/addresses
Extraction Method: playwright
Components: table(1)

# SmartData Feed Addresses
To learn how to use these feeds, see the SmartData Feeds documentation.

For LINK token and Faucet details, see the LINK Token Contracts page.

[Image: note]Talk to an expert

Contact us to talk to an expert about integrating
              Chainlink Data Feeds with your applications.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
### Risks for Proof of Reserve feeds using the wallet address manager
Cross-chain Proof of Reserve feeds using wallet address manager contracts can vary in their configurations. If the wallet address manager is self-reporting, these feeds might include reserve balances from onchain addresses that have not been cryptographically verified to show ownership or control. In circumstances where cryptographically verified ownership is not provided, there is a risk that token issuers could manipulate the value of a Proof of Reserve feed by adding more addresses to the address list even if they do not directly control these addresses. Each feed’s specific configuration is documented in the contract address section. Chainlink Labs is not responsible for the accuracy of self-reported reserves data. Users must do their own risk assessment for asset issuer risk.

[Image: caution]Disclaimer

Proof of Reserve feeds can vary in their configurations. Please be careful with the configuration of the feeds
          used by your smart contracts. You are solely responsible for reviewing the quality of the data (e.g., a Proof
          of Reserve feed) that you integrate into your smart contracts and assume full responsibility for any damage,
          injury, or any other loss caused by your use of the feeds used by your smart contracts.

Learn more about making responsible data quality decisions.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
## Networks
AptosArbitrumAvalancheBaseBNB ChainEthereumLineaOPPolygonScrollSoneiumSolanaSonicZKsyncTrack the status of this network at https://ethstats.dev/

### Ethereum Mainnet
SmartData Type
• Proof of Reserve
• NAVLink
• SmartAUM

Show more detailsShow Multiple-Variable Response (MVR) feeds
SmartData Feed | Deviation | Heartbeat | Dec | Address and Info
--- | --- | --- | --- | ---
🔵 21BTC Proof of ReservesProof of Reserve | 1e-7% | 86400 | 8 | 0x43921Ca0eca1EA69722c048A6afbc2CAd0BB80e9Asset name:Bitcoin (BTC)Reserve type:Cross-chainData source:Cross-chainReporting:Wallet addressIssuer:21.co
🔵 BGBTC Proof of ReservesProof of Reserve | 0.5% | 86400 | 8 | 0xADcc914F882965Ef1B2f1043522b3B81ED081491Asset name:Bitget Wrapped Bitcoin (BGBTC)Reserve type:Cross-chainData source:Bitcoin Network / Cross-chainReporting:Wallet Address ManagerIssuer:Bitget
🔵 cbBTC ReservesProof of Reserve | 0.5% | 86400 | 8 | 0xcBe87Dc0Cf9d807848a3E703B01A90B28eCFb2a7Asset name:Bitcoin (BTC)Reserve type:Cross-chainData source:Cross-chainReporting:Wallet Address ManagerIssuer:Coinbase
🔵 eETH Proof of ReservesProof of Reserve | 2% | 86400 | 18 | 0xC8cd82067eA907EA4af81b625d2bB653E21b5156Asset name:eETHReserve type:Cross-chainData source:Beacon Chain / Cross-chainReporting:Wallet AddressIssuer:ether.fi
🔵 EUTBL NAVNAVLink | 1e-7% | 97200 | 6 | 0xfD628af590c4150A9651C1f4ddD0b4f532B703aeAsset name:Spiko EU T-Bills Money Market Fund (EUTBL)Data source:CaceisReporting:Fund AdministratorIssuer:Spiko
🔵 FBTC Proof of ReservesProof of Reserve | 0.5% | 86400 | 8 | 0x75A0d3264a949C2C920d7F25Df174af1FaF73399Asset name:Bitcoin (BTC)Reserve type:Cross-chainData source:BlockSecAuditor verification:Third-partyIssuer:Ignition
🔵 HBTC Proof of ReservesProof of Reserve | 1e-7% | 259200 | 18 | 0x0A8cD0115B1EE87EbA5b8E06A9a15ED93e230f7aAsset name:BTCReserve type:Cross-chainData source:Cross-chainReporting:Wallet Address ManagerIssuer:Huobi
🔵 M NAVNAVLink | 1e-7% | 93600 | 8 | 0xC28198Df9aee1c4990994B35ff51eFA4C769e534Asset name:MData source:M^0 LabsReporting:M^0 LabsIssuer:M^0 Protocol

PrevShowing 1 to 8 of 26 entries

Next

================================================================================

# Rate and Volatility Feeds

Source: https://docs.chain.link/data-feeds/rates-feeds
Extraction Method: playwright

# Rate and Volatility Feeds
Chainlink rate and volatility feeds provide data for interest rates, interest rate curves, and asset volatility. You can read these feeds the same way that you read other Data Feeds. Specify the Rate or Volatility Feed Address that you want to read instead of specifying a Price Feed address. See the Using Data Feeds page to learn more.

The following data types are available:

• Bitcoin Interest Rate Curve
• ETH Staking APR
• Realized Volatility

## Bitcoin Interest Rate Curve
Lenders and borrowers use base rates to evaluate interest rate risk for lending and borrowing contracts, asset valuation for derivatives contracts, and an underlying rate for interest rate swap contracts. Bitcoin Interest Rate Curve Data Feeds provide a base rate to assist with market decisions and quantify the risks of using certain protocols and products based on current and predicted baseline interest rates. The curve’s normalized methodology and daily rates introduce more consistency and predictability to the ebb and flow of digital asset markets. Bitcoin Interest Rate Curve Feeds incorporate a wide range of data sources such as OTC lending desks, DeFi lending pools, and perpetual futures markets.

To learn more about the use of these interest rate curves in the industry, read the Bitcoin Interest Rate Curve (CF BIRC) blog post.

See the Rate and Volatility Feed Addresses page to find the Bitcoin Interest Rate Curve feeds that are currently available.

## ETH Staking APR
The ETH Staking APR feeds provide a trust-minimized and tamper-proof source of truth for the global rate of return from staking as a validator to secure the Ethereum network. The annualized rate of return is calculated over 30-day and 90-day rolling windows. Data providers use offchain computation to calculate returns at an epoch level, reach consensus on the APR, and then write the results onchain to be used by decentralized protocols and Web 3 applications. Feeds are currently configured to update at a minimum of once per day.

astro-island,astro-slot,astro-static-slot{display:contents}(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).only=e;window.dispatchEvent(new Event("astro:only"));})();(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();[Image: A diagram showing how Staking data is obtained and annualized rate of return is confirmed onchain]See the Rate and Volatility Feed Addresses page to find the ETH Staking APR feeds that are currently available. If you have questions or would like to request an enhancement to ETH Staking APR feeds, contact us using this form.

## Realized volatility
Realized volatility measures asset price movement over a specific time interval. This value is expressed as a percent of the asset price. The more an asset price moves up or down over time, the higher the realized volatility is for that asset. Please note that realized volatility is not the same as implied volatility, which measures the market’s expectation about future volatility typically derived from options markets.

Each data feed reflects the volatility of an asset over a specific rolling window of time. For example, some data feeds provide volatility data for the last 24 hours, 7 days, and 30 days of time. You can compare the data across these windows to infer whether the volatility of an asset is trending up or down. For example, if realized volatility for the 24-hour window is higher than the 7-day window, volatility might increase.

The same high-quality data providers used in Chainlink’s price feeds sample price data every 10 minutes to refresh volatility estimates. onchain values are updated when the feed heartbeat or deviation threshold is met.

[Image: A diagram showing how volatility data is obtained and answers for different volatility windows is confirmed onchain]See the Rate and Volatility Feed Addresses page to find heartbeat and deviation information for each feed. If you have questions or would like to request an enhancement to Realized Volatility Feeds, contact us using this form.

================================================================================

# Rate and Volatility Feed Addresses

Source: https://docs.chain.link/data-feeds/rates-feeds/addresses
Extraction Method: playwright
Components: table(1)

# Rate and Volatility Feed Addresses
To learn how to use these feeds, see the Using Data Feeds guide.

For LINK token and Faucet details, see the LINK Token Contracts page.

[Image: caution]caution

Please be careful with the feeds used by your smart contracts. The feeds listed in our official documentation
          have been reviewed; feeds built for custom deployments by other community members might have additional risks.
          Please do close diligence on your feeds before implementing them in your contracts.  Learn more about making responsible data quality decisions.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
## Networks
ArbitrumAvalancheEthereumTrack the status of this network at https://ethstats.dev/

### Sepolia Testnet
Show more details
Pair | Deviation | Heartbeat | Dec | Address and info
--- | --- | --- | --- | ---
30-Day ETH APR | 50% | 86400s | 7 | 0xceA6Aa74E6A86a7f85B571Ce1C34f1A60B77CD29Market hours:Crypto
90-Day ETH APR | 50% | 86400s | 7 | 0x7422A64372f95F172962e2C0f371E0D9531DF276Market hours:Crypto
BTC-USD 24hr Realized Volatility | 50% | 3600s | 5 | 0x28f9134a15cf0aAC9e1F0CD09E17f32925254C77Market hours:Crypto
BTC-USD 30-Day Realized Volatility | 50% | 3600s | 5 | 0xabfe1e28F54Ac40776DfCf2dF0874D37254D5F59Market hours:Crypto
BTC-USD 7-Day Realized Volatility | 50% | 3600s | 5 | 0x88163626786Ee98AA1De65BD2A76599e71598FD9Market hours:Crypto
ETH-USD 24hr Realized Volatility | 50% | 3600s | 5 | 0x31D04174D0e1643963b38d87f26b0675Bb7dC96eMarket hours:Crypto
ETH-USD 30-Day Realized Volatility | 50% | 3600s | 5 | 0x8e604308BD61d975bc6aE7903747785Db7dE97e2Market hours:Crypto
ETH-USD 7-Day Realized Volatility | 50% | 3600s | 5 | 0xF3140662cE17fDee0A6675F9a511aDbc4f394003Market hours:Crypto

PrevShowing 1 to 8 of 11 entries

Next

================================================================================

# Selecting Quality Data Feeds

Source: https://docs.chain.link/data-feeds/selecting-data-feeds
Extraction Method: playwright
Components: table(1)

# Selecting Quality Data Feeds
When you design your applications, consider the quality of the data that you use in your smart contracts. Ultimately you are responsible for identifying and assessing the accuracy, availability, and quality of data that you choose to consume via the Chainlink Network. Note that all feeds contain some inherent risk. Read the Risk Mitigation and Evaluating Data Sources sections when making design decisions. Chainlink lists decentralized data feeds in the documentation to help developers build new applications integrated with data.

## Data Feed Categories
This categorization is put in place to inform users about the intended use cases of feeds and help highlight some of the inherent market integrity risks surrounding the data quality of these feeds.

All feeds published on docs.chain.link are monitored and maintained to the same levels and standards. Each feed goes through a rigorous assessment process when implemented. The assessment criteria can vary depending on the product type of feed being deployed or change over time as the understanding of market integrity risks evolves.

Market price feeds incorporate three layers of aggregation at the data source, node operator, and oracle network layers, providing industry-standard security and reliability on the price data they reference. To learn more about the three layers of data aggregation, see the blog post about Data Aggregation in Chainlink Price Feeds. Additional information about how Chainlink Data Feeds are secured can be seen in the blog post about How Chainlink Price Feeds Secure the DeFi Ecosystem.

Data feeds are grouped into the following categories based on the level of market integrity risk from lowest to highest:

• 🟢 Low Market Risk
• 🟡 Medium Market Risk
• 🔴 High Market Risk
• 🟠 New Token Feeds
• 🔵 Custom Feeds
• ⭕ Deprecating

[Image: note]note

For important updates regarding the use of Chainlink Data Feeds, users should join the official Chainlink Discord and
subscribe to the #data-feeds channel.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
### 🟢 Low Market Risk Feeds
These are data feeds that follow a standardized data feeds workflow to report market prices for an asset pair. Chainlink node operators each query several sources for the market price and aggregate the estimates provided by those sources.

Low Market Risk feeds have the following characteristics:

• Highly resilient to disruption
• Leverage many data sources
• High volumes across a large number of markets enable consistent price discovery

While market risk may be low, other risks might still exist based on your use case, the blockchain on which the feed is deployed, and the conditions on that chain.

### 🟡 Medium Market Risk Feeds
These feeds also follow a standardized data feeds workflow to report market prices for an asset pair. The pair in question may have features that make it more challenging to reliably price, or potentially subject it to volatility which may pose a risk in some use cases. While the architecture of these feeds is resilient and distributed, these feeds carry additional market risk.

Types of market risk that may lead to a feed being categorized as Medium Market Risk include:

• Lower or inconsistent asset volume may result in periods of low liquidity in the market for such assets. This, in turn, can lead to volatile price movements
• A spread between the price for this asset on different trading venues or liquidity pools.
• Market Concentration Risk: If the volume for a given asset is excessively concentrated on a single exchange, that trading venue could become a single point of failure for the feed.
• Cross-Rate Risk: The base asset trades in large volumes against assets that are not pegged to the quote asset. As a result, the price of this specific asset pair may fluctuate even if the underlying asset is not being traded.
• The asset is going through a significant market event such as a token or liquidity migration.
• The asset has a high spread between data providers, the root cause of which is often one of the above factors.

### 🔴 High Market Risk Feeds
These feeds also follow a standardized data feeds workflow to report market prices for an asset pair. However, the pair in question often exhibits a heightened degree of some of the risk factors outlined under “Medium Market Risk”, or a separate risk that makes the market price subject to uncertainty or volatility. In using a High Market Risk data feed you acknowledge that you understand the risks associated with such a feed and that you are solely responsible for monitoring and mitigating such risks.

Types of market risk that may lead to a feed being categorized as High Market Risk include:

• The asset is going through a significant market event such as a hack, bridge failure, or a delisting from a major exchange.
• The asset or project is being deprecated in the market.
• Volumes have dropped to extremely low levels.

### 🟠 New Token Feeds
When a token is newly launched, the historical data required to implement a rigorous risk assessment framework that would allow the categorization of a market data feed for that token as low, medium, or high market risk is unavailable. Consistent price discovery may involve an indeterminate amount of time. Users must understand the additional market and volatility risks inherent with such assets. Users of new token feeds are responsible for independently verifying the liquidity and stability of the assets priced by the feeds that they use.
At the end of a probationary period, the status of new token feeds may be adjusted to high/medium/low market risk or in rare cases be deprecated entirely.

### 🔵 Custom Feeds
Custom Feeds are built to serve a specific use case and might not be suitable for general use or your use case's risk parameters. Users must evaluate the properties of a feed to make sure it aligns with their intended use case. Contact the Chainlink Labs team if you want more detail on any specific feeds in this category.

Custom feeds have the following categories and compositions:

• Onchain single source feeds: These feeds take their data from an onchain source, however, the feed has only a single data provider currently supporting the feed.
• Onchain Proof of Reserve Feeds: Chainlink Proof of Reserve uses a large decentralized collection of security-reviewed and Sybil-resistant node operators to acquire and verify reserve data. In this use case, reserves reside onchain.
• Exchange Rate Feeds: These feeds read an exchange rate from an external contract onchain that is designed to allow conversion from one token to another. Chainlink does not own or control these contracts in any way. They are not equivalent to market price feeds.
• Technical Feeds: Feeds within this category measure a particular technical metric from a specified blockchain. For example, Fast Gas or Block Difficulty.
• Total Value Locked Feeds: These feeds measure the total value locked in a particular protocol.
• Custom Index Feeds: An index calculates a function of the values for multiple underlying assets. The function is specific to that index and is typically calculated by node operators following an agreed formula.
• Offchain Single Source Feeds: Some data providers use a single data source, which might be necessary if only one source exists offchain for a specific type of data.
• Offchain Proof of Reserve Feeds: Chainlink Proof of Reserve uses a large decentralized collection of security-reviewed and Sybil-resistant node operators to acquire and verify reserve data. In this use case, reserves reside offchain.
• LP Token Feeds: These feeds use a decentralized feed for the underlying asset as well as calculations to value the liquidity pool (LP) tokens.
• Wrapped Calculated Feeds: These feeds are typically pegged 1:1 to the underlying token or asset. Under normal market conditions, these feeds track their underlying value accurately. However, given that the price is a derivative formed from a calculated method, the derivative asset may not always precisely track the value of the underlying token or asset precisely.

If you plan on using one of these feeds and would like to get a more detailed understanding, contact the Chainlink Labs team.

### ⭕ Deprecating
These feeds are being deprecated. To find the deprecation dates for specific feeds, see the Feeds Scheduled For Deprecation page.

#### Data Feed Shutdown Policy
Data feeds managed by Chainlink Labs will be considered for deprecation if they pose a risk to the Chainlink Community and broader ecosystem, if the asset or assets on the feed have significantly deteriorated and no longer meet our Quality Assurance standards, or if the data feed has become economically unsustainable to support.

Known users of these feeds will be contacted directly about the feeds' deprecation. Notifications will also be posted on the Feeds Scheduled For Deprecation page and on our Discord channel with two weeks of notice before they are shut down.

## Market hours
In addition to categories, be aware that markets for several assets are actively traded only during certain hours. Listed data feeds include an attribute describing their market hours. Chainlink Labs recommends using these feeds only during their specified hours:

Feed | Hours
--- | ---
Crypto | 24/7/365 - No market close.
US_Equities | Standard US equity market hours: 09:30 - 16:00 ET M-F excluding US equity market holidays.
UK_ETF | Standard UK equity market hours: 08:00 - 16:30 UK time M-F excluding UK equity market holidays.
Forex | 18:00 ET Sunday to 17:00 ET Friday.  The feeds also follow the global Forex market Christmas and New Year's Day holiday schedule. Many non-G12 currencies primarily trade during local market hours. It is recommended to use those feeds only during local trading hours.
Precious_Metals | 18:00 ET Sunday to 17:00 ET Friday with a one-hour break Monday through Thursday from 17:00 to 18:00.  The feeds also follow the global Forex market holiday schedule for Christmas and New Year's Day.
NYMEX (US OIL) | 18:00 ET Sunday to 17:00 ET Friday, with a one-hour break Monday through Thursday from 17:00 to 18:00.  The feed also follows the NYMEX market holiday schedule.
COMEX (Non precious metals) | 18:00 ET Sunday to 17:00 ET Friday with a one-hour break Monday through Thursday from 17:00 to 18:00.  The feed also follows the COMEX market holiday schedule.
CBOT (Agricultural) | Monday - Thursday 00:00-08:45, 09:30-00:00 and Friday 00:00-08:45, 09:30-14:00 ET, excluding CBOT market holidays.
MI_ETF | Standard Milan equity market hours. 09:00-17:30 CET time M-F, excluding Milan equity market holidays.
XETRA_ETF | Deutsche Börse Xetra equity market hours. 09:00-17:30 CET time M-F, excluding Xetra equity market holidays.

## Risk Mitigation
As a development best practice, design your systems and smart contracts to be resilient and mitigate risk to your protocol and your users. Ensure that your systems can tolerate known and unknown exceptions that might occur. Some examples include but are not limited to volatile market conditions, the degraded performance of infrastructure, chains, or networks, and any other upstream outage related to data providers or node operators. You bear responsibility for any manner in which you use the Chainlink Network, its software, and documentation.

To help you prepare for unforeseen market events, you should take additional steps to protect your application or protocol regardless of the market risk categorization of the Data Feeds your application consumes. The below tooling is put in place to mitigate extreme market events, possible malicious activity on third-party venues or contracts, potential delays, performance degradation, and outages.
Below are some examples of tooling that Chainlink users have put in place:

• Circuit breakers: In the case of an extreme price event, the contract would pause operations for a limited period of time. Chainlink Automation is able to monitor data feeds to identify unexpected events. If an event were to occur, the Automation network can send an onchain transaction to pause or halt contract functionality.
• Contract update delays: Contracts would not update until the protocol had received a recent fresh input from the data feed.
• Manual kill switch: If a vulnerability or bug is discovered in one of the upstream contracts, the user can manually cease operation and temporarily sever the connection to the data feed.
• Monitoring: Some users create their own monitoring alerts based on deviations in the data feeds that they are using.
• Soak testing: Users are strongly advised to thoroughly test price feed integrations and incorporate a soak period prior to providing access to end users or securing value.

For more detailed information about some of these examples, see the Monitoring data feeds documentation.

For important updates regarding the use of Chainlink Price Feeds, users should join the official Chainlink Discord and subscribe to the data-feeds-user-notifications channel.

## Chainlink Community Deployments
Chainlink technology is used by many within the blockchain community to support their use cases. Deployments built and run by community members are not tracked in the Chainlink documentation. Chainlink's community is continuously growing, and they play a vital role in developing the ecosystem, so the software and tooling are developed for anyone to use. Users have a wide variety of options for choosing how to deliver data onchain. They can deploy Chainlink nodes themselves or via the extensive network of node operators that offer services and access one of the community-managed oracle networks that support the supply of various types of data onchain. Chainlink Labs does not take responsibility for the use of Chainlink node software.

It is always recommended that you conduct a thorough analysis of your requirements and carry out appropriate due diligence on any partners you wish to use with your project.

The Chainlink Labs team does not monitor community deployments and users should use best practices in observability, monitoring, and risk mitigation as appropriate for your application's stage of development and use case.

As your usage of data feeds evolves and requirements for higher availability and greater security increases, such as securing substantive value, the reliability properties of your data feed will become crucial. Contact Chainlink Labs team for services to ensure deployments meet the highest levels of availability and security.

High Risk: Forked, modified, or custom software:

As Chainlink is open source, independent forks and modifications may exist. Chainlink Labs and development teams are not involved in these and do not track or maintain visibility on them. Chainlink Labs is not responsible for updates, enhancements, or bug fixes for these versions, and Chainlink Labs does not monitor them. Their use might pose risks that can do harm to your project. Users are responsible for thoroughly vetting and validating such deployments and determining their suitability.

## Evaluating Data Sources and Risks
If your smart contracts use data feeds, assess those data feeds for the following characteristics:

• Liquidity and its Distribution
• Single Source Data Providers
• Crypto and Blockchain Actions
• Market Failures Resulting from Extreme Events
• Periods of High Network Congestion
• Unknown and Known Users
• DEX volumes

### Liquidity and its Distribution
If your smart contract relies on pricing data for a specific asset, make sure that the asset has a sufficiently healthy level of liquidity in the market to avoid price and market manipulation. Assets with low liquidity or volume can be volatile, which might negatively impact your application and its users. Malicious actors might try to exploit volatility or periods of reduced trading activity to take advantage of the logic in a smart contract and cause it to execute in a way that you did not intend.

Some data feeds obtain their pricing data from individual exchanges rather than from aggregated price tracking services that gather their data from multiple exchanges. These are marked as such in the docs page for that feed. Assess the liquidity and reliability of that specific exchange.

Liquidity migrations occur when a project moves its tokens from one liquidity provider (such as a DEX, a CEX, or a new DeFi application) to another. When liquidity migrations occur, it can result in low liquidity in the original pool, making the asset susceptible to market manipulation. If your project is considering a liquidity migration, you should coordinate with relevant stakeholders, including liquidity providers, exchanges, oracle node operators, Data Feed providers, and users, to ensure prices are accurately reported throughout the migration.

Feeds for assets with low market liquidity or volume where data providers exhibit an abnormal price spread may, on occasion, see a price oscillate between two or more price points within regular intervals. To mitigate risk associated with such price oscillation, users must regularly monitor & assess the quality of an asset's liquidity. Similarly, assets with low market liquidity may experience abnormal or volatile price movements due to erroneous trades.

Design and test your contracts to handle price spikes and implement risk management measures to protect your assets. For example, create mock tests that return various oracle responses.

### Single Source Data Providers
Some data providers use a single data source, which might be necessary if only one source exists onchain or offchain for a specific type of data. Evaluate data providers to make sure they provide high-quality data that your smart contracts can rely on. Any error or omission in the provider's data might negatively impact your application and its users.

### Crypto and Blockchain Actions
Price data quality is subject to crypto actions by the crypto and blockchain project teams. Crypto actions are similar to corporate actions but are specific to cryptocurrency and blockchain projects, such as token renaming, token swaps, redenominations, splits, reverse splits, network upgrades, and other migrations that teams or communities who govern the blockchain or token might undertake.

Sustaining data quality is dependent on data sources implementing the necessary adjustments related to such actions. For example, when a project upgrades to a new version of their token, this results in a token migration. When token migrations occur, they require building a new Data Feed to ensure that the token price is accurately reported. Similarly, actions by blockchain project teams or communities, such as forks or upgrades to the network, may require new Data Feeds to ensure continuity and data quality. When considering a token migration, fork, network upgrade, or other crypto action, projects should proactively reach out to relevant stakeholders to ensure the asset price is accurately reported throughout the process.

### Market Failures Resulting from Extreme Events
Users are strongly advised to set up monitoring and alerts in the event of unexpected market failures. Black swan events, hacks, coordinated attacks, or extreme market conditions may trigger unanticipated outcomes such as liquidity pools becoming unbalanced, unexpected re-weighting of indices, abnormal behavior by centralized or decentralized exchanges, or the de-pegging of synthetic assets, stablecoins, and currencies from their intended exchange rates.

Circuit breakers can be created using Chainlink Automation. Circuit breakers are safety measures that monitor data feeds for unexpected scenarios such as stale prices, drastic price changes, or prices approaching a predetermined min/max threshold. If an unexpected scenario occurs, the circuit breaker can send an onchain transaction to pause or halt contract functionality.

### Periods of High Network Congestion
Data Feed performance relies on the chains they are deployed on. Periods of high network congestion or network downtime might impact the frequency of Chainlink Data Feeds. It is advised that you configure your applications to detect such chain performance or reliability issues and to respond appropriately.

### Unknown and Known Users
Routine maintenance is carried out on Chainlink Data Feeds, including decommissioning, on an ad-hoc basis. These maintenance periods might require users to take action in order to maintain business continuity.

Notifications are sent to inform known users regarding such occurrences, and it is strongly encouraged for all users, including those users utilizing data feeds for offchain purposes, to provide their contact information before utilizing data feeds. Without providing contact information, users will be unable to receive notifications regarding important Data Feed updates.

If you are using Data Feeds but have not provided your contact information, you can do so here. Users that fail to provide notification information do so at their own risk.

### DEX Volumes
Assets with a significant market presence on decentralized exchanges (DEXs) face distinct risks related to unique market structure. The market integrity can be compromised by flash loan-funded attacks, volume shifts to different onchain or offchain exchanges, or a well-capitalized actor temporarily manipulating the price on that exchange. Additionally, DEX trades can result in slippage due to liquidity migrations and trade size. The likelihood of high-slippage trades being accurately reflected in market prices depends on the trading patterns of the asset.

Generally, a lower risk of deviant trades impacting aggregated prices is associated with assets having multiple DEX pools with healthy volumes and consistent trading activity across different time windows.

## Evaluating Wrapped or Bridged Assets

### Assessing how to Price Wrapped or Bridged Assets
When assessing a Chainlink Data Feed for a wrapped or bridged asset such as WBTC, users should evaluate the tradeoffs between using a Data Feed specifically built for the wrapped or bridged asset or a Data Feed built for the underlying asset.

Decisions should be made on a case-by-case basis considering the liquidity, depth, and trading volatility of the underlying asset compared to its derivative. In addition, users must consider the security mechanism that is designed to keep the wrapped or bridged asset coupled to its underlying asset. Review these parameters regularly as asset dynamics continuously evolve.

### Extreme Events Causing Price Deviations in Wrapped or Bridged Assets
Chainlink Data Feeds are designed to provide the market-wide price of various assets, as determined by a volume-weighted average across a wide range of exchanges. On blockchain networks where assets are wrapped and/or bridged from another environment using a cross-chain token bridge, Chainlink Data Feeds built for the underlying asset will continue to report the market-wide price of the underlying asset as opposed to the price of the wrapped/bridged asset. This methodology reduces risks around market manipulation because wrapped/bridged tokens are often less liquid than the underlying asset.

However, users should be aware that certain extreme events may result in price deviations between the wrapped/bridged asset and its underlying counterpart. For example, the exploitation or hack of a cross-chain token bridge may cause a collapse in demand for a particular wrapped asset. As such, users should construct their applications with safeguards, such as circuit breakers to proactively pause functionality to mitigate risk during such scenarios. Circuit breakers can be created using Chainlink Automation to monitor data feeds for unexpected scenarios.

An additional mechanism for securing a protocol utilizing wrapped assets is by incorporating Chainlink Proof of Reserve. Chainlink Proof of Reserve enables the real-time reserve monitoring of offchain and cross-chain assets, including those that have been wrapped/bridged. By comparing the wrapped token’s supply against a Chainlink Proof of Reserve feed, protocols can ensure that these assets are properly collateralized at all times.

### Front Running Risk
Front running (when a third party benefits from prior access to information about a transaction) is a known risk inherent to specific blockchain applications. Chainlink Data Feeds are optimized to prioritize high levels of data quality and reliability over latency.

To mitigate the risk associated with front running, users building highly latency-dependent applications should assess whether the configuration of data feeds meets their needed specifications for speed and frequency. Chainlink Data Streams serve as an alternative solution to Data Feeds for latency-sensitive applications, providing low-latency delivery of market data offchain that can be verified onchain while mitigating front running.

## Exchange Rate Feeds
The architecture of exchange rate feeds differs from that of standard market rate Chainlink Price Feeds.

Market rate feeds (e.g., Chainlink Price Feeds) deliver price updates based on the volume-based aggregated market price of a specific asset. Price data is aggregated from across multiple sources, including centralized and decentralized exchanges, to provide an accurate representation of an asset's market-wide price.

Exchange rate feeds are tied to specific protocols or ecosystems and report the internal redemption rates for an asset (i.e., the value/rate at which an asset can be redeemed or exchanged within that protocol's ecosystem). This data is sourced directly from a specified smart contract on a source chain and relayed to a destination chain.

Exchange rate feeds are useful in circumstances such as:

• Pricing yield-bearing assets: Multiplying a yield-bearing asset's exchange rate by the underlying asset's market rate can be used to calculate the yield-bearing asset's current price. This methodology can reduce certain pricing volatility risks associated with lower-liquidity yield-bearing assets.
• Enabling cross-chain staking: For example, liquid staking tokens (LSTs) or liquid restaking tokens (LRTs) can be minted at the exchange rate on a layer 2, while Chainlink CCIP transfers the underlying asset to a layer 1 for staking.
• Improving liquidity pool performance for yield-bearing assets: Exchange rate feeds can be utilized to programmatically adjust swap curves to maximize liquidity efficiency.

[Image: note]note

Users must be aware that both market rate and exchange rate pricing methodologies have unique risk considerations and
mitigation strategies that vary based on an asset's type and liquidity profile. Users are responsible for decisions
relating to feed selection. To learn more about how best to leverage Chainlink Data Feeds for your project, contact us
here.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
## ETF and Forex feeds
When you use Data Feeds for ETFs or Foreign Exchange (Forex) data, be aware of the following best practices:

• Offchain equity and ETF assets are traded only during standard market hours. Do not use these feeds outside those windows.
• Assets on the Forex (Foreign Exchange) markets are traded only during defined market hours. Additionally, some currencies might trade only during local banking hours. Do not use Forex feeds outside market hours for the specific currency.
• UK ETF price feed answers are 15 minutes delayed from their original published source. Assets are traded only during standard market hours. Do not use these feeds outside their specified hours.

================================================================================

# Data Feeds on Solana

Source: https://docs.chain.link/data-feeds/solana
Extraction Method: playwright
Components: code_block(2)

# Data Feeds on Solana
[Image: caution]Solana Data Feeds Deprecation

Several Data Feeds on Solana are being deprecated as Chainlink migrates support to
Data Streams' pull-based model. See this page for the complete list of Data Streams
available on Solana.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }Chainlink provides data feeds on the Solana network. Chainlink data feeds on Solana employ Offchain Reporting (OCR) to aggregate data from data providers who pull from both centralized and decentralized exchanges. Chainlink’s Solana deployment has no dependencies on external blockchain networks such as Ethereum. In Solana, storage and smart contract logic are separate. Programs store all the logic similar to an EVM (Ethereum) smart contract. The accounts store all the data. Compared to Solidity, the combination of an account and a program is equivalent to a smart contract on an EVM chain. State and logic are separate in Solana.

Solana programs are stateless, so you don't always need to deploy your program to the network to test it. You can deploy and test your programs on a Solana Test Validator. However, to use Chainlink products on Solana, you must deploy your contract onchain to one of the supported Solana clusters.

[Image: note]Note

Please note that Price Feeds performance relies on the chains they are deployed on. Periods of high network congestion
may impact the frequency of Chainlink Price Feeds. Subscribe to Solana status
notifications to stay updated on system performance.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }To learn how to mitigate risk to your applications, read the Selecting Quality Data Feeds page.

## Chainlink products and Solana clusters
Price Feeds are available on the following Solana clusters:

• Solana Mainnet
• Solana Devnet

Solana provides a Testnet cluster that runs newer Solana releases, but Chainlink Data Feeds are not available on this cluster.

See the Solana Data Feeds page for a full list of Chainlink data feeds that are available on Solana.

To learn when more Chainlink services become available, follow us on Twitter or sign up for our mailing list.

## Languages, tools, and frameworks
The examples in the Chainlink documentation use the following languages, tools, and frameworks:

• Node.js 14 or higher: Used to run client code
• Rust: A general-purpose programming language designed for performance and memory safety
• Anchor: A Solana Sealevel Framework that provides several developer tools
• Chainlink Solana Starter Kit: An Anchor based program and client that shows developers how to use and interact with Chainlink Data Feeds on Solana
• Solana CLI: The Solana command line interface
• Git: Used to clone the example code repository

When developing applications to use Chainlink products on Solana, always use a Mainnet release version of the Solana CLI that is equal to or greater than the version currently running on your target cluster. Use solana --version and solana cluster-version to check CLI and cluster versions:

[Image: copy to clipboard]
```shell
solana --version
solana-cli 1.9.28 (src:b576e9cc; feat:320703611)

solana cluster-version --url devnet
1.9.25

solana cluster-version --url mainnet-beta
1.9.28
```

The examples in this documentation use Solana programs in Rust. To learn more about the Solana programming model, see the Solana Documentation.

## Solana wallets
When you use Chainlink on Solana, you need a Solana wallet. The Chainlink documentation uses file system wallets and free Devnet SOL tokens to demonstrate examples. When you deploy your programs to the Solana Mainnet, you must use wallets with mainnet lamports.

If you have existing wallets that you want to use for the guides in the Chainlink documentation, find your wallet keypair and make it available in your development environment as a file. You can point Anchor and the Solana CLI to a specific keypair when you deploy or manage your Solana programs.

[Image: copy to clipboard]
```shell
anchor build
⋮

anchor deploy --provider.wallet ~/.config/solana/id.json --provider.cluster devnet
⋮

solana program show --programs --keypair ~/.config/solana/id.json --url devnet

Program Id                                   | Slot      | Authority                                    | Balance
6U4suTp55kiJRKqV7HGAQvFgcLaStLnUA4myg5DRqsKw | 109609728 | E6gKKToCJPgf4zEL1GRLL6T99g2WcfAzJAMvtma1KijT | 2.57751768 SOL
```

When you build your production applications and deploy Solana programs to the Mainnet cluster, always follow the security best practices in the Solana Wallet Guide for managing your wallets and keypairs.

================================================================================

# Using Data Feeds on EVM Chains

Source: https://docs.chain.link/data-feeds/using-data-feeds
Extraction Method: playwright
Components: code_block(5)

# Using Data Feeds on EVM Chains
The code for reading Data Feeds is the same across all EVM-compatible blockchains and Data Feed types. You choose different types of feeds for different uses, but the request and response format are the same. To read a feed, specify the following variables:

• RPC endpoint URL: This determines which network that your smart contracts will run on. You can use a node provider service or point to your own client. If you are using a Web3 wallet, it is already configured with the RPC endpoints for several networks and the Remix IDE will automatically detect them for you.
• LINK token contract address: The address for the LINK token contract is different for each network. You can find the full list of addresses for all supported networks on the LINK Token Contracts page.
• Feed contract address: This determines which data feed your smart contract will read. Contract addresses are different for each network. You can find the available contract addresses on the following pages:

Price Feed Addresses
SmartData Addresses

The examples in this document indicate these variables, but you can modify the examples to work on different networks and read different feeds.

This guide shows example code that reads data feeds using the following languages:

• Onchain consumer contracts:

Solidity
Vyper
• Offchain reads using Web3 packages:

Javascript with web3.js
Python with Web3.py
Golang with go-ethereum

## Reading data feeds onchain
These code examples demonstrate how to deploy a consumer contract onchain that reads a data feed and stores the value.

### Solidity
To consume price data, your smart contract should reference AggregatorV3Interface, which defines the external functions implemented by Data Feeds.

[Image: copy to clipboard]
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import {AggregatorV3Interface} from "@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol";

/**
 * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED
 * VALUES FOR CLARITY.
 * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

/**
 * If you are reading data feeds on L2 networks, you must
 * check the latest answer from the L2 Sequencer Uptime
 * Feed to ensure that the data is accurate in the event
 * of an L2 sequencer outage. See the
 * https://docs.chain.link/data-feeds/l2-sequencer-feeds
 * page for details.
 */

contract DataConsumerV3 {
    AggregatorV3Interface internal dataFeed;

    /**
     * Network: Sepolia
     * Aggregator: BTC/USD
     * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
     */
    constructor() {
        dataFeed = AggregatorV3Interface(
            0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
        );
    }

    /**
     * Returns the latest answer.
     */
    function getChainlinkDataFeedLatestAnswer() public view returns (int) {
        // prettier-ignore
        (
            /* uint80 roundId */,
            int256 answer,
            /*uint256 startedAt*/,
            /*uint256 updatedAt*/,
            /*uint80 answeredInRound*/
        ) = dataFeed.latestRoundData();
        return answer;
    }
}
```

[Open in Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/DataFeeds/DataConsumerV3.sol&autoCompile=true)[What is Remix?](/getting-started/conceptual-overview#what-is-remix)The latestRoundData function returns five values representing information about the latest price data. See the Data Feeds API Reference for more details.

### Vyper
To consume price data, your smart contract should import AggregatorV3Interface which defines the external functions implemented by Data Feeds. You can find it here.
You can find a PriceConsumer example here. Read the apeworx-starter-kit README to learn how to run the example.

## Reading data feeds offchain
These code examples demonstrate how to read data feeds directly off chain using Web3 packages for each language.

### Javascript
This example uses web3.js to retrieve feed data from the BTC / USD feed on the Sepolia testnet.

(()=>{var a=(s,i,o)=>{let r=async()=>{await(await s())()},t=typeof i.value=="object"?i.value:void 0,c={rootMargin:t==null?void 0:t.rootMargin},n=new IntersectionObserver(e=>{for(let l of e)if(l.isIntersecting){n.disconnect(),r();break}},c);for(let e of o.children)n.observe(e)};(self.Astro||(self.Astro={})).visible=a;window.dispatchEvent(new Event("astro:visible"));})();web3.jsethers.js[Image: copy to clipboard]
```solidity
/**
 * THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
 * THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

const Web3 = require("web3") // for nodejs only
const web3 = new Web3("https://rpc.ankr.com/eth_sepolia")
const aggregatorV3InterfaceABI = [
  {
    inputs: [],
    name: "decimals",
    outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "description",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [{ internalType: "uint80", name: "_roundId", type: "uint80" }],
    name: "getRoundData",
    outputs: [
      { internalType: "uint80", name: "roundId", type: "uint80" },
      { internalType: "int256", name: "answer", type: "int256" },
      { internalType: "uint256", name: "startedAt", type: "uint256" },
      { internalType: "uint256", name: "updatedAt", type: "uint256" },
      { internalType: "uint80", name: "answeredInRound", type: "uint80" },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "latestRoundData",
    outputs: [
      { internalType: "uint80", name: "roundId", type: "uint80" },
      { internalType: "int256", name: "answer", type: "int256" },
      { internalType: "uint256", name: "startedAt", type: "uint256" },
      { internalType: "uint256", name: "updatedAt", type: "uint256" },
      { internalType: "uint80", name: "answeredInRound", type: "uint80" },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "version",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function",
  },
]
const addr = "0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43"
const priceFeed = new web3.eth.Contract(aggregatorV3InterfaceABI, addr)
priceFeed.methods
  .latestRoundData()
  .call()
  .then((roundData) => {
    // Do something with roundData
    console.log("Latest Round Data", roundData)
  })
```

[Image: copy to clipboard]
```solidity
/**
 * THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
 * THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

const { ethers } = require("ethers") // for nodejs only
const provider = new ethers.providers.JsonRpcProvider("https://rpc.ankr.com/eth_sepolia")
const aggregatorV3InterfaceABI = [
  {
    inputs: [],
    name: "decimals",
    outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "description",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [{ internalType: "uint80", name: "_roundId", type: "uint80" }],
    name: "getRoundData",
    outputs: [
      { internalType: "uint80", name: "roundId", type: "uint80" },
      { internalType: "int256", name: "answer", type: "int256" },
      { internalType: "uint256", name: "startedAt", type: "uint256" },
      { internalType: "uint256", name: "updatedAt", type: "uint256" },
      { internalType: "uint80", name: "answeredInRound", type: "uint80" },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "latestRoundData",
    outputs: [
      { internalType: "uint80", name: "roundId", type: "uint80" },
      { internalType: "int256", name: "answer", type: "int256" },
      { internalType: "uint256", name: "startedAt", type: "uint256" },
      { internalType: "uint256", name: "updatedAt", type: "uint256" },
      { internalType: "uint80", name: "answeredInRound", type: "uint80" },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "version",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function",
  },
]
const addr = "0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43"
const priceFeed = new ethers.Contract(addr, aggregatorV3InterfaceABI, provider)
priceFeed.latestRoundData().then((roundData) => {
  // Do something with roundData
  console.log("Latest Round Data", roundData)
})
```

astro:endastro-island,astro-slot,astro-static-slot{display:contents}(()=>{var l=(n,t)=>{let i=async()=>{await(await n())()},e=typeof t.value=="object"?t.value:void 0,s={timeout:e==null?void 0:e.timeout};"requestIdleCallback"in window?window.requestIdleCallback(i,s):setTimeout(i,s.timeout||200)};(self.Astro||(self.Astro={})).idle=l;window.dispatchEvent(new Event("astro:idle"));})();(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();Latest Price:Latest Price

### Python
This example uses Web3.py to retrieve feed data from the BTC / USD feed on the Sepolia testnet.

[Image: copy to clipboard]
```solidity
# THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
# THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
# DO NOT USE THIS CODE IN PRODUCTION.

from web3 import Web3

# Change this to use your own RPC URL
web3 = Web3(Web3.HTTPProvider('https://rpc.ankr.com/eth_sepolia'))
# AggregatorV3Interface ABI
abi = '[{"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"description","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint80","name":"_roundId","type":"uint80"}],"name":"getRoundData","outputs":[{"internalType":"uint80","name":"roundId","type":"uint80"},{"internalType":"int256","name":"answer","type":"int256"},{"internalType":"uint256","name":"startedAt","type":"uint256"},{"internalType":"uint256","name":"updatedAt","type":"uint256"},{"internalType":"uint80","name":"answeredInRound","type":"uint80"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"latestRoundData","outputs":[{"internalType":"uint80","name":"roundId","type":"uint80"},{"internalType":"int256","name":"answer","type":"int256"},{"internalType":"uint256","name":"startedAt","type":"uint256"},{"internalType":"uint256","name":"updatedAt","type":"uint256"},{"internalType":"uint80","name":"answeredInRound","type":"uint80"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"version","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}]'
# Price Feed address
addr = '0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43'

# Set up contract instance
contract = web3.eth.contract(address=addr, abi=abi)
# Make call to latestRoundData()
latestData = contract.functions.latestRoundData().call()
print(latestData)
```

### Golang
You can find an example with all the source files here. This example uses go-ethereum to retrieve feed data from the BTC / USD feed on the Sepolia testnet.
To learn how to run the example, see the README.

## Getting a different price denomination
Chainlink Data Feeds can be used in combination to derive denominated price pairs in other currencies.

If you require a denomination other than what is provided, you can use two data feeds to derive the pair that you need. For example, if you needed a BTC / EUR price, you could take the BTC / USD feed and the EUR / USD feed and derive BTC / EUR using division.

[Image: caution]Important

If your contracts require Solidity versions that are >=0.6.0 <0.8.0, use OpenZeppelin's SafeMath version 3.4.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }[Image: copy to clipboard]
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import {AggregatorV3Interface} from "@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol";

/**
 * Network: Sepolia
 * Base: BTC/USD
 * Base Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
 * Quote: EUR/USD
 * Quote Address: 0x1a81afB8146aeFfCFc5E50e8479e826E7D55b910
 * Decimals: 8
 */

/**
 * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
 * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

contract PriceConverter {
    function getDerivedPrice(
        address _base,
        address _quote,
        uint8 _decimals
    ) public view returns (int256) {
        require(
            _decimals > uint8(0) && _decimals <= uint8(18),
            "Invalid _decimals"
        );
        int256 decimals = int256(10 ** uint256(_decimals));
        (, int256 basePrice, , , ) = AggregatorV3Interface(_base)
            .latestRoundData();
        uint8 baseDecimals = AggregatorV3Interface(_base).decimals();
        basePrice = scalePrice(basePrice, baseDecimals, _decimals);

        (, int256 quotePrice, , , ) = AggregatorV3Interface(_quote)
            .latestRoundData();
        uint8 quoteDecimals = AggregatorV3Interface(_quote).decimals();
        quotePrice = scalePrice(quotePrice, quoteDecimals, _decimals);

        return (basePrice * decimals) / quotePrice;
    }

    function scalePrice(
        int256 _price,
        uint8 _priceDecimals,
        uint8 _decimals
    ) internal pure returns (int256) {
        if (_priceDecimals < _decimals) {
            return _price * int256(10 ** uint256(_decimals - _priceDecimals));
        } else if (_priceDecimals > _decimals) {
            return _price / int256(10 ** uint256(_priceDecimals - _decimals));
        }
        return _price;
    }
}
```

[Open in Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/DataFeeds/PriceConverter.sol&autoCompile=true)[What is Remix?](/getting-started/conceptual-overview#what-is-remix)
## More aggregator functions
Getting the latest price is not the only data that aggregators can retrieve. You can also retrieve historical price data. To learn more, see the Historical Price Data page.

================================================================================

# Chainlink Data Streams

Source: https://docs.chain.link/data-streams
Extraction Method: playwright

# Chainlink Data Streams
[Image: note]Talk to an expert

Contact us to talk to an expert about integrating
Chainlink Data Streams with your applications.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }Chainlink Data Streams delivers low-latency market data offchain, which you can verify onchain. This approach provides decentralized applications (dApps) with on-demand access to high-frequency market data backed by decentralized, fault-tolerant, and transparent infrastructure.

Traditional push-based oracles update onchain data at set intervals or when certain price thresholds are met. In contrast, Chainlink Data Streams uses a pull-based design that preserves trust-minimization with onchain verification.

Data Streams are offered in several report formats, each designed for distinct asset classes.

## Sub-Second Data and Commit-and-Reveal
Chainlink Data Streams supports sub-second data resolution for latency-sensitive use cases by retrieving data only when needed. You can combine the data with any transaction in near real time. A "commit-and-reveal" approach mitigates frontrunning by making trade data and stream data visible atomically onchain.

## Comparison to push-based oracles
Chainlink's push-based oracles regularly publish price data onchain. By contrast, Chainlink Data Streams relies on a pull-based design, letting you retrieve a report and verify it onchain whenever you need it. Verification confirms that the decentralized oracle network (DON) agreed on and signed the data. Some applications only need onchain data at fixed intervals, which suits push-based oracles. However, others require higher-frequency updates and lower latency. Pull-based oracles meet these needs and still provide cryptographic guarantees about data accuracy.

astro-island,astro-slot,astro-static-slot{display:contents}(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).only=e;window.dispatchEvent(new Event("astro:only"));})();(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();[Image: Chainlink Data Streams - Push-Based vs Pull-Based Oracles]Push-based and pull-based oracles comparison

Pull-based oracles also operate more efficiently by retrieving data only when necessary. For example, a decentralized exchange might fetch a Data Streams report and verify it onchain only when a user executes a trade, rather than continuously pushing updates that might not be immediately used.

## Comprehensive market insights
Chainlink Data Streams offers price points such as mid prices and Liquidity-Weighted Bid and Ask (LWBA) for Crypto Streams. LWBA prices reflect current order book conditions, providing deeper insight into market liquidity and depth. With additional parameters, such as volatility and liquidity metrics, Data Streams helps protocols enhance trading accuracy, improve onchain risk management, and dynamically adjust margins or settlement conditions in response to real-time market shifts.

## High availability and resilient infrastructure
Data Streams API services use an active-active multi-site deployment model across multiple distributed and isolated origins. This architecture ensures continuous operations even if one origin fails, delivering robust fault tolerance and high availability.

## Example use cases
Access to low-latency, high-frequency data enables a variety of onchain applications:

• Perpetual Futures: Sub-second data and frontrunning mitigation allow onchain perpetual futures protocols to compete with centralized exchanges on performance while retaining transparency and decentralization.
• Options: Pull-based oracles provide timely settlement of options contracts with the added benefit of market liquidity data to support dynamic onchain risk management.
• Prediction Markets: High-frequency updates let participants act on real-time data, ensuring quick reactions to events and accurate settlement.

## Key capabilities

• Sub-second Latency: Pull data on-demand with minimal delay
• Cryptographic Verification: Verify data authenticity onchain when needed
• Multiple Access Methods: REST API, WebSocket, or SDK integration
• Comprehensive Market Data: Mid prices, LWBA prices, volatility, and liquidity metrics
• High Availability: Multi-site deployment ensures 99.9%+ uptime

## How to use Data Streams
You can access Chainlink Data Streams through SDKs and APIs, allowing you to build custom solutions with low-latency, high-frequency data. Fetch reports or subscribe to report updates from the Data Streams Aggregation Network and verify their authenticity onchain.

[Image: Chainlink Data Streams - On-Demand Offchain Workflows]Chainlink Data Streams - On-Demand Offchain Workflows

### Integration options
Access data directly through REST APIs or WebSocket connections using our SDKs:

• Go SDK - Full-featured SDK with comprehensive examples
• Rust SDK - High-performance SDK for Rust applications
• REST API or WebSocket - Direct access to Data Streams endpoints

### Getting started

1. Understand the Architecture: Review the system components and data flow to understand how Data Streams works.
2. Explore Available Data: Browse available reports and associated schemas to see what data is available.
3. Try the API: Follow our hands-on tutorial to fetch and decode your first report.
4. Implement Verification: Add onchain verification to ensure data authenticity in your smart contracts.

### Streams Trade: An alternative implementation
For applications that require automated data retrieval and execution, Streams Trade combines Chainlink Data Streams with Chainlink Automation to deliver automated trade execution with frontrunning mitigation. This approach suits dApps that require automated, trust-minimized trade execution and high-frequency market data.

Learn more about Streams Trade.

================================================================================

# Getting Started with Chainlink Data Streams (Remix)

Source: https://docs.chain.link/data-streams/getting-started
Extraction Method: playwright
Components: code_block(1)

# Getting Started with Chainlink Data Streams (Remix)

## Guide Versions
This guide is available in multiple versions. Choose the one that matches your needs.

Remix[Remix](/data-streams/tutorials/streams-trade/getting-started)[Hardhat](/data-streams/tutorials/streams-trade/getting-started-hardhat)function i(){const t=document.querySelector(".dropdown-trigger"),n=document.querySelector(".dropdown-content");!t||!n||(t.addEventListener("click",()=>{const e=t.getAttribute("aria-expanded")==="true";t.setAttribute("aria-expanded",(!e).toString()),n.setAttribute("data-visible",(!e).toString())}),document.addEventListener("click",e=>{t.contains(e.target)||(t.setAttribute("aria-expanded","false"),n.setAttribute("data-visible","false"))}))}window.addEventListener("load",i);const r=document.querySelector(".tabs-section"),d=document.querySelector(".tabs-header");r&&!d&&r.style.setProperty("--section-padding","1rem");[Image: note]Talk to an expert

Contact us to talk to an expert about integrating
Chainlink Data Streams with your applications.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }This guide shows you how to read data from a Data Streams stream, verify the answer onchain, and store it.

This example uses the Streams Trade implementation, with a Chainlink Automation Log Trigger to check for events that require data. For this example, the log trigger comes from a simple emitter contract. Chainlink Automation then uses StreamsLookup to retrieve a signed report from the Data Streams Aggregation Network, return the data in a callback, and run the performUpkeep function on your registered upkeep contract. The performUpkeep function calls the verify function on the verifier contract.

Note: To learn how to use Data Streams with the REST API or WebSocket, see the Fetch and decode reports via a REST API guide or the Stream and decode reports via WebSocket guide.

[Image: caution]Disclaimer

This guide represents an example of using a Chainlink product or service and is provided to help you understand how to
interact with Chainlink's systems and services so that you can integrate them into your own. This template is provided
"AS IS" and "AS AVAILABLE" without warranties of any kind, has not been audited, and may be missing key checks or
error handling to make the usage of the product more clear. Do not use the code in this example in a production
environment without completing your own audits and application of best practices. Neither Chainlink Labs, the
Chainlink Foundation, nor Chainlink node operators are responsible for unintended outputs that are generated due to
errors in code.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
## Before you begin

• Contact
us to request
mainnet or testnet access.
• If you are new to smart contract development, learn how to Deploy Your First Smart Contract so you are familiar with the tools that are necessary for this guide:

The Solidity programming language
The MetaMask wallet
The Remix development environment
• This guide requires testnet ETH and LINK on Arbitrum Sepolia. Both are available at faucets.chain.link.
• Learn how to Fund your contract with LINK.

## Tutorial

### Deploy the Chainlink Automation upkeep contract
Deploy an upkeep contract that is enabled to retrieve data from Data Streams. For this example, you will read from the ETH/USD stream on Arbitrum Sepolia. This stream ID is 0x000359843a543ee2fe414dc14c7e7920ef10f4372990b79d6361cdc0dd1ba782. See the Data Streams Crypto streams page for a complete list of available crypto assets.

1. Open the StreamsUpkeep.sol contract in Remix.

Open in Remix
What is Remix?
2. Select the StreamsUpkeep.sol contract in the Solidity Compiler tab.
3. Compile the contract. You can ignore the warning messages for this example.
4. Open MetaMask and set the network to Arbitrum Sepolia. If you need to add Arbitrum Sepolia to your wallet, you can find the chain ID and the LINK token contract address on the LINK Token Contracts page.

Arbitrum Sepolia testnet and LINK token contract
5. On the Deploy & Run Transactions tab in Remix, select Injected Provider - MetaMask in the Environment list. Remix will use the MetaMask wallet to communicate with Arbitrum Sepolia.
6. In the Contract section, select the StreamsUpkeep contract and fill in the Arbitrum Sepolia verifier proxy address: 0x2ff010DEbC1297f19579B4246cad07bd24F2488A. You can find the verifier proxy addresses on the Stream Addresses page.
7. Click the Deploy button to deploy the contract. MetaMask prompts you to confirm the transaction. Check the transaction details to ensure you deploy the contract to Arbitrum Sepolia.
8. After you confirm the transaction, the contract address appears under the Deployed Contracts list in Remix. Save this contract address for later.

### Deploy the emitter contract
This contract emits logs that trigger the upkeep. This code can be part of your dApp. For example, you might emit log triggers when your users initiate a trade or other action requiring data retrieval. For this Getting Started guide, use a very simple emitter so you can test the upkeep and data retrieval.

1. Open the LogEmitter.sol contract in Remix.

Open in Remix
What is Remix?
2. Under the Solidity Compiler tab, select the 0.8.19 Solidity compiler and click the Compile LogEmitter.sol button to compile the contract.
3. Open MetaMask and make sure the network is still set to Arbitrum Sepolia.
4. On the Deploy & Run Transactions tab in Remix, ensure the Environment is still set to Injected Provider - MetaMask.
5. Click the Deploy button to deploy the contract. MetaMask prompts you to confirm the transaction. Check the transaction details to ensure you deploy the contract to Arbitrum Sepolia.
6. After you confirm the transaction, the contract address appears in the Deployed Contracts list. Save this contract address for later.

### Register the upkeep
Register a new Log trigger upkeep. See Automation Log Triggers to learn more about how to register Log Trigger upkeeps.

1. Go to the Chainlink Automation UI for Arbitrum Sepolia and connect your browser wallet.
2. Click Register new Upkeep.
3. Select the Log trigger upkeep type and click Next.
4. Specify the upkeep contract address you saved earlier as the Contract to automate. In this example, you can ignore the warning about the Automation compatible contract verification. Click Next.
5. Specify the emitter contract address that you saved earlier. This tells Chainlink Automation what contracts to watch for log triggers. Then click Next.
6. Provide the ABI if the contract is not validated. To find the ABI of your contract in Remix, navigate to the Solidity Compiler tab. Then, copy the ABI to your clipboard using the button at the bottom of the panel.
7. Select the Log event as the triggering event in the Emitted log dropdown. Log index topic filters are optional filters to narrow the logs you want to trigger your upkeep. For this example, leave the field blank. Click Next.
8. Specify a name for the upkeep.
9. Specify a Starting balance of 1 testnet LINK for this example. You can retrieve unused LINK later.
10. Leave the Check data value and other fields blank for now, and click Register Upkeep. MetaMask prompts you to confirm the transaction. Wait for the transaction to complete.

### Fund the upkeep contract
In this example, the upkeep contract pays for onchain verification of reports from Data Streams. The Automation subscription does not cover the cost.

Open MetaMask and send 1 testnet LINK on Arbitrum Sepolia to the upkeep contract address you saved earlier.

[Image: Chainlink Data Streams Fund Deployed Upkeep]
### Emit a log
You can use your emitter contract to emit a log and initiate the upkeep, which retrieves data for the specified stream ID.

1. In Remix, on the Deploy & Run Transactions tab, expand your emitter contract under the Deployed Contracts section.
2. Click the emitLog button to call the function and emit a log. MetaMask prompts you to accept the transaction.

After the transaction is complete, the log is emitted, and the upkeep is triggered. You can find the upkeep transaction hash in the Chainlink Automation UI. Check to make sure the transaction is successful.

### View the retrieved price
The retrieved price is stored in the lastDecodedPrice storage variable.

1. On the Deploy & Run Transactions tab in Remix, expand the details of your upkeep contract in the Deployed Contracts section.
2. Click the lastDecodedPrice getter function to view the retrieved price. The answer on the ETH/USD stream uses 18 decimal places, so an answer of 248412100000000000 indicates an ETH/USD price of 2,484.121. Some streams may use a different number of decimal places for answers. See the Data Streams Crypto streams page for more information.

## Examine the code
The example code you deployed has all the interfaces and functions required to work with Chainlink Automation as an upkeep contract. It follows a similar flow to the trading flow in the Architecture documentation but uses a basic log emitter to simulate the client contract that would initiate a StreamsLookup. After the contract receives and verifies the report, performUpkeep stores the price from the report in the lastDecodedPrice variable. You could modify this to use the data in a way that works for your specific use case and application.

The code example uses revert with StreamsLookup to convey call information about what streams to retrieve. See the EIP-3668 rationale for more information about how to use revert in this way.

[Image: copy to clipboard]
```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import {Common} from "@chainlink/contracts/src/v0.8/llo-feeds/libraries/Common.sol";
import {StreamsLookupCompatibleInterface} from "@chainlink/contracts/src/v0.8/automation/interfaces/StreamsLookupCompatibleInterface.sol";
import {ILogAutomation, Log} from "@chainlink/contracts/src/v0.8/automation/interfaces/ILogAutomation.sol";
import {IRewardManager} from "@chainlink/contracts/src/v0.8/llo-feeds/v0.3.0/interfaces/IRewardManager.sol";
import {IVerifierFeeManager} from "@chainlink/contracts/src/v0.8/llo-feeds/v0.3.0/interfaces/IVerifierFeeManager.sol";
import {IERC20} from "@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/interfaces/IERC20.sol";

/**
 * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE FOR DEMONSTRATION PURPOSES.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

// Custom interfaces for IVerifierProxy and IFeeManager
interface IVerifierProxy {
    /**
     * @notice Verifies that the data encoded has been signed.
     * correctly by routing to the correct verifier, and bills the user if applicable.
     * @param payload The encoded data to be verified, including the signed
     * report.
     * @param parameterPayload Fee metadata for billing. For the current implementation this is just the abi-encoded fee token ERC-20 address.
     * @return verifierResponse The encoded report from the verifier.
     */
    function verify(
        bytes calldata payload,
        bytes calldata parameterPayload
    ) external payable returns (bytes memory verifierResponse);

    function s_feeManager() external view returns (IVerifierFeeManager);
}

interface IFeeManager {
    /**
     * @notice Calculates the fee and reward associated with verifying a report, including discounts for subscribers.
     * This function assesses the fee and reward for report verification, applying a discount for recognized subscriber addresses.
     * @param subscriber The address attempting to verify the report. A discount is applied if this address
     * is recognized as a subscriber.
     * @param unverifiedReport The report data awaiting verification. The content of this report is used to
     * determine the base fee and reward, before considering subscriber discounts.
     * @param quoteAddress The payment token address used for quoting fees and rewards.
     * @return fee The fee assessed for verifying the report, with subscriber discounts applied where applicable.
     * @return reward The reward allocated to the caller for successfully verifying the report.
     * @return totalDiscount The total discount amount deducted from the fee for subscribers
     */
    function getFeeAndReward(
        address subscriber,
        bytes memory unverifiedReport,
        address quoteAddress
    ) external returns (Common.Asset memory, Common.Asset memory, uint256);

    function i_linkAddress() external view returns (address);

    function i_nativeAddress() external view returns (address);

    function i_rewardManager() external view returns (address);
}

contract StreamsUpkeep is ILogAutomation, StreamsLookupCompatibleInterface {
    error InvalidReportVersion(uint16 version); // Thrown when an unsupported report version is provided to verifyReport.

    /**
     * @dev Represents a data report from a Data Streams stream for v3 schema (used for crypto and DEX State Price streams).
     * The `price`, `bid`, and `ask` values are carried to either 8 or 18 decimal places, depending on the stream.
     * `bid`, and `ask` values are not available for DEX State Price streams.
     * For more information, see https://docs.chain.link/data-streams/crypto-streams and https://docs.chain.link/data-streams/reference/report-schema
     */
    struct ReportV3 {
        bytes32 feedId; // The stream ID the report has data for.
        uint32 validFromTimestamp; // Earliest timestamp for which price is applicable.
        uint32 observationsTimestamp; // Latest timestamp for which price is applicable.
        uint192 nativeFee; // Base cost to validate a transaction using the report, denominated in the chain’s native token (e.g., WETH/ETH).
        uint192 linkFee; // Base cost to validate a transaction using the report, denominated in LINK.
        uint32 expiresAt; // Latest timestamp where the report can be verified onchain.
        int192 price; // DON consensus median price (8 or 18 decimals).
        int192 bid; // Simulated price impact of a buy order up to the X% depth of liquidity utilisation (8 or 18 decimals). Note: not available for DEX State Price streams.
        int192 ask; // Simulated price impact of a sell order up to the X% depth of liquidity utilisation (8 or 18 decimals). Note: not available for DEX State Price streams.
    }

    /**
     * @dev Represents a data report from a Data Streams stream for v4 schema (RWA streams).
     * The `price` value is carried to either 8 or 18 decimal places, depending on the stream.
     * The `marketStatus` indicates whether the market is currently open. Possible values: `0` (`Unknown`), `1` (`Closed`), `2` (`Open`).
     * For more information, see https://docs.chain.link/data-streams/rwa-streams and https://docs.chain.link/data-streams/reference/report-schema-v4
     */
    struct ReportV4 {
        bytes32 feedId; // The stream ID the report has data for.
        uint32 validFromTimestamp; // Earliest timestamp for which price is applicable.
        uint32 observationsTimestamp; // Latest timestamp for which price is applicable.
        uint192 nativeFee; // Base cost to validate a transaction using the report, denominated in the chain’s native token (e.g., WETH/ETH).
        uint192 linkFee; // Base cost to validate a transaction using the report, denominated in LINK.
        uint32 expiresAt; // Latest timestamp where the report can be verified onchain.
        int192 price; // DON consensus median benchmark price (8 or 18 decimals).
        uint32 marketStatus; // The DON's consensus on whether the market is currently open.
    }

    struct Quote {
        address quoteAddress;
    }

    IVerifierProxy public verifier;

    address public FEE_ADDRESS;
    string public constant DATASTREAMS_FEEDLABEL = "feedIDs";
    string public constant DATASTREAMS_QUERYLABEL = "timestamp";
    int192 public lastDecodedPrice;

    // This example reads the ID for the ETH/USD report.
    // Find a complete list of IDs at https://docs.chain.link/data-streams/crypto-streams.
    string[] public feedIds = [
        "0x000359843a543ee2fe414dc14c7e7920ef10f4372990b79d6361cdc0dd1ba782"
    ];

    constructor(address _verifier) {
        verifier = IVerifierProxy(_verifier);
    }

    // This function uses revert to convey call information.
    // See https://eips.ethereum.org/EIPS/eip-3668#rationale for details.
    function checkLog(
        Log calldata log,
        bytes memory
    ) external returns (bool upkeepNeeded, bytes memory performData) {
        revert StreamsLookup(
            DATASTREAMS_FEEDLABEL,
            feedIds,
            DATASTREAMS_QUERYLABEL,
            log.timestamp,
            ""
        );
    }

    /**
     * @notice this is a new, optional function in streams lookup. It is meant to surface streams lookup errors.
     * @return upkeepNeeded boolean to indicate whether the keeper should call performUpkeep or not.
     * @return performData bytes that the keeper should call performUpkeep with, if
     * upkeep is needed. If you would like to encode data to decode later, try `abi.encode`.
     */
    function checkErrorHandler(
        uint256 /*errCode*/,
        bytes memory /*extraData*/
    ) external pure returns (bool upkeepNeeded, bytes memory performData) {
        return (true, "0");
        // Hardcoded to always perform upkeep.
        // Read the StreamsLookup error handler guide for more information.
        // https://docs.chain.link/chainlink-automation/guides/streams-lookup-error-handler
    }

    // The Data Streams report bytes is passed here.
    // extraData is context data from stream lookup process.
    // Your contract may include logic to further process this data.
    // This method is intended only to be simulated offchain by Automation.
    // The data returned will then be passed by Automation into performUpkeep
    function checkCallback(
        bytes[] calldata values,
        bytes calldata extraData
    ) external pure returns (bool, bytes memory) {
        return (true, abi.encode(values, extraData));
    }

    // function will be performed onchain
    function performUpkeep(bytes calldata performData) external {
        // Decode the performData bytes passed in by CL Automation.
        // This contains the data returned by your implementation in checkCallback().
        (bytes[] memory signedReports, bytes memory extraData) = abi.decode(
            performData,
            (bytes[], bytes)
        );

        bytes memory unverifiedReport = signedReports[0];

        (, /* bytes32[3] reportContextData */ bytes memory reportData) = abi
            .decode(unverifiedReport, (bytes32[3], bytes));

        // Extract report version from reportData
        uint16 reportVersion = (uint16(uint8(reportData[0])) << 8) |
            uint16(uint8(reportData[1]));

        // Validate report version
        if (reportVersion != 3 && reportVersion != 4) {
            revert InvalidReportVersion(uint8(reportVersion));
        }

        // Report verification fees
        IFeeManager feeManager = IFeeManager(address(verifier.s_feeManager()));
        IRewardManager rewardManager = IRewardManager(
            address(feeManager.i_rewardManager())
        );

        address feeTokenAddress = feeManager.i_linkAddress();
        (Common.Asset memory fee, , ) = feeManager.getFeeAndReward(
            address(this),
            reportData,
            feeTokenAddress
        );

        // Approve rewardManager to spend this contract's balance in fees
        IERC20(feeTokenAddress).approve(address(rewardManager), fee.amount);

        // Verify the report
        bytes memory verifiedReportData = verifier.verify(
            unverifiedReport,
            abi.encode(feeTokenAddress)
        );

        // Decode verified report data into the appropriate Report struct based on reportVersion
        if (reportVersion == 3) {
            // v3 report schema
            ReportV3 memory verifiedReport = abi.decode(
                verifiedReportData,
                (ReportV3)
            );

            // Store the price from the report
            lastDecodedPrice = verifiedReport.price;
        } else if (reportVersion == 4) {
            // v4 report schema
            ReportV4 memory verifiedReport = abi.decode(
                verifiedReportData,
                (ReportV4)
            );

            // Store the price from the report
            lastDecodedPrice = verifiedReport.price;
        }
    }
}
```

[Open in Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/DataStreams/StreamsUpkeep.sol&autoCompile=true)[What is Remix?](/getting-started/conceptual-overview#what-is-remix)
### Initializing the upkeep contract
When you deploy the contract, you define the verifier proxy address. You can find this address on the Stream Addresses page. The IVerifierProxy interface provides the following functions:

• The s_feeManager function to estimate the verification fees.
• The verify function to verify the report onchain.

### Emitting a log, retrieving, and verifying the report
After registering your upkeep contract with Chainlink Automation with a log trigger, you can emit a log with the emitLog function from your emitter contract.

1. The emitted log triggers the Chainlink Automation upkeep.
2. Chainlink Automation then uses StreamsLookup to retrieve a signed report from the Data Streams Aggregation Network, returns the data in a callback (checkCallback), and runs the performUpkeep function on your registered upkeep contract.
3. The performUpkeep function calls the verify function on the verifier contract to verify the report onchain.
4. In this example, the performUpkeep function also stores the price from the report in the lastDecodedPrice state variable.

### Viewing the retrieved price
The lastDecodedPrice getter function of your upkeep contract retrieves the last price stored by the performUpkeep function in the lastDecodedPrice state variable of the StreamsUpkeep contract.

### Feed ID types and conversion
Chainlink Data Streams uses different data types for feed IDs at different stages of the process:

• The StreamsLookup error requires feed IDs to be provided as an array of string,
• The decoded reports within the contract use bytes32 types for feed IDs (see the Report Schemas reference).

If your application needs to compare the feed ID(s) sent in the StreamsLookup with those received in the report(s), you must convert between string and bytes32 types.

### Optional: Handle Data Streams fetching errors offchain with checkErrorHandler
When Automation detects the triggering event, it runs the checkLog function of your upkeep contract, which includes a StreamsLookup revert custom error. The StreamsLookup revert enables your upkeep to fetch a report from the Data Streams Aggregation Network. If the report is fetched successfully, the checkCallback function is evaluated offchain. Otherwise, the checkErrorHandler function is evaluated offchain to determine what Automation should do next.

In this example, the checkErrorHandler is set to always return true for upkeepNeeded. This implies that the upkeep is always triggered, even if the report fetching fails. You can modify the checkErrorHandler function to handle errors offchain in a way that works for your specific use case. Read more about using the StreamsLookup error handler.

================================================================================

# Data Streams Billing

Source: https://docs.chain.link/data-streams/billing
Extraction Method: playwright

# Data Streams Billing
[Image: note]Talk to an expert

Contact us to talk to an expert about
integrating Chainlink Data Streams with your applications.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }Chainlink Data Streams offers two billing models:

1. Subscription model: A subscription-based billing option.
2. Pay-per-report model: You pay to verify reports from Data Streams onchain using the verifier contract. You pay per report verified. If you verify multiple reports in a batch, you pay for all of the reports included in that batch.
The verification price is 0.35 USD per report. Chainlink Data Streams supports fee payments in LINK and in alternative assets, which currently includes native blockchain gas tokens and their ERC20-wrapped version. Payments made in alternative assets have a 10% surcharge when compared to LINK payments.

Contact us to learn more about Mainnet pricing and subscription options.

================================================================================

# Data Streams Crypto streams

Source: https://docs.chain.link/data-streams/stream-ids
Extraction Method: playwright
Components: table(3)

# Data Streams Crypto streams
To learn how to use Data Streams, see the Fetch and decode reports tutorial.

For LINK token and Faucet details, see the LINK Token Contracts page.

[Image: note]Talk to an expert

Contact us to talk to an
              expert about integrating Chainlink Data Streams with your applications.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
## Streams Verifier Network Addresses

Network |  | Verifier Proxy Address
--- | --- | ---
0G | 0G Aristotle (Mainnet) | 0x2e6621e5e3F916d5e512124dD79e06b55E258054
 | 0G Galileo (Testnet) | 0x7C8bf15e7d4d44AB1b29F0aC047600295111de4c
View 0G Network Status →
Apechain | Apechain Mainnet | 0x2e6621e5e3F916d5e512124dD79e06b55E258054
 | Apechain Curtis (Testnet) | 0x9D93c410AfDb41E8aEb1BA88B5Ff6DEAa09FF537
View Apechain Network Status →
Arbitrum | Arbitrum Mainnet | 0x478Aa2aC9F6D65F84e09D9185d126c3a17c2a93C
 | Arbitrum Sepolia | 0x2ff010DEbC1297f19579B4246cad07bd24F2488A
View Arbitrum Network Status →
Avalanche | Avalanche Mainnet | 0x79BAa65505C6682F16F9b2C7F8afEBb1821BE3f6
 | Avalanche Fuji Testnet | 0x2bf612C65f5a4d388E687948bb2CF842FFb8aBB3
View Avalanche Network Status →
Base | Base Mainnet | 0xDE1A28D87Afd0f546505B28AB50410A5c3a7387a
 | Base Sepolia | 0x8Ac491b7c118a0cdcF048e0f707247fD8C9575f9
View Base Network Status →
Berachain | Berachain Mainnet | 0xC539169910DE08D237Df0d73BcDa9074c787A4a1
 | Berachain bArtio Testnet | 0x5A1634A86e9b7BfEf33F0f3f3EA3b1aBBc4CC85F
View Berachain Network Status →
Bitlayer | Bitlayer Mainnet | 0x6FDC15cad4f90a037B7126D7EFff105A9d03D6e7
 | Bitlayer Testnet | 0x57A97148C1fa50f35F0639f380077017D8893b6b
View Bitlayer Network Status →
Blast | Blast Mainnet | 0xaB93491064aEE774BE4b8a1cFFe4421F5B124F4e
 | Blast Sepolia Testnet | 0x141f4278A5D71070Dc09CA276b72809b80F20eF0
View Blast Network Status →
BNB Chain | BNB Chain Mainnet | 0xF276a4BC8Da323EA3E8c3c195a4E2E7615a898d1
 | BNB Chain Testnet | 0xF45D6dba93d0dB2C849C280F45e60D6e11b3C4DD
View BNB Chain Network Status →
Bob | Bob Mainnet | 0xF45D6dba93d0dB2C849C280F45e60D6e11b3C4DD
 | Bob Sepolia Testnet | 0x60fAa7faC949aF392DFc858F5d97E3EEfa07E9EB
View Bob Network Status →
Botanix | Botanix Mainnet | 0xC539169910DE08D237Df0d73BcDa9074c787A4a1
 | Botanix Testnet | 0xfBFff08fE4169853F7B1b5Ac67eC10dc8806801d
View Botanix Network Status →
Celo | Celo Mainnet | 0x57A97148C1fa50f35F0639f380077017D8893b6b
 | Celo Testnet Alfajores | 0xfa58eE98c9d56A3e6e903f300BE8C60Bf031808D
View Celo Network Status →
Ethereum | Ethereum Mainnet | 0x5A1634A86e9b7BfEf33F0f3f3EA3b1aBBc4CC85F
 | Sepolia Testnet | 0x4e9935be37302B9C97Ff4ae6868F1b566ade26d2
View Ethereum Network Status →
Gnosis | Gnosis Mainnet | 0x60fAa7faC949aF392DFc858F5d97E3EEfa07E9EB
 | Gnosis Chiado | 0x60fAa7faC949aF392DFc858F5d97E3EEfa07E9EB
View Gnosis Network Status →
Gravity | Gravity Alpha Mainnet | 0x60fAa7faC949aF392DFc858F5d97E3EEfa07E9EB
 | Gravity Alpha Testnet Sepolia | 0x60fAa7faC949aF392DFc858F5d97E3EEfa07E9EB
View Gravity Network Status →
HashKey Chain | HashKey Chain Mainnet | 0x3278e7a582B94d82487d4B99b31A511CbAe2Cd54
 | HashKey Chain Testnet | 0xE02A72Be64DA496797821f1c4BB500851C286C6c
View HashKey Chain Network Status →
HyperEVM | HyperEVM Mainnet | 0x60fAa7faC949aF392DFc858F5d97E3EEfa07E9EB
 | HyperEVM Testnet | 0x60fAa7faC949aF392DFc858F5d97E3EEfa07E9EB
View HyperEVM Network Status →
Ink | Ink Mainnet | 0x60fAa7faC949aF392DFc858F5d97E3EEfa07E9EB
 | Ink Sepolia Testnet | 0x1f27392cC2394d54fFBA83B89C881200b5d5632C
View Ink Network Status →
Jovay | Jovay Mainnet | 0x57a97148c1fa50f35f0639f380077017d8893b6b
 | Jovay Sepolia Testnet | 0x60faa7fac949af392dfc858f5d97e3eefa07e9eb
View Jovay Network Status →
Katana | Katana Mainnet | 0x2a644E5AC685112A7Eff0c4d73CD0260546D366F
 | Katana Testnet (Tatara) | 0x57A97148C1fa50f35F0639f380077017D8893b6b
View Katana Network Status →
Lens | Lens Mainnet | 0xD9A79903359B4Dedf3a9c26AB47D4a8Fc62A70A2
 | Lens Testnet | 0x5c0a4924535667ee025dDA78fCb0F213664927d5
View Lens Network Status →
Linea | Linea Mainnet | 0x60fAa7faC949aF392DFc858F5d97E3EEfa07E9EB
 | Linea Sepolia Testnet | 0x60fAa7faC949aF392DFc858F5d97E3EEfa07E9EB
View Linea Network Status →
Mantle | Mantle Mainnet | 0x223752Eb475098e79d10937480DF93864D7EfB83
 | Mantle Sepolia Testnet | 0xdc458847982C496E1a5E25D005A332D5a838302B
View Mantle Network Status →
MegaETH | MegaETH Testnet | 0xfBFff08fE4169853F7B1b5Ac67eC10dc8806801d
View MegaETH Network Status →
Metis | Metis Andromeda Mainnet | 0xC539169910DE08D237Df0d73BcDa9074c787A4a1
 | Metis Sepolia Testnet | 0xcFC9A8Efad365B04253575326f6A9bcDD8131Eb7
View Metis Network Status →
Monad | Monad Testnet | 0xC539169910DE08D237Df0d73BcDa9074c787A4a1
opBNB | opBNB Mainnet | 0x7D543D1a715ED544f7e3Ae9e3b1777BCdA56bF8e
 | opBNB Testnet | 0x001225Aca0efe49Dbb48233aB83a9b4d177b581A
View opBNB Network Status →
OP | OP Mainnet | 0xEBA4789A88C89C18f4657ffBF47B13A3abC7EB8D
 | OP Sepolia | 0x5f64394a2Ab3AcE9eCC071568Fc552489a8de7AF
View OP Network Status →
Polygon | Polygon Mainnet | 0xF276a4BC8Da323EA3E8c3c195a4E2E7615a898d1
 | Polygon Amoy Testnet | 0x60fAa7faC949aF392DFc858F5d97E3EEfa07E9EB
View Polygon Network Status →
Plasma | Plasma Mainnet | 0xB4626C56c8d66b09adC57e38a5A15CcCd51BE082
 | Plasma Testnet | 0x60fAa7faC949aF392DFc858F5d97E3EEfa07E9EB
View Plasma Network Status →
Ronin | Ronin Mainnet | 0x499Ce6718a50e154B0C69905eEE8D307e5B003cc
 | Ronin Saigon Testnet | 0xE02A72Be64DA496797821f1c4BB500851C286C6c
View Ronin Network Status →
Scroll | Scroll Mainnet | 0x37e550C9b35DB56F9c943126F1c2642fcbDF7B51
 | Scroll Sepolia Testnet | 0xE17A7C6A7c2eF0Cb859578aa1605f8Bc2434A365
View Scroll Network Status →
Sei | Sei Mainnet | 0x60fAa7faC949aF392DFc858F5d97E3EEfa07E9EB
 | Sei Testnet | 0x60fAa7faC949aF392DFc858F5d97E3EEfa07E9EB
View Sei Network Status →
Shibarium | Shibarium Mainnet | 0xBE9f07f73de2412A9d0Ed64C42De7d9A10C9F28C
 | Shibarium Puppynet | 0xc44eb6c00A0F89D044279cD91Bdfd5f62f752Da3
View Shibarium Network Status →
Soneium | Soneium Mainnet | 0x8760535A80Ac5908096B57A094266866f4aA1A8c
 | Soneium Minato Testnet | 0x26603bAC5CE09DAE5604700B384658AcA13AD6ae
View Soneium Network Status →
Sonic | Sonic Mainnet | 0xfBFff08fE4169853F7B1b5Ac67eC10dc8806801d
 | Sonic Blaze Testnet | 0xfBFff08fE4169853F7B1b5Ac67eC10dc8806801d
View Sonic Network Status →
Solana | Solana Mainnet | Verifier Program ID:Gt9S41PtjR58CbG9JhJ3J6vxesqrNAswbWYbLNTMZA3cAccess Controller:7mSn5MoBjyRLKoJShgkep8J17ueGG8rYioVAiSg5YWMF
 | Solana Devnet | Verifier Program ID:Gt9S41PtjR58CbG9JhJ3J6vxesqrNAswbWYbLNTMZA3cAccess Controller:2k3DsgwBoqrnvXKVvd7jX7aptNxdcRBdcd5HkYsGgbrb
View Solana Network Status →
Taiko | Taiko Alethia (Mainnet) | 0x60fAa7faC949aF392DFc858F5d97E3EEfa07E9EB
 | Taiko Hekla (Testnet) | 0xF45D6dba93d0dB2C849C280F45e60D6e11b3C4DD
View Taiko Network Status →
Unichain | Unichain Mainnet | 0x60fAa7faC949aF392DFc858F5d97E3EEfa07E9EB
 | Unichain Sepolia Testnet | 0x60fAa7faC949aF392DFc858F5d97E3EEfa07E9EB
View Unichain Network Status →
World Chain | World Chain Mainnet | 0x6733e9106094b0C794e8E0297c96611fF60460Bf
 | World Chain Sepolia Testnet | 0xd61ceB4521453F147C58d22879B4ec539331F851
View World Chain Network Status →
ZKSync | ZKSync Era Mainnet | 0xcA64d9D1a9AE4C10E94D0D45af9E878fc64dc207
 | ZKSync Sepolia Testnet | 0xDf37875775d1E777bB413f27de093A62CFF4264b
View ZKSync Network Status →

## Mainnet Crypto Streams
Show DEX State Price streams
Stream | Details
--- | ---
0G/USD | 0x0003242d01a117767fb02954edb3fa22523785423ba8690f682cb599530bb2b4Full name:0G/USD-Streams-CexPrice-DS-Premium-Global-003Asset name:Zero GravityAsset class:CryptoMarket hours:CryptoDecimals:18Report Schema:Crypto Schema (v3)
1INCH/USD | 0x0003fb80bf0e043e7bcc6e9808c9f62e722117afddb2b760ad6c58f6cc614444Full name:1INCH/USD-RefPrice-DS-Premium-Global-003Asset name:1inch NetworkAsset class:CryptoMarket hours:CryptoDecimals:18Report Schema:Crypto Schema (v3)
AAPLx/USD | 0x0003c9c629e12c36e7befe79001ef7042623f9e5b6e455bb5720f54df716dfe2Full name:AAPLx/USD-Streams-CexPrice-DS-Premium-Global-003Asset name:Apple xStockAsset class:CryptoMarket hours:CryptoDecimals:18Report Schema:Crypto Schema (v3)
AAVE/USD | 0x0003481a2f7fe21c01d427f39035541d2b7a53db9c76234dc36082e6ad6db7f5Full name:AAVE/USD-RefPrice-DS-Premium-Global-003Asset name:AAVEAsset class:CryptoMarket hours:CryptoDecimals:18Report Schema:Crypto Schema (v3)
ACE/USD | 0x000306560d458ac3d101b500e0dd3e4a17e2f41065839e2182f8fd9f74a5a84cFull name:ACE/USD-RefPrice-DS-Premium-Global-003Asset name:FusionistAsset class:CryptoMarket hours:CryptoDecimals:18Report Schema:Crypto Schema (v3)
ADA/USD | 0x00038580225b924c69e28ea101d4723d90c1b44ab83548a995c3d86ad9e92eb0Full name:ADA/USD-RefPrice-DS-Premium-Global-003Asset name:CardanoAsset class:CryptoMarket hours:CryptoDecimals:18Report Schema:Crypto Schema (v3)
AERO/USD | 0x00038458999fd77d9deece17154ee687193b328cf7a53670501dd8ccad906ff6Full name:AERO/USD-RefPrice-DS-Premium-Global-003Asset name:Aerodrome FinanceAsset class:CryptoMarket hours:CryptoDecimals:18Report Schema:Crypto Schema (v3)
AEVO/USD | 0x00032b4e4b9c9c2aa5a3675628ed71e7682c50b11fe6c7df4cb625510f7732aaFull name:AEVO/USD-RefPrice-DS-Premium-Global-003Asset name:AevoAsset class:CryptoMarket hours:CryptoDecimals:18Report Schema:Crypto Schema (v3)

PrevShowing 1 to 8 of 320 entries

Next
## Testnet Crypto Streams
Show DEX State Price streams
Stream | Details
--- | ---
0G/USD | 0x000357e0d1bedf1b616eb81c6094dae393f61a044cf56c073c4eeede96a62e36Asset name:Zero GravityAsset class:CryptoMarket hours:CryptoDecimals:18Report Schema:Crypto Schema (v3)
1INCH/USD | 0x00039e3a2f120539378fe688b38581a5740cfa1db8d7df9e5aa58dade9bde8a2Asset name:1inch NetworkAsset class:CryptoMarket hours:CryptoDecimals:18Report Schema:Crypto Schema (v3)
AAPLx/USD | 0x0003f62c69d2860bc657cdbe354b9c301ed695dc5b0ae3f64b72571c7e917dcfAsset name:Apple xStockAsset class:CryptoMarket hours:CryptoDecimals:18Report Schema:Crypto Schema (v3)
AAVE/USD | 0x0003c8e550d2fc5304993010112de9b69798297e4cc11990ee6250e464daf760Asset name:AAVEAsset class:CryptoMarket hours:CryptoDecimals:18Report Schema:Crypto Schema (v3)
ACE/USD | 0x0003eae0c3b5d771005374779c42de0f5dbacc1f940c86e205557a05c6c7103fAsset name:FusionistAsset class:CryptoMarket hours:CryptoDecimals:18Report Schema:Crypto Schema (v3)
ADA/USD | 0x00033470b2bb164a50c5a6fda879ddabcf8fb91fcfca048ac81a6bd5763fa1e3Asset name:CardanoAsset class:CryptoMarket hours:CryptoDecimals:18Report Schema:Crypto Schema (v3)
AERO/USD | 0x00033cf9f3040c301dcbfbf6d2827e49dc78e361b947eefe2dd870c86b950ca9Asset name:Aerodrome FinanceAsset class:CryptoMarket hours:CryptoDecimals:18Report Schema:Crypto Schema (v3)
AEVO/USD | 0x00034eff2911861c2f4a9465862ce553a98657d2097246857d24b989c95064f0Asset name:AevoAsset class:CryptoMarket hours:CryptoDecimals:18Report Schema:Crypto Schema (v3)

PrevShowing 1 to 8 of 297 entries

Next

================================================================================

# Chainlink Automation

Source: https://docs.chain.link/chainlink-automation
Extraction Method: playwright

# Chainlink Automation
[Image: note]Get Started

Try Chainlink Automation in the Getting Started guide.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }[Image: caution]Deprecation of older upkeeps

The only supported Automation registries are v2.1 and later. Migrate your older
upkeeps if you need them to be performed. Unmigrated upkeeps on
registries earlier than v2.1 will not be performed anymore, and you will see a "deprecated" notice in the Chainlink
Automation App.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }Automate your smart contracts using a secure and hyper-reliable decentralized network that uses the same external network of node operators that secures billions in value. Building on Chainlink Automation will accelerate your innovation, save you time and money, and help you get to market faster so you don't have to deal with the setup cost, ongoing maintenance, and risks associated with a centralized automation stack.

To learn more about how the Chainlink Automation Network automates your smart contracts, visit the Concepts and Architecture pages. You can also learn more through our additional Automation resources.

astro-island,astro-slot,astro-static-slot{display:contents}(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).only=e;window.dispatchEvent(new Event("astro:only"));})();(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();
## Supported networks and costs
For a list of blockchains that are supported by Chainlink Automation, see the Supported Networks page. To learn more about the cost of using Chainlink Automation, see the Automation Economics page.

## Contact us
For help with your specific use case, contact us to connect with one of our Solutions Architects. You can also ask questions about Chainlink Automation on Stack Overflow or the #automation channel in our Discord server. For all developers resources, check out the Developer Resource Hub.

================================================================================

# Getting Started with Chainlink Automation

Source: https://docs.chain.link/chainlink-automation/overview/getting-started
Extraction Method: playwright

# Getting Started with Chainlink Automation
Chainlink Automation will reliably execute smart contract functions using a variety of triggers. Explore the examples below to see how Chainlink Automation works for each type of trigger. Before you begin, you will need an active cryptocurrency wallet such as Metamask.

• Time-based trigger: Use a time-based trigger to execute your function according to a time schedule.
• Custom logic trigger: Use a custom logic trigger to provide custom solidity logic that Automation Nodes evaluate (offchain) to determine when to execute your function onchain.
• Log trigger: Use log data as both trigger and input.

## Try out Chainlink Automation
Click the tabs below to use Chainlink Automation with each type of trigger:

(()=>{var a=(s,i,o)=>{let r=async()=>{await(await s())()},t=typeof i.value=="object"?i.value:void 0,c={rootMargin:t==null?void 0:t.rootMargin},n=new IntersectionObserver(e=>{for(let l of e)if(l.isIntersecting){n.disconnect(),r();break}},c);for(let e of o.children)n.observe(e)};(self.Astro||(self.Astro={})).visible=a;window.dispatchEvent(new Event("astro:visible"));})();Custom LogicLog TriggerTime-basedIncrement a counter using custom logic stored onchain.

1. Navigate to the Chainlink Automation app and connect to Arbitrum Sepolia in the top dropdown menu.
2. Connect your cryptocurrency wallet to the app if you haven't done so already. You might also need to fetch LINK for the Arbitrum Sepolia testnet from faucets.chain.link.
3. Click Register new Upkeep and select Custom logic trigger.
4. Under Target contract address, enter 0x6C0AAAeBcDb6F5D03759B8BF14b47BE491755530. This contract is an Automation-compatible contract that uses logic stored onchain and onchain state to determine when to increment a counter. View the source code here. Click Next.
5. Enter an Upkeep name, your public key address under Admin Address, 500000 under Gas limit, and 0.1 under Starting balance (LINK).
6. Finally, enter your public key address under Check data (Hexadecimal). checkData is optional static data that you can pass into your upkeep to ensure your counter increments.
7. Click Register Upkeep.
8. After the transaction is complete, you can view the performs for your upkeep in the upkeep details. Your upkeep should perform once every minute and stop after 4 performs.

You have successfully automated your first custom logic upkeep. To learn more about creating custom logic upkeeps, read here.

Increment an onchain counter using a log as trigger.

1. Navigate to the Chainlink Automation app and connect to Arbitrum Sepolia in the top dropdown menu.
2. Connect your cryptocurrency wallet to the app if you haven't done so already. You might also need to fetch LINK for the Arbitrum Sepolia testnet from faucets.chain.link.
3. Click Register new Upkeep and select Log trigger.
4. Under Contract to automate, enter 0xe817e4A71C69C72C01B31906F9F8591FbaB6b448. This is a simple iLogAutomation-compatible example contract that increments a counter when a log is detected. View the source code here. Click Next.
5. Under Contract emitting logs, enter 0x1260206b960bB07F12d48C19fad505CeFc071bDd. This is the contract Automation will listen to for emitted logs. View the source code here. Click Next.
6. Under Emitted log select Bump from the dropdown menu. This is the log signature Automation will look for.
7. Log index topic filters are optional filters to narrow the logs you want to trigger your upkeep. For this example, enter your public key address under addr and leave the num field empty. Later when you call the bump function to emit the log, your msg.Sender address will be emitted in the log, triggering your upkeep. Click Next.
8. Enter an Upkeep name, your public key address under Admin Address, 500000 under Gas limit, and 0.1 under Starting balance (LINK).
9. Click Register Upkeep and wait for the transaction to complete.
10. To trigger your upkeep call bump on the trigger contract by navigating to the Arbitrum Sepolia scanner, connecting your wallet and executing the bump function. You can observe your upkeep's perform in the Automation dashboard.

You have successfully automated your first log trigger upkeep. To learn more about creating log trigger upkeeps, read here.

Increment a counter every 5 minutes using our example contract.

1. Navigate to the Chainlink Automation app and connect to Arbitrum Sepolia in the top dropdown menu.
2. Connect your cryptocurrency wallet to the app if you haven't done so already. You may also need to fetch Arbitrum Sepolia testnet LINK here.
3. Click Register new Upkeep and select Time-based trigger.
4. Under Target contract address, enter 0x083935210524c0A8922ec610d1063Aa0A54d9d70. This is a simple counter contract that increments with each call. View the source code here.
5. In the Contract call section, enter addInteger under Target function. In the Function inputs section, enter a number to increment by under intToAdd. Then click Next.
6. Specify the time schedule, for example every 5 minutes. Paste the cron expression */5 * * * * under Cron expression or select one of the example timers. Then click Next.
7. To learn more about CRON expressions, click here.
8. Enter an Upkeep name, your public key address under Admin Address, 500000 under Gas limit, and 0.1 under Starting balance (LINK).
9. Click Register Upkeep.
10. After the transaction has completed, you can view the performs for your upkeep in the upkeep details.

You have successfully automated your first time-based upkeep. To learn more about creating time-based upkeeps, read here.

## Supported networks and costs
For a list of blockchains that are supported by Chainlink Automation, see the Supported Networks page. To learn more about the cost of using Chainlink Automation, see the Automation Economics page.

## Contact us
For help with your specific use case, contact us to connect with one of our Solutions Architects. You can also ask questions about Chainlink Automation on Stack Overflow or the #automation channel in our Discord server. Utility contracts can also help you get started quickly.

================================================================================

# Automation Billing and Costs

Source: https://docs.chain.link/chainlink-automation/overview/automation-economics
Extraction Method: playwright
Components: table(1)

# Automation Billing and Costs

## Cost of using Chainlink Automation
Chainlink Automation requires only an execution fee for transactions onchain. This fee includes the transaction cost, a node operator percentage fee, and a small fixed gas overhead accounting for gas between the network and the registry.
The percentage fee compensates the Automation Network for monitoring and performing your upkeep. The Automation percentage fee varies by chain and is listed on our Supported Networks page.

The fee calculation for upkeeps that are configured for LINK payments (or other non-native payments as applicable) have a conversion from native tokens to LINK (or other non-native payments as applicable).
This conversion is not performed in the fee calculation for upkeeps that are configured for native token payments. Otherwise, the fee formula is the same for both payment types:

astro-island,astro-slot,astro-static-slot{display:contents}(()=>{var a=(s,i,o)=>{let r=async()=>{await(await s())()},t=typeof i.value=="object"?i.value:void 0,c={rootMargin:t==null?void 0:t.rootMargin},n=new IntersectionObserver(e=>{for(let l of e)if(l.isIntersecting){n.disconnect(),r();break}},c);for(let e of o.children)n.observe(e)};(self.Astro||(self.Astro={})).visible=a;window.dispatchEvent(new Event("astro:visible"));})();(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();LINKNative tokensFormula for Registry v2.3

FeeLINK = [tx.gasPriceNative WEI * gasUsed * (1 + premium%) + (gasOverhead * tx.gasPriceNative WEI)]/[LINK/NativeRate in WEI]

Formula for Registry v2.3

FeeNative = tx.gasPriceNative WEI * gasUsed * (1 + premium%) + (gasOverhead * tx.gasPriceNative WEI)

There is no registration fee or other fees for any offchain computation.

[Image: note]Additional fees for specific cases

On Automation v2.3 and earlier, there is an additional flat per-transaction fee of 0.01 LINK in the following cases:

• For testnet transactions on all supported networks to account for node infrastructure costs.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
### Fee calculation example
An upkeep transaction was performed on Polygon mainnet. It used 110,051 gas at a gas price of 182,723,799,380 wei.
The node operator percentage on Polygon was 70% at the time of this transaction, and this fee varies by network.

The tables below show how the fees are calculated for upkeeps configured for LINK payments:

The LINK/MATIC exchange rate for this transaction was 7,308,290,731,273,610,000 wei. The upkeep's LINK balance was reduced by a fee of 0.008077 LINK. The preceding information and calculation can be found in the table below:

Variable | Description | Value
--- | --- | ---
tx.gasPriceNative WEI | Gas price of the transaction | 182, 723, 799,380
gasUsed | Gas used for performUpkeep calculated in solidity | 110,051
gasOverhead | Fixed gas amount used for transaction call from node to Registry | 80,000
premium% | Current premium on Polygon which can be found on the Supported Networks page | 70%
LINK/NativeRate in WEI | Exchange rate fetched from Chainlink Oracle | 7,308,290,731,273,610,000

0.008077 = [182,723,799,380 * (110,051 + 80,000) * (1 + 70%)]/[7,308,290,731,273,610,000]

## How funding works
Upkeeps have a LINK (ERC-677) balance. Every time an onchain transaction is performed for your upkeep, its LINK balance will be reduced by the LINK fee.

Your upkeep's balance must exceed the minimum balance. If this requirement is not met, the Automation Network will not perform onchain transactions. You can add funds using the Chainlink Automation App or by directly calling the addFunds() function on the AutomationRegistry contract. Anyone can call the addFunds() function.

## Withdrawing funds
To withdraw a LINK balance, you must cancel your upkeep first. Any upkeep that has not spent more than an aggregated amount of 0.1 LINK fees over the span of its lifetime is subject to a 0.1 LINK fee. This cancellation fee protects node operators from spammers who register jobs that never perform.

Example 1: Your upkeep has spent 4.8 LINK over its lifetime and has a balance of 5 LINK. When it is cancelled, I will receive 5 LINK.
Example 2: Your upkeep has spent 0 LINK over its lifetime and has a balance of 5 LINK. When it is cancelled, I will receive 4.9 LINK.

## No node competition
Individual Automation Nodes do not compete with one another, but rather work together to ensure all registered upkeeps are performed. This makes costs more predictable upfront, enabling you to estimate costs based on the expected gas consumption.

## Minimum balance
The Chainlink Automation Network is designed to perform your upkeep even when gas prices spike. The minimum balance in LINK reflects the best estimate of the cost to perform your upkeep when gas prices spike. To ensure your upkeep is monitored and performed, ensure that your upkeep's balance is above this minimum balance.

The minimum balance is calculated using the current fast gas price, the gas limit you entered for your upkeep, the max gas multiplier, and the LINK/NativeRate in WEI for conversion to LINK. To find the latest value for the gasCeilingMultiplier, see the Registry Configuration page.

Follow maintain a minimum balance to ensure that your upkeep is funded.

## Price selection and gas bumping
Automation Nodes select the gas price dynamically based on the prices of transactions within the last several blocks. This optimizes the gas price based on current network conditions. Automation Nodes are configured to select a price based on a target percentile.

If the Automation Node does not see the performUpkeep transaction get confirmed within the next few blocks, it automatically replaces the transaction and bumps the gas price. This process repeats until the transaction is confirmed.

## ERC-677 LINK
For funding on mainnet, you will need ERC-677 LINK. Many token bridges give you ERC-20 LINK tokens. Use PegSwap to convert Chainlink tokens (LINK) to be ERC-677 compatible. Use faucets.chain.link to get testnet LINK.

================================================================================

# Supported Networks

Source: https://docs.chain.link/chainlink-automation/overview/supported-networks
Extraction Method: playwright
Components: table(22)

# Supported Networks
[Image: caution]Deprecation of older upkeeps

The only supported Automation registries are v2.1 and later. Migrate your older
upkeeps if you need them to be performed. Unmigrated upkeeps on
registries earlier than v2.1 will not be performed anymore, and you will see a "deprecated" notice in the Chainlink
Automation App.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }astro-island,astro-slot,astro-static-slot{display:contents}(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).only=e;window.dispatchEvent(new Event("astro:only"));})();(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();To use Chainlink Automation on certain networks, you may need to conduct token transfers. You can transfer tokens by using Chainlink CCIP, Transporter or third-party applications such as XSwap.

[Image: note]Interfaces and Applications

Chainlink CCIP is a messaging protocol. Third parties may build user interfaces or other applications on top of CCIP.
Neither Chainlink Labs nor the Chainlink Foundation owns, controls, endorses, or assumes any responsibility for any
such interfaces or applications. You are solely responsible for your use of such interfaces or applications. Please
visit the Chainlink Foundation Terms of Service for more information.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }[Image: caution]Understand Risks associated with Bridges

If you are using a cross-chain bridge to transfer your LINK tokens, read the Bridges and Associated Risks guide to understand what cross-chain bridges are and the risks associated with using them.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
## Parameters

• Payment Premium % (paymentPremiumPPB): This percentage premium compensates the Chainlink Automation Network for monitoring and performing your upkeep. Every time a transaction is submitted for your upkeep, your LINK balance is reduced by the transaction cost plus this percentage premium.
• Flat Fee Micro Link (flatFeeMicroLink): A flat fee charged per transaction on all testnets and OP Mainnet.
• Maximum Check Data Size (maxCheckDataSize): The maximum size, in bytes, that can be sent to your checkUpkeep function.
• Check Gas Limit (checkGasLimit): The maximum amount of gas that can be used by your checkUpkeep function for offchain computation.
• Perform Gas Limit (performGasLimit): The maximum amount of gas that can be used by the client contract's performUpkeep function for the onchain transaction. You can set an upper limit on your upkeep during registration, but this number must not exceed the maxPerformGas on the Registry.
• maximum Perform Data Size (maxPerformDataSize): The maximum size in bytes that can be sent to your performUpkeep function.
• Gas Ceiling Multiplier (gasCeilingMultiplier): Establishes a ceiling for the maximum price based on the onchain fast gas feed.
• Minimum Upkeep Spend (LINK): The minimum amount of LINK an upkeep must spend over its lifetime. If the lifetime (or total) upkeep spend is below this amount, then at cancellation this amount will be held back.

## Arbitrum

### Arbitrum One

Item | Value
--- | ---
Registry Address | 0x37D9dC70bfcd8BC77Ec2858836B923c560E891D1
Registrar Address | 0x86EFBD0b6736Bed994962f9797049422A3A8E8Ad
Payment Premium % | 50
Block Count per Turn | Not Applicable
Maximum Check Data Size | 5,000
Check Gas Limit | 10,000,000
Perform Gas Limit | 5,000,000
Maximum Perform Data Size | 2,000
Gas Ceiling Multiplier | 5
Minimum Upkeep Spend (LINK) | 0.1

### Arbitrum Sepolia

Item | Value
--- | ---
Registry Address | 0x8194399B3f11fcA2E8cCEfc4c9A658c61B8Bf412
Registrar Address | 0x881918E24290084409DaA91979A30e6f0dB52eBe
Payment Premium % | 50
Block Count per Turn | Not Applicable
Maximum Check Data Size | 5,000
Check Gas Limit | 10,000,000
Perform Gas Limit | 5,000,000
Maximum Perform Data Size | 2,000
Gas Ceiling Multiplier | 5
Minimum Upkeep Spend (LINK) | 0.1

## Avalanche

### Avalanche Mainnet

Item | Value
--- | ---
Registry Address | 0x7f00a3Cd4590009C349192510D51F8e6312E08CB
Registrar Address | 0x5Cb7B29e621810Ce9a04Bee137F8427935795d00
Payment Premium % | 40
Block Count per Turn | Not Applicable
Maximum Check Data Size | 5,000
Check Gas Limit | 10,000,000
Perform Gas Limit | 5,000,000
Maximum Perform Data Size | 5,000
Gas Ceiling Multiplier | 2
Minimum Upkeep Spend (LINK) | 0.1

### Avalanche Fuji Testnet

Item | Value
--- | ---
Registry Address | 0x819B58A646CDd8289275A87653a2aA4902b14fe6
Registrar Address | 0xD23D3D1b81711D75E1012211f1b65Cc7dBB474e2
Payment Premium % | 40
Block Count per Turn | Not Applicable
Maximum Check Data Size | 5,000
Check Gas Limit | 10,000,000
Perform Gas Limit | 5,000,000
Maximum Perform Data Size | 5,000
Gas Ceiling Multiplier | 2
Minimum Upkeep Spend (LINK) | 0.0

## Base

### Base Mainnet

Item | Value
--- | ---
Registry Address | 0xf4bAb6A129164aBa9B113cB96BA4266dF49f8743
Registrar Address | 0xE28Adc50c7551CFf69FCF32D45d037e5F6554264
Payment Premium % | 50
Block Count per Turn | Not Applicable
Maximum Check Data Size | 5,000
Check Gas Limit | 10,000,000
Perform Gas Limit | 5,000,000
Maximum Perform Data Size | 2,000
Gas Ceiling Multiplier | 5
Minimum Upkeep Spend (LINK) | 0.1

### Base Sepolia Testnet

Item | Value
--- | ---
Registry Address | 0x91D4a4C3D448c7f3CB477332B1c7D420a5810aC3
Registrar Address | 0xf28D56F3A707E25B71Ce529a21AF388751E1CF2A
Payment Premium % | 50
Block Count per Turn | Not Applicable
Maximum Check Data Size | 5,000
Check Gas Limit | 10,000,000
Perform Gas Limit | 5,000,000
Maximum Perform Data Size | 1,000
Gas Ceiling Multiplier | 2
Minimum Upkeep Spend (LINK) | 0.1

## BNB Chain

### BNB Chain Mainnet

Item | Value
--- | ---
Registry Address | 0xDc21E279934fF6721CaDfDD112DAfb3261f09A2C
Registrar Address | 0xf671F60bCC964B309D22424886FF202807381B32
Payment Premium % | 30
Block Count per Turn | Not Applicable
Maximum Check Data Size | 5,000
Check Gas Limit | 10,000,000
Perform Gas Limit | 5,000,000
Maximum Perform Data Size | 5,000
Gas Ceiling Multiplier | 3
Minimum Upkeep Spend (LINK) | 0.1

### BNB Chain Testnet

Item | Value
--- | ---
Registry Address | 0x96bb60aAAec09A0FceB4527b81bbF3Cc0c171393
Registrar Address | 0x0631ea498c2Cd8371B020b9eC03f5F779174562B
Payment Premium % | 30
Block Count per Turn | Not Applicable
Maximum Check Data Size | 5,000
Check Gas Limit | 10,000,000
Perform Gas Limit | 5,000,000
Maximum Perform Data Size | 5,000
Gas Ceiling Multiplier | 3
Minimum Upkeep Spend (LINK) | 0.0

## Ethereum

### Ethereum Mainnet

Item | Value
--- | ---
Registry Address | 0x6593c7De001fC8542bB1703532EE1E5aA0D458fD
Registrar Address | 0x6B0B234fB2f380309D47A7E9391E29E9a179395a
Payment Premium % | 20
Block Count per Turn | Not Applicable
Maximum Check Data Size | 5,000
Check Gas Limit | 10,000,000
Perform Gas Limit | 5,000,000
Maximum Perform Data Size | 2,000
Gas Ceiling Multiplier | 2
Minimum Upkeep Spend (LINK) | 0.1

### Ethereum Sepolia Testnet

Item | Value
--- | ---
Registry Address | 0x86EFBD0b6736Bed994962f9797049422A3A8E8Ad
Registrar Address | 0xb0E49c5D0d05cbc241d68c05BC5BA1d1B7B72976
Payment Premium % | 20
Block Count per Turn | Not Applicable
Maximum Check Data Size | 5,000
Check Gas Limit | 10,000,000
Perform Gas Limit | 5,000,000
Maximum Perform Data Size | 2,000
Gas Ceiling Multiplier | 3
Minimum Upkeep Spend (LINK) | 0.0

## Gnosis

### Gnosis Mainnet

Item | Value
--- | ---
Registry Address | 0x299c92a219F61a82E91d2062A262f7157F155AC1
Registrar Address | 0x0F7E163446AAb41DB5375AbdeE2c3eCC56D9aA32
Payment Premium % | 100
Block Count per Turn | Not Applicable
Maximum Check Data Size | 5,000
Check Gas Limit | 10,000,000
Perform Gas Limit | 5,000,000
Maximum Perform Data Size | 5,000
Gas Ceiling Multiplier | 3
Minimum Upkeep Spend (LINK) | 0.1

### Gnosis Chiado Testnet

Item | Value
--- | ---
Registry Address | 0x2CA3BC9eC81E9647e7f8e7EdFE630a27A4E470dB
Registrar Address | 0xcfB98e8E3AB99217a0E61C29f86ba3a4B79037BF
Payment Premium % | 30
Block Count per Turn | Not Applicable
Maximum Check Data Size | 5,000
Check Gas Limit | 10,000,000
Perform Gas Limit | 5,000,000
Maximum Perform Data Size | 5,000
Gas Ceiling Multiplier | 3
Minimum Upkeep Spend (LINK) | 0.1

## OP

### OP Mainnet

Item | Value
--- | ---
Registry Address | 0x4F70c323b8B72AeffAF633Aa4D5e8B6Be5df4AEf
Registrar Address | 0xe96057F85510292231e2C759752f012C87A8c8dd
Payment Premium % | 50
Block Count per Turn | Not Applicable
Maximum Check Data Size | 5,000
Check Gas Limit | 10,000,000
Perform Gas Limit | 5,000,000
Maximum Perform Data Size | 5,000
Gas Ceiling Multiplier | 5

### OP Sepolia Testnet

Item | Value
--- | ---
Registry Address | 0x8E82eE417f916Bd44E8Efa144222808E5Fa84611
Registrar Address | 0x9e329384F4155a5c284FF91CeD9f2AEF589C81c9
Payment Premium % | 50
Block Count per Turn | Not Applicable
Maximum Check Data Size | 5,000
Check Gas Limit | 10,000,000
Perform Gas Limit | 5,000,000
Maximum Perform Data Size | 5,000
Gas Ceiling Multiplier | 5
Minimum Upkeep Spend (LINK) | 0.1

## Polygon

### Polygon Mainnet

Item | Value
--- | ---
Registry Address | 0x08a8eea76D2395807Ce7D1FC942382515469cCA1
Registrar Address | 0x0Bc5EDC7219D272d9dEDd919CE2b4726129AC02B
Payment Premium % | 70
Block Count per Turn | Not Applicable
Maximum Check Data Size | 5,000
Check Gas Limit | 10,000,000
Perform Gas Limit | 5,000,000
Maximum Perform Data Size | 5,000
Gas Ceiling Multiplier | 3
Minimum Upkeep Spend (LINK) | 0.1

### Polygon Amoy Testnet

Item | Value
--- | ---
Registry Address | 0x93C0e201f7B158F503a1265B6942088975f92ce7
Registrar Address | 0x99083A4bb154B0a3EC7a0D1eb40370C892Db4225
Payment Premium % | 30
Block Count per Turn | Not Applicable
Maximum Check Data Size | 5,000
Check Gas Limit | 10,000,000
Perform Gas Limit | 5,000,000
Maximum Perform Data Size | 5,000
Gas Ceiling Multiplier | 3
Minimum Upkeep Spend (LINK) | 0.1

## Polygon zkEVM

### Polygon zkEVM Mainnet

Item | Value
--- | ---
Registry Address | 0x0F7E163446AAb41DB5375AbdeE2c3eCC56D9aA32
Registrar Address | 0x703C1d261a996755409c74d00871e7D6Af4d9896
Payment Premium % | 56
Block Count per Turn | Not Applicable
Maximum Check Data Size | 5,000
Check Gas Limit | 10,000,000
Perform Gas Limit | 5,000,000
Maximum Perform Data Size | 5,000
Gas Ceiling Multiplier | 2
Minimum Upkeep Spend (LINK) | 0.0004

### Polygon zkEVM Cardona Testnet

Item | Value
--- | ---
Registry Address | 0x0F7E163446AAb41DB5375AbdeE2c3eCC56D9aA32
Registrar Address | 0x703C1d261a996755409c74d00871e7D6Af4d9896
Payment Premium % | 50
Block Count per Turn | Not Applicable
Maximum Check Data Size | 5,000
Check Gas Limit | 10,000,000
Perform Gas Limit | 5,000,000
Maximum Perform Data Size | 5,000
Gas Ceiling Multiplier | 2
Minimum Upkeep Spend (LINK) | 0.0004

## Scroll

### Scroll Mainnet

Item | Value
--- | ---
Registry Address | 0xBe55E7eb27Cd69Be0883E0284632A91bB7AdC272
Registrar Address | 0x80C55e674a34FfE730B0357E16e8852B19573f7C
Payment Premium % | 56
Block Count per Turn | Not Applicable
Maximum Check Data Size | 5,000
Check Gas Limit | 10,000,000
Perform Gas Limit | 5,000,000
Maximum Perform Data Size | 5,000
Gas Ceiling Multiplier | 2
Minimum Upkeep Spend (LINK) | 0.0004

### Scroll Sepolia Testnet

Item | Value
--- | ---
Registry Address | 0x93C0e201f7B158F503a1265B6942088975f92ce7
Registrar Address | 0x8ee44ab698169a0AcA2571834b19a02d09D818d5
Payment Premium % | 50
Block Count per Turn | Not Applicable
Maximum Check Data Size | 5,000
Check Gas Limit | 10,000,000
Perform Gas Limit | 5,000,000
Maximum Perform Data Size | 5,000
Gas Ceiling Multiplier | 2
Minimum Upkeep Spend (LINK) | 0.1

## ZkSync

### ZkSync Mainnet

Item | Value
--- | ---
Registry Address | 0x8D405a2252fe4bd50dF29835e621986E59A81D74
Registrar Address | 0x7415C4E9758F3cA26F1a4a8F11d885eadEF68939
Payment Premium % | 50
Block Count per Turn | Not Applicable
Maximum Check Data Size | 5,000
Check Gas Limit | 10,000,000
Perform Gas Limit | 5,000,000
Maximum Perform Data Size | 5,000
Gas Ceiling Multiplier | 2
Minimum Upkeep Spend (LINK) | 0.0004

### ZkSync Sepolia Testnet

Item | Value
--- | ---
Registry Address | 0xc740003833d487c49881Cd19A21B8c58313e0cF4
Registrar Address | 0xC23751714a66B9824Fa6724A7B08635D480e88cD
Payment Premium % | 30
Block Count per Turn | Not Applicable
Maximum Check Data Size | 5,000
Check Gas Limit | 10,000,000
Perform Gas Limit | 5,000,000
Maximum Perform Data Size | 5,000
Gas Ceiling Multiplier | 2
Minimum Upkeep Spend (LINK) | 0.0004

================================================================================

# Create Automation-Compatible Contracts

Source: https://docs.chain.link/chainlink-automation/guides/compatible-contracts
Extraction Method: playwright
Components: code_block(1)

# Create Automation-Compatible Contracts
Learn how to make smart contracts that are compatible with Automation.

[Image: tip]Considerations and Best Practices

Before you deploy contracts to use with Chainlink Automation, read the Best Practices guide. These best practices are important for using Chainlink Automation securely and reliably. You can also read more about the Chainlink Automation architecture here.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
## Automation compatible contracts
A contract is Automation-compatible when it follows a specified interface that allows the Chainlink Automation Network to determine if, when, and how the contract should be automated.

The interface you use will depend on the type of trigger you want to use:

• If you want a log event to trigger your upkeep, use the ILogAutomation interface.
• If you want to use onchain state in a custom calculation to trigger your upkeep, use AutomationCompatibleInterface interface.
• If you want to call a function just based on time, you don't need an interface. Consider instead using a time-based upkeep.
• If you want to use Automation with Data Streams, use StreamsLookupCompatibleInterface interface.

You can learn more about these interfaces here.

## Example Automation-compatible contract using custom logic trigger
Custom logic Automation compatible contracts must meet the following requirements:

• Import AutomationCompatible.sol. You can refer to the Chainlink Contracts on GitHub to find the latest version.
• Use the AutomationCompatibleInterface from the library to ensure your checkUpkeep and performUpkeep function definitions match the definitions expected by the Chainlink Automation Network.
• Include a checkUpkeep function that contains the logic that will be executed offchain to see if performUpkeep should be executed. checkUpkeep can use onchain data and a specified checkData parameter to perform complex calculations offchain and then send the result to performUpkeep as performData.
• Include a performUpkeep function that will be executed onchain when checkUpkeep returns true.

Use these elements to create a compatible contract that will automatically increment a counter after every updateInterval seconds. After you register the contract as an upkeep, the Chainlink Automation Network frequently simulates your checkUpkeep offchain to determine if the updateInterval time has passed since the last increment (timestamp). When checkUpkeep returns true, the Chainlink Automation Network calls performUpkeep onchain and increments the counter. This cycle repeats until the upkeep is cancelled or runs out of funding.

[Image: copy to clipboard]
```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

// AutomationCompatible.sol imports the functions from both ./AutomationBase.sol and
// ./interfaces/AutomationCompatibleInterface.sol
import {AutomationCompatibleInterface} from "@chainlink/contracts/src/v0.8/automation/AutomationCompatible.sol";

/**
 * @dev Example contract, use the Forwarder as needed for additional security.
 *
 * @notice important to implement {AutomationCompatibleInterface}
 */

/**
 * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
 * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

contract Counter is AutomationCompatibleInterface {
    /**
     * Public counter variable
     */
    uint256 public counter;

    /**
     * Use an interval in seconds and a timestamp to slow execution of Upkeep
     */
    uint256 public immutable interval;
    uint256 public lastTimeStamp;

    constructor(uint256 updateInterval) {
        interval = updateInterval;
        lastTimeStamp = block.timestamp;

        counter = 0;
    }

    function checkUpkeep(
        bytes calldata /* checkData */
    )
        external
        view
        override
        returns (bool upkeepNeeded, bytes memory /* performData */)
    {
        upkeepNeeded = (block.timestamp - lastTimeStamp) > interval;
        // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
    }

    function performUpkeep(bytes calldata /* performData */) external override {
        if ((block.timestamp - lastTimeStamp) > interval) {
            lastTimeStamp = block.timestamp;
            counter = counter + 1;
        }
        // We don't use the performData in this example. The performData is generated by the Automation Node's call to your checkUpkeep function
    }
}
```

[Open in Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/Automation/AutomationCounter.sol&autoCompile=true)[What is Remix?](/getting-started/conceptual-overview#what-is-remix)Compile and deploy your own Automation Counter onto a supported Testnet.

1. In the Remix example, select the compile tab on the left and press the compile button. Make sure that your contract compiles without any errors. Note that the Warning messages in this example are acceptable and will not block the deployment.
2. Select the Deploy tab and deploy the Counter smart contract in the injected web3 environment. When deploying the contract, specify the updateInterval value. For this example, set a short interval of 60. This is the interval at which the performUpkeep function will be called.
3. After deployment is complete, copy the address of the deployed contract. This address is required to register your upkeep in the Automation UI. The example in this document uses custom logic automation.

To see more complex examples, go to the Quick Starts page.

Now register your upkeep.

## Vyper example
[Image: note]Note on arrays

Make sure the checkdata array size is correct. Vyper does not support dynamic arrays.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }You can find a KeepersConsumer example here. Read the apeworx-starter-kit README to learn how to run the example.

================================================================================

# Create a Time-Based Upkeep

Source: https://docs.chain.link/chainlink-automation/guides/job-scheduler
Extraction Method: playwright
Components: code_block(1)

# Create a Time-Based Upkeep
Create powerful automation for your smart contract using time schedules without having to create Automation-compatible contracts. This guide explains how to register time-based upkeeps.

[Image: tip]Testing and best practices

Follow the best practices when creating an Automation-compatible
contract and test your upkeep on a testnet before deploying it to a mainnet.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
## Using the Chainlink Automation app
In the Chainlink Automation App, click the blue Register new Upkeep button.

astro-island,astro-slot,astro-static-slot{display:contents}(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).only=e;window.dispatchEvent(new Event("astro:only"));})();(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();
### Connecting your wallet
If you do not already have a wallet connected with the Chainlink Automation network, the interface will prompt you to do so. Click the Connect Wallet button and follow the remaining prompts to connect your wallet to one of the Automation supported blockchain networks.

## Trigger selection
Select Time-based trigger.

## Using time-based triggers
When you select the time-based trigger, you are prompted to enter a contract address. Provide the address of the contract you want to automate. If you did not verify the contract on chain, you will need to paste the Application Binary Interface (ABI) of the deployed contract into the corresponding text box. Select the function name that you want to execute and provide any static inputs. If you want to use dynamic inputs please see Custom logic Upkeeps

### Specifying the time schedule
After you have successfully entered your contract address and ABI, specify your time schedule in the form of a CRON expression. CRON expressions provide a shorthand way of creating a time schedule. You can use the provided example buttons in the Automation app to experiment with different schedules. Then, create your own time schedule.

[Image: copy to clipboard]
```plaintext
Cron jobs are interpreted according to this format:

  ┌───────────── minute (0 - 59)
  │ ┌───────────── hour (0 - 23)
  │ │ ┌───────────── day of the month (1 - 31)
  │ │ │ ┌───────────── month (1 - 12)
  │ │ │ │ ┌───────────── day of the week (0 - 6) (Sunday to Saturday)
  │ │ │ │ │
  │ │ │ │ │
  │ │ │ │ │
  * * * * *

All times are in UTC.

- can be used for range e.g. "0 8-16 * * *"
/ can be used for interval e.g. "0 */2 * * *"
, can be used for list e.g. "0 17 * * 0,2,4"

Special limitations:
  * there is no year field
  * no special characters: ? L W #
  * lists can have a max length of 26
  * no words like JAN / FEB or MON / TUES
```

After entering your CRON expression, click Next.

## Entering upkeep details
Provide the following information in the Automation app:

• Upkeep name: This will be visible in the Chainlink Automation app.
• Gas limit: This is the maximum amount of gas that your transaction requires to execute on chain. This limit cannot exceed the performGasLimit value configured on the registry.

[Image: note]Job Scheduler Gas requirements

When you create an upkeep through the Job Scheduler, Chainlink Automation deploys a new CronUpkeep contract from the
CronUpkeepFactory
to manage your time schedule and ensure that it is compatible. Because this contract uses roughly 110K gas per call, it is
recommended to add 150K additional gas to the gas limit of the function you would like to automate.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
• Starting balance (LINK): Specify a LINK starting balance to fund your upkeep. See the LINK Token Contracts page to find the correct contract address and access faucets for testnet LINK. This field is required. You must have LINK before you can use the Chainlink Automation service.

[Image: tip]ERC-677 Link

For registration you must use ERC-677 LINK. Read our LINK page to determine where
to acquire mainnet LINK, or visit faucets.chain.link to request testnet LINK.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
• Your email address (optional): This email address will be used to send you an email notification when your upkeep is underfunded.

## Complete upkeep registration
Click Register upkeep and confirm the transaction in MetaMask.

Your upkeeps will be displayed in your list of Active Upkeeps. You must monitor the balance of your upkeep. If the balance drops below the minimum balance, the Chainlink Automation Network will not perform the Upkeep. See Managing Upkeeps to learn how to manage your upkeeps.

================================================================================

# Chainlink Functions

Source: https://docs.chain.link/chainlink-functions
Extraction Method: playwright

# Chainlink Functions
Chainlink Functions provides your smart contracts access to trust-minimized compute infrastructure, allowing you to fetch data from APIs and perform custom computation. Your smart contract sends source code in a request to a Decentralized Oracle Network (DON), and each node in the DON executes the code in a serverless environment. The DON then aggregates all the independent return values from each execution and sends the final result back to your smart contract.

Chainlink Functions eliminates the need for you to manage your own Chainlink node and provides decentralized offchain computation and consensus, ensuring that a minority of the network cannot manipulate the response sent back to your smart contract.

Furthermore, Chainlink Functions allows you to include secret values in your request that are encrypted using threshold encryption. These values can only be decrypted via a multi-party decryption process, meaning that every node can only decrypt the secrets with participation from other DON nodes. This feature can provide API keys or other sensitive values to your source code, enabling access to APIs that require authentication.

To pay for requests, you fund a subscription account with LINK. Your subscription is billed when the DON fulfills your requests. Check out the subscriptions page for more information.

Read the architecture page to learn more about how Chainlink Functions works.

See the Tutorials page for simple tutorials showing you different GET and POST requests that run on Chainlink Functions. You can also gain hands-on experience with Chainlink Functions with the Chainlink Functions Playground.

## When to use Chainlink Functions
[Image: note]note

Chainlink Functions is a self-service solution. You are responsible for independently reviewing any code and API dependencies that you submit in a request. Community-created code examples might not be audited, so you must independently review this code before you use it.

Chainlink Functions is offered "as is" and "as available" without conditions or warranties of any kind. Neither Chainlink Labs, the Chainlink Foundation, nor Chainlink node operators are responsible for unintended outputs from Functions due to issues in your code or downstream issues with API dependencies. You must ensure that the data sources or APIs specified in requests are of sufficient quality and have the proper availability for your use case. Users are responsible for complying with the licensing agreements for all data providers that they connect with through Chainlink Functions. Violations of data provider licensing agreements or the terms can result in suspension or termination of your Chainlink Functions account or subscription.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }Chainlink Functions enables a variety of use cases. Use Chainlink Functions to:

• Connect to any public data. For example, you can connect your smart contracts to weather statistics for parametric insurance or real-time sports results for Dynamic NFTs.
• Connect to public data and transform it before consumption. You could calculate Twitter sentiment after reading data from the Twitter API, or derive asset prices after reading price data from Chainlink Price Feeds.
• Connect to a password-protected data source; from IoT devices like smartwatches to enterprise resource planning systems.
• Connect to an external decentralized database, such as IPFS, to facilitate offchain processes for a dApp or build a low-cost governance voting system.
• Connect to your Web2 application and build complex hybrid smart contracts.
• Fetch data from almost any Web2 system such as AWS S3, Firebase, or Google Cloud Storage.

You can find several community examples at useChainlinkFunctions.com

## Supported networks
See the Supported Networks page to find a list of supported networks and contract addresses.

================================================================================

# Getting Started

Source: https://docs.chain.link/chainlink-functions/getting-started
Extraction Method: playwright
Components: code_block(14)

# Getting Started
Learn how to make requests to the Chainlink Functions Decentralized Oracle Network (DON) and make any computation or API calls offchain. Chainlink Functions is available on several blockchains (see the supported networks page), but this guide uses Sepolia to simplify access to testnet funds. Complete the following tasks to get started with Chainlink Functions:

• Set up your web3 wallet and fund it with testnet tokens.
• Simulate a Chainlink Functions on the Chainlink Functions
Playground.
• Send a Chainlink Functions request to the DON. The JavaScript source code makes an API call to the Star Wars API and fetches the name of a given character.
• Receive the response from Chainlink Functions and parse the result.

Playclass i extends HTMLElement{connectedCallback(){this.videoId=this.getAttribute("videoid");let e=this.querySelector(".lty-playbtn");if(this.playLabel=e&&e.textContent.trim()||this.getAttribute("playlabel")||"Play",this.dataset.title=this.getAttribute("title")||"",this.style.backgroundImage||(this.style.backgroundImage=`url("https://i.ytimg.com/vi/${this.videoId}/hqdefault.jpg")`,this.upgradePosterImage()),e||(e=document.createElement("button"),e.type="button",e.classList.add("lty-playbtn"),this.append(e)),!e.textContent){const t=document.createElement("span");t.className="lyt-visually-hidden",t.textContent=this.playLabel,e.append(t)}this.addNoscriptIframe(),e.nodeName==="A"&&(e.removeAttribute("href"),e.setAttribute("tabindex","0"),e.setAttribute("role","button"),e.addEventListener("keydown",t=>{(t.key==="Enter"||t.key===" ")&&(t.preventDefault(),this.activate())})),this.addEventListener("pointerover",i.warmConnections,{once:!0}),this.addEventListener("focusin",i.warmConnections,{once:!0}),this.addEventListener("click",this.activate),this.needsYTApi=this.hasAttribute("js-api")||navigator.vendor.includes("Apple")||navigator.userAgent.includes("Mobi")}static addPrefetch(e,t,a){const r=document.createElement("link");r.rel=e,r.href=t,a&&(r.as=a),document.head.append(r)}static warmConnections(){i.preconnected||(i.addPrefetch("preconnect","https://www.youtube-nocookie.com"),i.addPrefetch("preconnect","https://www.google.com"),i.addPrefetch("preconnect","https://googleads.g.doubleclick.net"),i.addPrefetch("preconnect","https://static.doubleclick.net"),i.preconnected=!0)}fetchYTPlayerApi(){window.YT||window.YT&&window.YT.Player||(this.ytApiPromise=new Promise((e,t)=>{var a=document.createElement("script");a.src="https://www.youtube.com/iframe_api",a.async=!0,a.onload=r=>{YT.ready(e)},a.onerror=t,this.append(a)}))}async getYTPlayer(){return this.playerPromise||await this.activate(),this.playerPromise}async addYTPlayerIframe(){this.fetchYTPlayerApi(),await this.ytApiPromise;const e=document.createElement("div");this.append(e);const t=Object.fromEntries(this.getParams().entries());this.playerPromise=new Promise(a=>{let r=new YT.Player(e,{width:"100%",videoId:this.videoId,playerVars:t,events:{onReady:n=>{n.target.playVideo(),a(r)}}})})}addNoscriptIframe(){const e=this.createBasicIframe(),t=document.createElement("noscript");t.innerHTML=e.outerHTML,this.append(t)}getParams(){const e=new URLSearchParams(this.getAttribute("params")||[]);return e.append("autoplay","1"),e.append("playsinline","1"),e}async activate(){if(this.classList.contains("lyt-activated"))return;if(this.classList.add("lyt-activated"),this.needsYTApi)return this.addYTPlayerIframe(this.getParams());const e=this.createBasicIframe();this.append(e),e.focus()}createBasicIframe(){const e=document.createElement("iframe");return e.width=560,e.height=315,e.title=this.playLabel,e.allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture",e.allowFullscreen=!0,e.src=`https://www.youtube-nocookie.com/embed/${encodeURIComponent(this.videoId)}?${this.getParams().toString()}`,e}upgradePosterImage(){setTimeout(()=>{const e=`https://i.ytimg.com/vi_webp/${this.videoId}/sddefault.webp`,t=new Image;t.fetchPriority="low",t.referrerpolicy="origin",t.src=e,t.onload=a=>{a.target.naturalHeight==90&&a.target.naturalWidth==120||(this.style.backgroundImage=`url("${e}")`)}},100)}}customElements.define("lite-youtube",i);
## Simulation
Before making a Chainlink Functions request from your smart contract, it is always a good practice to simulate the source code offchain to make any adjustments or corrections.

1. Open the Functions playground.
2. Copy and paste the following source code into the playground's code block.
const characterId = args[0];
const apiResponse = await Functions.makeHttpRequest({
  url: `https://swapi.info/api/people/${characterId}/`,
});
if (apiResponse.error) {
  throw Error("Request failed");
}
const { data } = apiResponse;
return Functions.encodeString(data.name);
3. Under Argument, set the first argument to 1. You are going to fetch the name of the first Star Wars character.
4. Click on Run code. Under Output, you should see Luke Skywalker.

## Configure your resources

### Configure your wallet
You will test on Sepolia, so you must have an Ethereum web3 wallet with enough testnet ETH and LINK tokens. Testnet ETH is the native gas fee token on Sepolia. You will use testnet ETH tokens to pay for gas whenever you make a transaction on Sepolia. On the other hand, you will use LINK tokens to pay the Chainlink Functions Decentralized Oracles Network (DON) for processing your request.

1. Install the MetaMask wallet or other Ethereum web3 wallet.
2. Set the network for your wallet to the Sepolia testnet. If you need to add Sepolia to your wallet, you can find the chain ID and the LINK token contract address on the LINK Token Contracts page.

Sepolia testnet and LINK token contract
3. Request testnet LINK and ETH from faucets.chain.link/sepolia.

### Deploy a Functions consumer contract on Sepolia

1. Open the GettingStartedFunctionsConsumer.sol contract in Remix.

Open in Remix
What is Remix?
2. Compile the contract.
3. Open MetaMask and select the Sepolia network.
4. In Remix under the Deploy & Run Transactions tab, select Injected Provider - MetaMask in the Environment list. Remix will use the MetaMask wallet to communicate with Sepolia.
5. Click the Deploy button to deploy the contract. MetaMask prompts you to confirm the transaction. Check the transaction details to make sure you are deploying the contract to Sepolia.
6. After you confirm the transaction, the contract address appears in the Deployed Contracts list. Copy the contract address and save it for later. You will use this address with a Functions Subscription.

### Create a subscription
You use a Chainlink Functions subscription to pay for, manage, and track Functions requests.

1. Go to functions.chain.link.
2. Click Connect wallet:
3. Read and accept the Chainlink Foundation Terms of Service. Then click MetaMask.
4. Make sure your wallet is connected to the Sepolia testnet. If not, click the network name in the top right corner of the page and select Sepolia.
5. Click Create Subscription:
6. Provide an email address and an optional subscription name:
7. The first time you interact with the Subscription Manager using your EOA, you must accept the Terms of Service (ToS). A MetaMask popup appears and you are asked to accept the ToS:
8. After you approve the ToS, another MetaMask popup appears, and you are asked to approve the subscription creation:
9. After the subscription is created, MetaMask prompts you to sign a message that links the subscription name and email address to your subscription:

### Fund your subscription

1. After the subscription is created, the Functions UI prompts you to fund your subscription. Click Add funds:
2. For this example, add 2 LINK and click Add funds:

### Add a consumer to your subscription

1. After you fund your subscription, add your consumer to it. Specify the address for the consumer contract that you deployed earlier and click Add consumer. MetaMask prompts you to confirm the transaction.
2. Subscription creation and configuration is complete. You can always see the details of your subscription again at functions.chain.link:

## Run the example
The example is hardcoded to communicate with Chainlink Functions on Sepolia. After this example is run, you can examine the code and see a detailed description of all components.

1. In Remix under the Deploy & Run Transactions tab, expand your contract in the Deployed Contracts section.
2. Expand the sendRequest function to display its parameters.
3. Fill in the subscriptionId with your subscription ID and args with [1]. You can find your subscription ID on the Chainlink Functions Subscription Manager at functions.chain.link. The [1] value for args specifies which argument in the response will be retrieved.
4. Click the transact button.
5. Wait for the request to be fulfilled. You can monitor the status of your request on the Chainlink Functions Subscription Manager.
6. Refresh the Functions UI to get the latest request status.
7. After the status is Success, check the character name. In Remix, under the Deploy & Run Transactions tab, click the character function. If the transaction and request ran correctly, you will see the name of your character in the response.

Chainlink Functions is capable of much more than just retrieving data. Try one of the Tutorials to see examples that can GET and POST to public APIs, securely handle API secrets, handle custom responses, and query multiple APIs.

## Examine the code

### Solidity code
[Image: copy to clipboard]
```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import {FunctionsClient} from "@chainlink/contracts/src/v0.8/functions/v1_0_0/FunctionsClient.sol";
import {ConfirmedOwner} from "@chainlink/contracts/src/v0.8/shared/access/ConfirmedOwner.sol";
import {FunctionsRequest} from "@chainlink/contracts/src/v0.8/functions/v1_0_0/libraries/FunctionsRequest.sol";

/**
 * Request testnet LINK and ETH here: https://faucets.chain.link/
 * Find information on LINK Token Contracts and get the latest ETH and LINK faucets here: https://docs.chain.link/resources/link-token-contracts/
 */

/**
 * @title GettingStartedFunctionsConsumer
 * @notice This is an example contract to show how to make HTTP requests using Chainlink
 * @dev This contract uses hardcoded values and should not be used in production.
 */
contract GettingStartedFunctionsConsumer is FunctionsClient, ConfirmedOwner {
    using FunctionsRequest for FunctionsRequest.Request;

    // State variables to store the last request ID, response, and error
    bytes32 public s_lastRequestId;
    bytes public s_lastResponse;
    bytes public s_lastError;

    // Custom error type
    error UnexpectedRequestID(bytes32 requestId);

    // Event to log responses
    event Response(
        bytes32 indexed requestId,
        string character,
        bytes response,
        bytes err
    );

    // Router address - Hardcoded for Sepolia
    // Check to get the router address for your supported network https://docs.chain.link/chainlink-functions/supported-networks
    address router = 0xb83E47C2bC239B3bf370bc41e1459A34b41238D0;

    // JavaScript source code
    // Fetch character name from the Star Wars API.
    // Documentation: https://swapi.info/people
    string source =
        "const characterId = args[0];"
        "const apiResponse = await Functions.makeHttpRequest({"
        "url: `https://swapi.info/api/people/${characterId}/`"
        "});"
        "if (apiResponse.error) {"
        "throw Error('Request failed');"
        "}"
        "const { data } = apiResponse;"
        "return Functions.encodeString(data.name);";

    //Callback gas limit
    uint32 gasLimit = 300000;

    // donID - Hardcoded for Sepolia
    // Check to get the donID for your supported network https://docs.chain.link/chainlink-functions/supported-networks
    bytes32 donID =
        0x66756e2d657468657265756d2d7365706f6c69612d3100000000000000000000;

    // State variable to store the returned character information
    string public character;

    /**
     * @notice Initializes the contract with the Chainlink router address and sets the contract owner
     */
    constructor() FunctionsClient(router) ConfirmedOwner(msg.sender) {}

    /**
     * @notice Sends an HTTP request for character information
     * @param subscriptionId The ID for the Chainlink subscription
     * @param args The arguments to pass to the HTTP request
     * @return requestId The ID of the request
     */
    function sendRequest(
        uint64 subscriptionId,
        string[] calldata args
    ) external onlyOwner returns (bytes32 requestId) {
        FunctionsRequest.Request memory req;
        req.initializeRequestForInlineJavaScript(source); // Initialize the request with JS code
        if (args.length > 0) req.setArgs(args); // Set the arguments for the request

        // Send the request and store the request ID
        s_lastRequestId = _sendRequest(
            req.encodeCBOR(),
            subscriptionId,
            gasLimit,
            donID
        );

        return s_lastRequestId;
    }

    /**
     * @notice Callback function for fulfilling a request
     * @param requestId The ID of the request to fulfill
     * @param response The HTTP response data
     * @param err Any errors from the Functions request
     */
    function fulfillRequest(
        bytes32 requestId,
        bytes memory response,
        bytes memory err
    ) internal override {
        if (s_lastRequestId != requestId) {
            revert UnexpectedRequestID(requestId); // Check if request IDs match
        }
        // Update the contract's state variables with the response and any errors
        s_lastResponse = response;
        character = string(response);
        s_lastError = err;

        // Emit an event to log the response
        emit Response(requestId, character, s_lastResponse, s_lastError);
    }
}
```

[Open in Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/ChainlinkFunctions/GettingStartedFunctionsConsumer.sol&autoCompile=true)[What is Remix?](/getting-started/conceptual-overview#what-is-remix)
• To write a Chainlink Functions consumer contract, your contract must import FunctionsClient.sol and FunctionsRequest.sol. You can read the API references: FunctionsClient and FunctionsRequest.
These contracts are available in an NPM package so that you can import them from within your project.
import {FunctionsClient} from "@chainlink/contracts/src/v0.8/functions/v1_0_0/FunctionsClient.sol";
import {FunctionsRequest} from "@chainlink/contracts/src/v0.8/functions/v1_0_0/libraries/FunctionsRequest.sol";
• Use the FunctionsRequest.sol library to get all the functions needed for building a Chainlink Functions request.
using FunctionsRequest for FunctionsRequest.Request;
• The latest request ID, latest received response, and latest received error (if any) are defined as state variables:
bytes32 public s_lastRequestId;
bytes public s_lastResponse;
bytes public s_lastError;
• We define the Response event that your smart contract will emit during the callback
event Response(bytes32 indexed requestId, string character, bytes response, bytes err);
• The Chainlink Functions router address and donID are hardcoded for Sepolia. Check the supported networks page to try the code sample on another testnet.
• The gasLimit is hardcoded to 300000, the amount of gas that Chainlink Functions will use to fulfill your request.
• The JavaScript source code is hardcoded in the source state variable. For more explanation, read the JavaScript code section.
• Pass the router address for your network when you deploy the contract:
constructor() FunctionsClient(router)
• The two remaining functions are:

sendRequest for sending a request. It receives the subscription ID and list of arguments to pass to the source code. Then:

It uses the FunctionsRequest library to initialize the request and add the source code and arguments. You can read the API Reference for Initializing a request and adding arguments.
FunctionsRequest.Request memory req;
req.initializeRequestForInlineJavaScript(source);
if (args.length > 0) req.setArgs(args);

It sends the request to the router by calling the FunctionsClient sendRequest function. You can read the API reference for sending a request. Finally, it stores the request id in s_lastRequestId and returns it.
s_lastRequestId = _sendRequest(
    req.encodeCBOR(),
    subscriptionId,
    gasLimit,
    jobId
);
return s_lastRequestId;

Note: _sendRequest accepts requests encoded in bytes. Therefore, you must encode it using encodeCBOR.
• fulfillRequest to be invoked during the callback. This function is defined in FunctionsClient as virtual (read fulfillRequest API reference). So, your smart contract must override the function to implement the callback. The implementation of the callback is straightforward: the contract stores the latest response and error in s_lastResponse and s_lastError, parses the response from bytes to string to fetch the character name before emitting the Response event.
s_lastResponse = response;
character = string(response);
s_lastError = err;
emit Response(requestId, s_lastResponse, s_lastError);

### JavaScript code
[Image: copy to clipboard]
```javascript
const characterId = args[0];
const apiResponse = await Functions.makeHttpRequest({
  url: `https://swapi.info/api/people/${characterId}/`,
});
if (apiResponse.error) {
  throw Error("Request failed");
}
const { data } = apiResponse;
return Functions.encodeString(data.name);
```

This JavaScript source code uses Functions.makeHttpRequest to make HTTP requests. The source code calls the https://swapi.info/ API to request a Star Wars character name. If you read the Functions.makeHttpRequest documentation and the Star Wars API documentation, you notice that URL has the following format where $characterId is provided as parameter when making the HTTP request:

[Image: copy to clipboard]
```plaintext
url: `https://swapi.info/api/people/${characterId}/`
```

To check the expected API response for the first character, you can directly paste the following URL in your browser https://swapi.info/api/people/1/ or run the curl command in your terminal:

[Image: copy to clipboard]
```bash
curl -X 'GET' \
  'https://swapi.info/api/people/1/' \
  -H 'accept: application/json'
```

The response should be similar to the following example:

[Image: copy to clipboard]
```json
{
  "name": "Luke Skywalker",
  "height": "172",
  "mass": "77",
  "hair_color": "blond",
  "skin_color": "fair",
  "eye_color": "blue",
  "birth_year": "19BBY",
  "gender": "male",
  "homeworld": "https://swapi.info/api/planets/1/",
  "films": [
    "https://swapi.info/api/films/1/",
    "https://swapi.info/api/films/2/",
    "https://swapi.info/api/films/3/",
    "https://swapi.info/api/films/6/"
  ],
  "species": [],
  "vehicles": ["https://swapi.info/api/vehicles/14/", "https://swapi.info/api/vehicles/30/"],
  "starships": ["https://swapi.info/api/starships/12/", "https://swapi.info/api/starships/22/"],
  "created": "2014-12-09T13:50:51.644000Z",
  "edited": "2014-12-20T21:17:56.891000Z",
  "url": "https://swapi.info/api/people/1/"
}
```

Now that you understand the structure of the API. Let's delve into the JavaScript code. The main steps are:

• Fetch characterId from args. Args is an array. The characterId is located in the first element.
• Make the HTTP call using Functions.makeHttpRequest and store the response in apiResponse.
• Throw an error if the call is not successful.
• The API response is located at data.
• Read the name from the API response data.name and return the result as a buffer using the Functions.encodeString helper function. Because the name is a string, we use encodeString. For other data types, you can use different data encoding functions.
Note: Read this article if you are new to Javascript Buffers and want to understand why they are important.

================================================================================

# Chainlink Functions Architecture

Source: https://docs.chain.link/chainlink-functions/resources/architecture
Extraction Method: playwright

# Chainlink Functions Architecture
[Image: note]Prerequisites

Read the Chainlink Functions introduction to understand all the concepts discussed on this
page.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
## Request and Receive Data
This model is similar to the Basic Request Model: The consumer contract initiates the cycle by sending a request to the FunctionsRouter contract. Oracle nodes watch for events emitted by the FunctionsCoordinator contract and run the computation offchain. Finally, oracle nodes use the Chainlink OCR protocol to aggregate all the returned before passing the single aggregated response back to the consumer contract via a callback function.

astro-island,astro-slot,astro-static-slot{display:contents}(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).only=e;window.dispatchEvent(new Event("astro:only"));})();(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();[Image: Chainlink Functions request and receive diagram]The main actors and components are:

• Initiator (or end-user): initiates the request to Chainlink Functions. It can be an EOA (Externally Owned Account) or Chainlink Automation.
• Consumer contract: smart contract deployed by developers, which purpose is to interact with the FunctionsRouter to initiate a request.
• FunctionsRouter contract: manages subscriptions and is the entry point for consumers. The interface of the router is stable. Consumers call the sendRequest method to initiate a request.
• FunctionsCoordinator contracts: interface for the Decentralized Oracle Network. Oracle nodes listen to events emitted by the coordinator contract and interact with the coordinator to transmit the responses.
• DON: Chainlink Functions are powered by a Decentralized Oracle Network. The oracle nodes are independent of each other and are responsible for executing the request's source code. The nodes use the Chainlink OCR protocol to aggregate all the nodes' responses. Finally, a DON's oracle sends the aggregate response to the consumer contract in a callback.
• Secrets endpoint: To transmit their secrets, users can encrypt them with the DON public key and then upload them to the secrets endpoint, a highly available service for securely sharing encrypted secrets with the nodes. Note: An alternative method involves self-hosting secrets. In this approach, users provide a publicly accessible HTTP(s) URL, allowing nodes to retrieve the encrypted secrets. Refer to the secrets management page for detailed information on both methods.
• Serverless Environment: Every Oracle node accesses a distinct, sandboxed environment for computation. While the diagram illustrates an API request, the computation isn't restricted solely to this. You can perform any computation, from API calls to mathematical operations, using vanilla Deno code without module imports. Note: All nodes execute identical computations. If the target API has throttling limits, know that multiple simultaneous calls will occur since each DON node will independently run the request's source code.

Let's walk through the sequence of interactions among these components, as illustrated in the diagram:

1. If there are secrets, a user encrypts secrets with the public key linked to the DON master secret key (MSK) and then uploads the encrypted secrets to the secrets endpoint. The secrets endpoint pushes the encrypted secrets to the nodes part of the DON (The secrets capability depicted in this diagram is called threshold encryption and is explained in secrets management).
2. An EOA (Externally Owned Account) or Chainlink Automation initiates the request by calling the consumer contract.
3. The consumer contract should inherit the FunctionsClient contract. This ensures it will be able to receive responses from the FunctionsRouter contract via the handleOracleFulfillment callback. The router contract starts the billing to estimate the fulfillment costs and block the amount in the reservation balance (To learn more, read Cost simulation). Then it calls the FunctionsCoordinator contract.
4. The coordinator contract emits an OracleRequest event containing information about the request.
5. On reception of the event by the DON, the DON's nodes decrypt the secrets using threshold decryption (The threshold encryption feature is explained in secrets management). Each DON's Oracle node executes the request's source code in a serverless environment.
6. The DON runs the Offchain Reporting protocol (OCR) to aggregate the values returned by each node's execution of the source code.
7. A DON's oracle node transmits the attested report (which includes the aggregated response) to the FunctionsCoordinator contract.
8. The FunctionsCoordinator contract calls the FunctionsRouter's fulfill method to calculate the fulfillment costs and finalize the billing (To learn more, read Cost calculation).
9. The FunctionsRouter contract calls the consumer contract's callback with the aggregated response.

Note: Chainlink Functions requests are not limited to API requests. The diagram depicts an example of API requests, but you can request the DON to run any computation.

## Subscription management
Chainlink Functions do not require your consumer contracts to hold LINK tokens and send them to oracles when making requests. Instead, you must create a subscription account and fund it to pay for your Chainlink Functions requests, so your consumer contracts don't need to hold LINK when calling Chainlink Functions.

### Concepts

• Terms of service (ToS): Before interacting with Chainlink Functions, users must agree to the terms of service. Once signed, the accounts that can manage subscriptions are added to the allowedSenders in the ToS allow list contract.
• Chainlink Functions Subscription Manager: A user interface that allows users to agree to the sign Terms of service and interact with the FunctionsRouter to manage subscriptions.
• Subscription account: An account that holds LINK tokens and makes them available to fund requests to Chainlink DON. A Subscription ID uniquely identifies each account.
• Subscription ID: 64-bit unsigned integer representing the unique identifier of the Subscription account.
• Subscription owner: The wallet address that creates and manages a Subscription account. Any account can add LINK tokens to the subscription balance. Still, only the owner can add consumer contracts to the subscription, remove consumer contracts from the subscription, withdraw funds, or transfer a subscription. Only the subscription owner can generate encrypted secrets for requests that use their Subscription ID.
• Subscription balance: The amount of LINK maintained on your Subscription account. Requests from consumer contracts are funded as long as sufficient funds are in the balance, so be sure to maintain sufficient funds in your Subscription balance to pay for the requests and keep your applications running.
• Subscription reservation: The amount of LINK blocked on the Subscription balance. It corresponds to the total LINK amount to be paid by in-flight requests.
• Effective balance: The amount of LINK available on your Subscription account. Effective balance = Subscription balance - Subscription reservation.
• Subscription consumers: Consumer contracts are approved to use funding from your Subscription account while making Chainlink Functions requests. The consumers receive response data in a callback.

### Accept ToS
To ensure compliance and governance, Chainlink Functions mandates that any account that manages a subscription must first accept the platform's Terms of Service (ToS). The acceptance is verified by cross-referencing the account with the allowedSenders registry contained within the TermsOfServiceAllowList contract.

The acceptance process is initiated via the Chainlink Functions Subscription Manager. After a user accepts the ToS by generating the required signature with their externally owned account (EOA), they transmit proof of acceptance to the TermsOfServiceAllowList contract. Upon successful validation of the proof, the EOA is added to the allowedSenders registry, permitting it to manage subscriptions.

### Create subscription
After the ToS is accepted, EOAs can create subscriptions. Upon creation, the FunctionsRouter assigns a unique identifier, Subscription ID.

Note: EOAs can directly interact with the FunctionsRouter contract using their preferred web3 library, such as web3.js or ethers.js.

### Fund subscription
You must fund your subscription accounts with enough LINK tokens:

1. Connect your EOA to the Chainlink Functions Subscription Manager.
2. Fund your subscription account. The Chainlink Functions Subscription Manager abstracts the following:

Call transferAndCall on the LINK token contract, transferring LINK tokens along with the Subscription ID in the payload.
The FunctionsRouter contract implements onTokenTransfer: It parses the Subscription ID from the payload and funds the subscription account with the transferred LINK amount.

Note: EOAs can directly interact with the LinkToken contract using their preferred web3 library, such as web3.js or ethers.js.

### Add consumer
You must allowlist your consumers' contracts on your subscription account before they can make Chainlink Functions requests:

1. Connect your EOA to the Chainlink Functions Subscription Manager.
2. Add the address of the consumer contract to the subscription account.
3. The Chainlink Functions Subscription Manager interacts with the FunctionsRouter contract to register the consumer contract address to the subscription account.

Note: EOAs can directly interact with the FunctionsRouter contract using a web3 library, such as web3.js or ethers.js.

### Remove consumer
To prevent further Chainlink Functions requests from a given consumer contract, you must remove it from your subscription account:

1. Connect your EOA to the Chainlink Functions Subscription Manager.
2. Remove the address of the consumer contract from the subscription account.
3. The Chainlink Functions Subscription Manager communicates with the FunctionsRouter contract to remove the consumer contract address from the subscription account.

Note: You can still remove consumers from your subscription even if in-flight requests exist. The consumer contract will still receive a callback, and your Subscription Account will be charged.

Note: EOAs can directly interact with the FunctionsRouter contract using a web3 library, such as web3.js or ethers.js.

### Cancel subscription
To cancel a subscription:

1. Connect your EOA to the Chainlink Functions Subscription Manager.
2. Cancel your subscription, providing the Subscription Balance receiver account address. The Chainlink Functions Subscription Manager handles the following processes:

Invokes the cancelSubscription function on the FunctionsRouter contract, deleting the Subscription ID and removing all associated consumers.
Transfers the remaining Subscription Balance to the specified receiver account.

Note: EOAs can directly interact with the FunctionsRouter contract using their preferred web3 library, such as web3.js or ethers.js.

Note: Subscriptions cannot be canceled while there are in-flight requests. Furthermore, any expired requests (requests that have yet to receive a response within 5 minutes) must be timed out before cancellation.

### Transferring ownership of a Subscription
Transferring ownership is currently only supported using the Functions Hardhat Starter kit or the Functions Toolkit NPM package:

1. Use the functions-sub-transfer command to initiate the transfer of ownership by specifying the new owner's address.
2. As a prerequisite, the prospective owner must be part of the allowedSenders registry within the TermsOfServiceAllowList contract. This verifies their acceptance of the Chainlink Functions' Terms of Service (ToS).
3. The prospective owner should use the Functions Hardhat Starter kit and run the functions-sub-accept command to confirm the ownership transfer.

Note: This guide will be updated as soon as the Chainlink Functions Subscription Manager supports ownership transfers.

================================================================================

# Chainlink Functions Billing

Source: https://docs.chain.link/chainlink-functions/resources/billing
Extraction Method: playwright
Components: code_block(2), table(9)

# Chainlink Functions Billing

## Request costs
To send Chainlink Functions requests, you must maintain a sufficient amount of LINK in your subscription balance. Because Chainlink Functions follows the Request and Receive Data model, billing is done in two steps:

1. During the request step, the cost to fulfill a Chainlink Functions request is estimated and blocked on the subscription balance by adding it to the subscription reservation.
2. During the receive step, the exact fulfillment cost is calculated, then billed to the subscription account, and the subscription reservation is removed.

You can break down total costs into the following components:

• Gas cost: This cost is paid back to the transmitter oracle in LINK for fulfilling the request.
• Premium fees: These fees are paid in LINK to compensate nodes for their work and for the maintenance of the FunctionsRouter contract.

Gas cost calculation includes the following variables:

• Gas price: The current gas price fluctuates depending on network conditions.
• Overestimated gas price: refers to a deliberately higher gas price estimation to account for potential price fluctuations between the time a request is made and the time Chainlink Functions fulfills it. By setting the gas price higher than the current one, Chainlink Functions increases the likelihood that the request will be fulfilled, even if gas prices rise unexpectedly in the short term. The overestimation is calculated as a percentage increase over the current gas price.
• Callback gas: The amount of gas used for the callback request. See the Cost Calculation section.
• Callback gas limit: The maximum amount of gas that can be used to call the handleOracleFulfillment callback function of the consumer contract in order to provide the response. See the Cost Simulation section.
• Gas overhead: The amount of gas used by the FunctionsRouter and FunctionsCoordinator contracts. It is an estimate of the total gas cost of fulfilling a request.
• Native to LINK translation: Your subscription balance can be billed only in LINK tokens.

Translate the network's native gas tokens to LINK: The total gas cost in native units is translated using the correct Price Feed. For example, on Sepolia, the translation uses the ETH/LINK Price Feed, and on Polygon, the translation uses POL/LINK Price Feed.
Fallback Wei to LINK ratio: In the unlikely event that the Native to LINK price data feed is unavailable, the fallback translation is used. You can find this ratio by running the getConfig function in the FunctionsCoordinator contract. See the Supported Networks page to find the contract addresses for each network.

### Cost simulation (reservation)
During the request step:

1. The total cost in LINK is estimated using the following formula:
total estimated gas cost in LINK = (Overestimated gas price * (Gas overhead + Callback gas limit)) / Native to LINK translation

total estimated cost in LINK = total estimated gas cost + premium fees

All networks have USD-denominated premium fees. This means that the fixed premium fee is denominated in USD, but no USD is ever used. The LINK equivalent of this fee is calculated at request time.
2. The total estimated cost is then added to the subscription reservation.

### Cost calculation (fulfillment)
When a DON's oracle reports the response, subscription accounts are charged based on the gas amount used in the callback:

1. The total cost in LINK is calculated using the following formula:
total gas cost in LINK = (Gas price * (Gas overhead + Callback gas)) / Native to LINK translation

total cost in LINK = total gas cost + premium fees

All networks have USD-denominated premium fees. This means that the fixed premium fee is denominated in USD, but no USD is ever used. The LINK equivalent of this fee is calculated at request time.
2. The FunctionsRouter contract performs several accounting movements.

### Cost calculation example
This is an example of cost estimation for a request and then cost calculation at fulfillment.

For networks with USD-denominated premium fees, the premium fees are set in USD, but no USD is ever used. The LINK equivalent of the fee is calculated at request time, and then deducted from your subscription in LINK at response time.

#### Cost Simulation (Reservation)

Parameter | Value
--- | ---
Overestimated gas price | 9 gwei
Callback gas limit | 300000
Gas overhead | 185000
Premium fee | 320 cents USD

1. Calculate the total estimated gas cost in LINK, using an overestimated gas price, the gas overhead, and the full callback gas limit:
Gas cost calculationTotal estimated gas costOverestimated gas price x (Gas overhead + Callback gas limit)9 gwei x (300000 + 185000)4365000 gwei (0.004365 ETH)
2. Convert the gas cost to LINK using the LINK/ETH feed.
For this example, assume the feed returns a conversion value of Ξ0.007 ETH per 1 LINK.
ETH to LINK cost conversionTotal gas cost (LINK)0.004365 ETH / 0.007 ETH/LINK0.62 LINK
3. Convert the USD-denominated premium fee to LINK using the LINK/USD feed.
For this example, assume the feed returns a conversion value of $20.00 USD per 1 LINK:
USD to LINK cost conversionPremium fee (LINK)$3.20 USD / 20.00 USD/LINK0.16 LINK
4. Add the converted premium fee to get the estimated cost for a subscription reservation:
Adding converted LINK premiumMaximum request cost (LINK)Total gas cost (LINK) + Premium fee0.62 LINK + 0.16 LINK0.78 LINK

For this example request, 0.78 LINK is reserved from your subscription balance, but not yet deducted. When the request is fulfilled, the exact request cost is deducted. The estimated cost of a request is overestimated to allow for 99% of gas price fluctuation increases in between request and response time.

#### Cost calculation (fulfillment)

Parameter | Value
--- | ---
Gas price | 1.5 gwei
Callback gas | 200000
Gas overhead | 185000
Premium fee converted to LINK | 0.16 LINK

1. Calculate the total gas cost:
Gas cost calculationTotal gas costGas price x (Gas overhead + Callback gas)1.5 gwei x (200000 + 185000)577500 gwei (0.0005775 ETH)
2. Convert the gas cost to LINK using the LINK/ETH feed.
For this example, assume the feed returns a conversion value of Ξ0.007 ETH per 1 LINK.
ETH to LINK cost conversionTotal gas cost (LINK)0.0005775 ETH / 0.007 ETH/LINK0.0825 LINK
3. The premium fee was converted from USD to LINK at the time of the request. Add this converted premium fee to get the total cost of a request:
Adding premium feeTotal request cost (LINK)Total gas cost (LINK) + premium fee0.0825 LINK + 0.16 LINK0.2425 LINK

This example request would cost 0.2425 LINK when it is fulfilled. The subscription reservation for the 0.78 LINK is released, and the actual cost of 0.2425 LINK is deducted from your subscription balance.

## Minimum balance for uploading encrypted secrets
If you choose to store the encrypted secrets with the DON (learn more on the Secrets Management page), then one of your subscriptions must maintain a balance greater than the minimum required for uploading encrypted secrets. This balance is blockchain-specific. You can find the specific values for each blockchain on the Supported Networks page.
Note: Uploading encrypted secrets is free of charge. However, to prevent misuse of Chainlink Functions, you are required to maintain a minimum balance in one of the subscriptions owned by your externally-owned account (EOA) before you can upload encrypted secrets to a DON.

## Withdrawing funds
To withdraw your LINK balance, you must first cancel your subscription. To prevent misuse of Chainlink Functions, any subscription with fulfilled requests below the request threshold will incur a cancellation fee. Both the request threshold and the cancellation fee are blockchain-specific. You can find their values for each blockchain on the Supported Networks page.

Example 1:

• Request Threshold: Two requests
• Cancellation Fee: 0.5 LINK
• Your Balance: 0.4 LINK
• Number of Fulfilled Requests: One
• Outcome: Canceling your subscription results in a non-refundable balance

Example 2:

• Request Threshold: Two requests
• Cancellation Fee: 0.5 LINK
• Your Balance: 1 LINK
• Number of Fulfilled Requests: One
• Outcome: You will receive 0.5 LINK if you cancel your subscription

Example 3:

• Request Threshold: Two requests
• Cancellation Fee: 0.5 LINK
• Your Balance: 1 LINK
• Number of Fulfilled Requests: Two or more
• Outcome: You will receive 1 LINK if you cancel your subscription. Your subscription will not incur the cancellation fee

================================================================================

# Supported Networks

Source: https://docs.chain.link/chainlink-functions/supported-networks
Extraction Method: playwright
Components: table(36)

# Supported Networks
astro-island,astro-slot,astro-static-slot{display:contents}(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).only=e;window.dispatchEvent(new Event("astro:only"));})();(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();Read the LINK Token Contracts page to learn where to get testnet LINK and ETH.

To use Chainlink Functions on certain networks, you may need to conduct token transfers. You can transfer tokens by using Chainlink CCIP, Transporter or third-party applications such as XSwap.

[Image: note]Interfaces and Applications

Chainlink CCIP is a messaging protocol. Third parties may build user interfaces or other applications on top of CCIP.
Neither Chainlink Labs nor the Chainlink Foundation owns, controls, endorses, or assumes any responsibility for any
such interfaces or applications. You are solely responsible for your use of such interfaces or applications. Please
visit the Chainlink Foundation Terms of Service for more information.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }[Image: caution]Understand Risks associated with Bridges

If you are using a cross-chain bridge to transfer your LINK tokens, read the Bridges and Associated Risks guide to understand what cross-chain bridges are and the risks associated with using them.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
## Arbitrum
[Image: note]USD-denominated premium fees

The fixed premium fee is denominated in USD but no USD is ever used. The LINK equivalent of the fee is calculated at
request time, and then deducted from your subscription in LINK at response time. See the example cost
calculation for more information.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
### Arbitrum Mainnet

Item | Value
--- | ---
Functions router | 0x97083e831f8f0638855e2a515c90edcf158df238
DON ID | fun-arbitrum-mainnet-1 / 0x6675...0000
Encrypted secrets upload endpoints | https://01.functions-gateway.chain.link/https://02.functions-gateway.chain.link/

Billing Item | Value
--- | ---
Premium fees | 3 cents USD
Request threshold (withdrawing funds) | 10 requests
Cancellation fees (withdrawing funds) | 0.1 LINK
Minimum balance for uploading encrypted secrets | 0.1 LINK

### Arbitrum Sepolia Testnet

Item | Value
--- | ---
Functions router | 0x234a5fb5Bd614a7AA2FfAB244D603abFA0Ac5C5C
DON ID | fun-arbitrum-sepolia-1 / 0x6675...0000
Encrypted secrets upload endpoints | https://01.functions-gateway.testnet.chain.link/https://02.functions-gateway.testnet.chain.link/

Billing Item | Value
--- | ---
Premium fees | 320 cents USD
Request threshold (withdrawing funds) | 10 requests
Cancellation fees (withdrawing funds) | 2 LINK
Minimum balance for uploading encrypted secrets | 2 LINK

## Avalanche
[Image: note]USD-denominated premium fees

The fixed premium fee is denominated in USD but no USD is ever used. The LINK equivalent of the fee is calculated at
request time, and then deducted from your subscription in LINK at response time. See the example cost
calculation for more information.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
### Avalanche Mainnet

Item | Value
--- | ---
Functions router | 0x9f82a6A0758517FD0AfA463820F586999AF314a0
DON ID | fun-avalanche-mainnet-1 / 0x6675...0000
Encrypted secrets upload endpoints | https://01.functions-gateway.chain.link/https://02.functions-gateway.chain.link/

Billing Item | Value
--- | ---
Premium fees | 3 cents USD
Request threshold (withdrawing funds) | 1 request
Cancellation fees (withdrawing funds) | 1 LINK
Minimum balance for uploading encrypted secrets | 1 LINK

### Avalanche Fuji Testnet

Item | Value
--- | ---
Functions router | 0xA9d587a00A31A52Ed70D6026794a8FC5E2F5dCb0
DON ID | fun-avalanche-fuji-1 / 0x6675...0000
Encrypted secrets upload endpoints | https://01.functions-gateway.testnet.chain.link/https://02.functions-gateway.testnet.chain.link/

Billing Item | Value
--- | ---
Premium fees | 320 cents USD
Request threshold (withdrawing funds) | 10 requests
Cancellation fees (withdrawing funds) | 2 LINK
Minimum balance for uploading encrypted secrets | 2 LINK

## BASE
[Image: note]USD-denominated premium fees

The fixed premium fee is denominated in USD but no USD is ever used. The LINK equivalent of the fee is calculated at
request time, and then deducted from your subscription in LINK at response time. See the example cost
calculation for more information.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
### BASE Mainnet

Item | Value
--- | ---
Functions router | 0xf9b8fc078197181c841c296c876945aaa425b278
DON ID | fun-base-mainnet-1 / 0x6675...0000
Encrypted secrets upload endpoints | https://01.functions-gateway.chain.link/https://02.functions-gateway.chain.link/

Billing Item | Value
--- | ---
Premium fees (converted to LINK at request time) | 3 cents USD
Request threshold (withdrawing funds) | 1 request
Cancellation fees (withdrawing funds) | 0.1 LINK
Minimum balance for uploading encrypted secrets | 0.1 LINK

### BASE Sepolia Testnet

Item | Value
--- | ---
Functions router | 0xf9B8fc078197181C841c296C876945aaa425B278
DON ID | fun-base-sepolia-1 / 0x6675...0000
Encrypted secrets upload endpoints | https://01.functions-gateway.testnet.chain.link/https://02.functions-gateway.testnet.chain.link/

Billing Item | Value
--- | ---
Premium fees (converted to LINK at request time) | 320 cents USD
Request threshold (withdrawing funds) | 10 requests
Cancellation fees (withdrawing funds) | 2 LINK
Minimum balance for uploading encrypted secrets | 2 LINK

## Celo
[Image: note]USD-denominated premium fees

The fixed premium fee is denominated in USD but no USD is ever used. The LINK equivalent of the fee is calculated at
request time, and then deducted from your subscription in LINK at response time. See the example cost
calculation for more information.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
### Celo Mainnet

Item | Value
--- | ---
Functions router | 0xd74646C75163f9dA0F3666C3BE8A9C42F4b3b261
DON ID | fun-celo-mainnet-1 / 0x6675...0000
Encrypted secrets upload endpoints | https://01.functions-gateway.chain.link/https://02.functions-gateway.chain.link/

Billing Item | Value
--- | ---
Premium fees (converted to LINK at request time) | 3 cents USD
Request threshold (withdrawing funds) | 1 request
Cancellation fees (withdrawing funds) | 0.1 LINK
Minimum balance for uploading encrypted secrets | 0.1 LINK

### Celo Alfajores Testnet

Item | Value
--- | ---
Functions router | 0x53BA5D8E5aab0cf9589aCE139666Be2b9Fd268e2
DON ID | fun-celo-alfajores-1 / 0x6675...0000
Encrypted secrets upload endpoints | https://01.functions-gateway.testnet.chain.link/https://02.functions-gateway.testnet.chain.link/

Billing Item | Value
--- | ---
Premium fees (converted to LINK at request time) | 320 cents USD
Request threshold (withdrawing funds) | 10 requests
Cancellation fees (withdrawing funds) | 2 LINK
Minimum balance for uploading encrypted secrets | 2 LINK

## Ethereum
[Image: note]USD-denominated premium fees

The fixed premium fee is denominated in USD but no USD is ever used. The LINK equivalent of the fee is calculated at
request time, and then deducted from your subscription in LINK at response time. See the example cost
calculation for more information.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
### Ethereum Mainnet

Item | Value
--- | ---
Functions router | 0x65Dcc24F8ff9e51F10DCc7Ed1e4e2A61e6E14bd6
DON ID | fun-ethereum-mainnet-1 / 0x6675...0000
Encrypted secrets upload endpoints | https://01.functions-gateway.chain.link/https://02.functions-gateway.chain.link/

Billing Item | Value
--- | ---
Premium fees | 400 cents USD
Request threshold (withdrawing funds) | 1 request
Cancellation fees (withdrawing funds) | 1 LINK
Minimum balance for uploading encrypted secrets | 1 LINK

### Sepolia Testnet

Item | Value
--- | ---
Functions router | 0xb83E47C2bC239B3bf370bc41e1459A34b41238D0
DON ID | fun-ethereum-sepolia-1 / 0x6675...0000
Encrypted secrets upload endpoints | https://01.functions-gateway.testnet.chain.link/https://02.functions-gateway.testnet.chain.link/

Billing Item | Value
--- | ---
Premium fees | 320 cents USD
Request threshold (withdrawing funds) | 10 requests
Cancellation fees (withdrawing funds) | 2 LINK
Minimum balance for uploading encrypted secrets | 2 LINK

## OP
[Image: note]USD-denominated premium fees

The fixed premium fee is denominated in USD but no USD is ever used. The LINK equivalent of the fee is calculated at
request time, and then deducted from your subscription in LINK at response time. See the example cost
calculation for more information.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
### OP Mainnet

Item | Value
--- | ---
Functions router | 0xaA8AaA682C9eF150C0C8E96a8D60945BCB21faad
DON ID | fun-optimism-mainnet-1 / 0x6675...0000
Encrypted secrets upload endpoints | https://01.functions-gateway.chain.link/https://02.functions-gateway.chain.link/

Billing Item | Value
--- | ---
Premium fees (converted to LINK at request time) | 3 cents USD
Request threshold (withdrawing funds) | 1 request
Cancellation fees (withdrawing funds) | 0.1 LINK
Minimum balance for uploading encrypted secrets | 0.1 LINK

### OP Sepolia

Item | Value
--- | ---
Functions router | 0xC17094E3A1348E5C7544D4fF8A36c28f2C6AAE28
DON ID | fun-optimism-sepolia-1 / 0x6675...0000
Encrypted secrets upload endpoints | https://01.functions-gateway.testnet.chain.link/https://02.functions-gateway.testnet.chain.link/

Billing Item | Value
--- | ---
Premium fees (converted to LINK at request time) | 320 cents USD
Request threshold (withdrawing funds) | 10 requests
Cancellation fees (withdrawing funds) | 2 LINK
Minimum balance for uploading encrypted secrets | 2 LINK

## Polygon
[Image: note]USD-denominated premium fees

The fixed premium fee is denominated in USD but no USD is ever used. The LINK equivalent of the fee is calculated at
request time, and then deducted from your subscription in LINK at response time. See the example cost
calculation for more information.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
### Polygon Mainnet

Item | Value
--- | ---
Functions router | 0xdc2AAF042Aeff2E68B3e8E33F19e4B9fA7C73F10
DON ID | fun-polygon-mainnet-1 / 0x6675...0000
Encrypted secrets upload endpoints | https://01.functions-gateway.chain.link/https://02.functions-gateway.chain.link/

Billing Item | Value
--- | ---
Premium fees | 3 cents USD
Request threshold (withdrawing funds) | 1 request
Cancellation fees (withdrawing funds) | 1 LINK
Minimum balance for uploading encrypted secrets | 1 LINK

### Polygon Amoy Testnet

Item | Value
--- | ---
Functions router | 0xC22a79eBA640940ABB6dF0f7982cc119578E11De
DON ID | fun-polygon-amoy-1 / 0x6675...0000
Encrypted secrets upload endpoints | https://01.functions-gateway.testnet.chain.link/https://02.functions-gateway.testnet.chain.link/

Billing Item | Value
--- | ---
Premium fees (converted to LINK at request time) | 320 cents USD
Request threshold (withdrawing funds) | 10 requests
Cancellation fees (withdrawing funds) | 2 LINK
Minimum balance for uploading encrypted secrets | 2 LINK

## Soneium
[Image: note]USD-denominated premium fees

The fixed premium fee is denominated in USD but no USD is ever used. The LINK equivalent of the fee is calculated at
request time, and then deducted from your subscription in LINK at response time. See the example cost
calculation for more information.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
### Soneium Mainnet

Item | Value
--- | ---
Functions router | 0x20fef1B12FA78fAc8CFB8a7ac1bf032Bd8DcAdDa
DON ID | fun-soneium-mainnet-1 / 0x6675...0000
Encrypted secrets upload endpoints | https://01.functions-gateway.chain.link/https://02.functions-gateway.chain.link/

Billing Item | Value
--- | ---
Premium fees (converted to LINK at request time) | 3 cents USD
Request threshold (withdrawing funds) | 1 requests
Cancellation fees (withdrawing funds) | 0.1 LINK
Minimum balance for uploading encrypted secrets | 0.1 LINK

### Soneium Minato Testnet

Item | Value
--- | ---
Functions router | 0x3704dc1eefCDCE04C58813836AEcfdBC8e7cB3D8
DON ID | fun-soneium-sepolia-1 / 0x6675...0000
Encrypted secrets upload endpoints | https://01.functions-gateway.testnet.chain.link/https://02.functions-gateway.testnet.chain.link/

Billing Item | Value
--- | ---
Premium fees (converted to LINK at request time) | 320 cents USD
Request threshold (withdrawing funds) | 10 requests
Cancellation fees (withdrawing funds) | 2 LINK
Minimum balance for uploading encrypted secrets | 2 LINK

## ZKSync
[Image: note]USD-denominated premium fees

The fixed premium fee is denominated in USD but no USD is ever used. The LINK equivalent of the fee is calculated at
request time, and then deducted from your subscription in LINK at response time. See the example cost
calculation for more information.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
### ZKSync Mainnet

Item | Value
--- | ---
Functions router | 0x70eb02f47e7F492e57A9D05578f275Cdde0b3d4c
DON ID | fun-zksync-mainnet-1 / 0x6675...0000
Encrypted secrets upload endpoints | https://01.functions-gateway.chain.link/https://02.functions-gateway.chain.link/

Billing Item | Value
--- | ---
Premium fees (converted to LINK at request time) | 3 cents USD
Request threshold (withdrawing funds) | 1 requests
Cancellation fees (withdrawing funds) | 0.1 LINK
Minimum balance for uploading encrypted secrets | 0.1 LINK

### ZKSync Sepolia Testnet

Item | Value
--- | ---
Functions router | 0x2053f087Df166772423Aeb8d270d64fD71f303E9
DON ID | fun-zksync-sepolia-1 / 0x6675...0000
Encrypted secrets upload endpoints | https://01.functions-gateway.testnet.chain.link/https://02.functions-gateway.testnet.chain.link/

Billing Item | Value
--- | ---
Premium fees (converted to LINK at request time) | 320 cents USD
Request threshold (withdrawing funds) | 10 requests
Cancellation fees (withdrawing funds) | 2 LINK
Minimum balance for uploading encrypted secrets | 2 LINK

================================================================================

# Call an API with HTTP Query Parameters

Source: https://docs.chain.link/chainlink-functions/tutorials/api-query-parameters
Extraction Method: playwright
Components: code_block(22)

# Call an API with HTTP Query Parameters
This tutorial shows you how to send a request to a Decentralized Oracle Network to call the Cryptocompare GET /data/pricemultifull API. After OCR completes offchain computation and aggregation, it returns the asset price for ETH/USD to your smart contract. This guide also shows you how to configure HTTP query parameters to request different asset prices.

[Image: note]note

Chainlink Functions is a self-service solution. You must ensure that the data sources or APIs specified in requests
are of sufficient quality and have the proper availability for your use case. You are responsible for complying with
the licensing agreements for all data providers that you connect with through Chainlink Functions. Violations of data
provider licensing agreements or the terms can result in suspension or termination of your
Chainlink Functions account.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
## Prerequisites
[Image: note]note

You might skip these prerequisites if you have followed one of these guides. You can
check your subscription details (including the balance in LINK) in the Chainlink Functions Subscription
Manager. If your subscription runs out of LINK, follow the Fund a
Subscription guide.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
### Set up your environment
You must provide the private key from a testnet wallet to run the examples in this documentation. Install a Web3 wallet, configure Node.js, clone the smartcontractkit/smart-contract-examples repository, and configure a .env.enc file with the required environment variables.

Install and configure your Web3 wallet for Ethereum Sepolia:

1. Install Deno so you can compile and simulate your Functions source code on your local machine.
2. Install the MetaMask wallet or other Ethereum Web3 wallet.
3. Set the network for your wallet to the Sepolia testnet. If you need to add Sepolia to your wallet, you can find the chain ID and the LINK token contract address on the LINK Token Contracts page.

Sepolia testnet and LINK token contract
4. Request testnet LINK and ETH from faucets.chain.link/sepolia.

Install the required frameworks and dependencies:

1. Install the latest release of Node.js 20. Optionally, you can use the nvm package to switch between Node.js versions with nvm use 20.
Note: To ensure you are running the correct version in a terminal, type node -v.
node -v

$ node -v
v20.9.0
2. In a terminal, clone the smart-contract examples repository and change directories. This example repository imports the Chainlink Functions Toolkit NPM package. You can import this package to your own projects to enable them to work with Chainlink Functions.
git clone https://github.com/smartcontractkit/smart-contract-examples.git && \
cd ./smart-contract-examples/functions-examples/
3. Run npm install to install the dependencies.
npm install
4. For higher security, the examples repository encrypts your environment variables at rest.

Set an encryption password for your environment variables.
npx env-enc set-pw

Run npx env-enc set to configure a .env.enc file with the basic variables that you need to send your requests to the Sepolia network.

ETHEREUM_SEPOLIA_RPC_URL: Set a URL for the Sepolia testnet. You can sign up for a personal endpoint from Alchemy, Infura, or another node provider service.

PRIVATE_KEY: Find the private key for your testnet wallet. If you use MetaMask, follow the instructions to Export a Private Key. Note: Your private key is needed to sign any transactions you make such as making requests.

npx env-enc set

### Configure your onchain resources
After you configure your local environment, configure some onchain resources to process your requests, receive the responses, and pay for the work done by the DON.

#### Deploy a Functions consumer contract on Sepolia

1. Open the FunctionsConsumerExample.sol contract in Remix.

Open in Remix
What is Remix?
2. Compile the contract.
3. Open MetaMask and select the Sepolia network.
4. In Remix under the Deploy & Run Transactions tab, select Injected Provider - MetaMask in the Environment list. Remix will use the MetaMask wallet to communicate with Sepolia.
5. Under the Deploy section, fill in the router address for your specific blockchain. You can find both of these addresses on the Supported Networks page. For Sepolia, the router address is 0xb83E47C2bC239B3bf370bc41e1459A34b41238D0.
6. Click the Deploy button to deploy the contract. MetaMask prompts you to confirm the transaction. Check the transaction details to make sure you are deploying the contract to Sepolia.
7. After you confirm the transaction, the contract address appears in the Deployed Contracts list. Copy the contract address.

#### Create a subscription
Follow the Managing Functions Subscriptions guide to accept the Chainlink Functions Terms of Service (ToS), create a subscription, fund it, then add your consumer contract address to it.

You can find the Chainlink Functions Subscription Manager at functions.chain.link.

## Tutorial
This tutorial is configured to get the ETH/USD price. For a detailed explanation of the code example, read the Examine the code section.

You can locate the scripts used in this tutorial in the examples/2-call-api directory.

To run the example:

1. Open the file request.js, which is located in the 2-call-api folder.
2. Replace the consumer contract address and the subscription ID with your own values.
const consumerAddress = "0x8dFf78B7EE3128D00E90611FBeD20A71397064D9" // REPLACE this with your Functions consumer address
const subscriptionId = 3 // REPLACE this with your subscription ID
3. Make a request:
node examples/2-call-api/request.js

The script runs your function in a sandbox environment before making an onchain transaction:
$ node examples/2-call-api/request.js
secp256k1 unavailable, reverting to browser version
Start simulation...
 Simulation result {
   capturedTerminalOutput: 'HTTP GET Request to https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD\n' +
     'ETH price is: 3420.54 USD\n',
   responseBytesHexstring: '0x0000000000000000000000000000000000000000000000000000000000053826'
 }
 ✅ Decoded response to uint256:  342054n

 Estimate request costs...
 Fulfillment cost estimated to 1.004325887213695 LINK

 Make request...

 ✅ Functions request sent! Transaction hash 0xbbe473ccc6593b6f3baf30fd66b2329b05a32fe0321a319d09142f4b9ba4547c. Waiting for a response...
 See your request in the explorer https://sepolia.etherscan.io/tx/0xbbe473ccc6593b6f3baf30fd66b2329b05a32fe0321a319d09142f4b9ba4547c

 ✅ Request 0xe55201188012e3ec198427937f7897729999ab7b287207ff8f0c157a9662e5f0 successfully fulfilled. Cost is 0.249819373001796045 LINK.Complete response:  {
   requestId: '0xe55201188012e3ec198427937f7897729999ab7b287207ff8f0c157a9662e5f0',
   subscriptionId: 2303,
   totalCostInJuels: 249819373001796045n,
   responseBytesHexstring: '0x0000000000000000000000000000000000000000000000000000000000053892',
   errorString: '',
   returnDataBytesHexstring: '0x',
   fulfillmentCode: 0
 }

 ✅ Decoded response to uint256:  342162n

The output of the example gives you the following information:

Your request is first run on a sandbox environment to ensure it is correctly configured.

The fulfillment costs are estimated before making the request.

Your request was successfully sent to Chainlink Functions. The transaction in this example is 0xbbe473ccc6593b6f3baf30fd66b2329b05a32fe0321a319d09142f4b9ba4547c and the request ID is 0xe55201188012e3ec198427937f7897729999ab7b287207ff8f0c157a9662e5f0.

The DON successfully fulfilled your request. The total cost was: 0.249819373001796045 LINK.

The consumer contract received a response in bytes with a value of 0x0000000000000000000000000000000000000000000000000000000000053892. Decoding it offchain to uint256 gives you a result: 342162.

## Examine the code

### FunctionsConsumerExample.sol
[Image: copy to clipboard]
```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import {FunctionsClient} from "@chainlink/contracts/src/v0.8/functions/v1_0_0/FunctionsClient.sol";
import {ConfirmedOwner} from "@chainlink/contracts/src/v0.8/shared/access/ConfirmedOwner.sol";
import {FunctionsRequest} from "@chainlink/contracts/src/v0.8/functions/v1_0_0/libraries/FunctionsRequest.sol";

/**
 * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
 * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */
contract FunctionsConsumerExample is FunctionsClient, ConfirmedOwner {
    using FunctionsRequest for FunctionsRequest.Request;

    bytes32 public s_lastRequestId;
    bytes public s_lastResponse;
    bytes public s_lastError;

    error UnexpectedRequestID(bytes32 requestId);

    event Response(bytes32 indexed requestId, bytes response, bytes err);

    constructor(
        address router
    ) FunctionsClient(router) ConfirmedOwner(msg.sender) {}

    /**
     * @notice Send a simple request
     * @param source JavaScript source code
     * @param encryptedSecretsUrls Encrypted URLs where to fetch user secrets
     * @param donHostedSecretsSlotID Don hosted secrets slotId
     * @param donHostedSecretsVersion Don hosted secrets version
     * @param args List of arguments accessible from within the source code
     * @param bytesArgs Array of bytes arguments, represented as hex strings
     * @param subscriptionId Billing ID
     */
    function sendRequest(
        string memory source,
        bytes memory encryptedSecretsUrls,
        uint8 donHostedSecretsSlotID,
        uint64 donHostedSecretsVersion,
        string[] memory args,
        bytes[] memory bytesArgs,
        uint64 subscriptionId,
        uint32 gasLimit,
        bytes32 donID
    ) external onlyOwner returns (bytes32 requestId) {
        FunctionsRequest.Request memory req;
        req.initializeRequestForInlineJavaScript(source);
        if (encryptedSecretsUrls.length > 0)
            req.addSecretsReference(encryptedSecretsUrls);
        else if (donHostedSecretsVersion > 0) {
            req.addDONHostedSecrets(
                donHostedSecretsSlotID,
                donHostedSecretsVersion
            );
        }
        if (args.length > 0) req.setArgs(args);
        if (bytesArgs.length > 0) req.setBytesArgs(bytesArgs);
        s_lastRequestId = _sendRequest(
            req.encodeCBOR(),
            subscriptionId,
            gasLimit,
            donID
        );
        return s_lastRequestId;
    }

    /**
     * @notice Send a pre-encoded CBOR request
     * @param request CBOR-encoded request data
     * @param subscriptionId Billing ID
     * @param gasLimit The maximum amount of gas the request can consume
     * @param donID ID of the job to be invoked
     * @return requestId The ID of the sent request
     */
    function sendRequestCBOR(
        bytes memory request,
        uint64 subscriptionId,
        uint32 gasLimit,
        bytes32 donID
    ) external onlyOwner returns (bytes32 requestId) {
        s_lastRequestId = _sendRequest(
            request,
            subscriptionId,
            gasLimit,
            donID
        );
        return s_lastRequestId;
    }

    /**
     * @notice Store latest result/error
     * @param requestId The request ID, returned by sendRequest()
     * @param response Aggregated response from the user code
     * @param err Aggregated error from the user code or from the execution pipeline
     * Either response or error parameter will be set, but never both
     */
    function fulfillRequest(
        bytes32 requestId,
        bytes memory response,
        bytes memory err
    ) internal override {
        if (s_lastRequestId != requestId) {
            revert UnexpectedRequestID(requestId);
        }
        s_lastResponse = response;
        s_lastError = err;
        emit Response(requestId, s_lastResponse, s_lastError);
    }
}
```

[Open in Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/ChainlinkFunctions/FunctionsConsumerExample.sol&autoCompile=true)[What is Remix?](/getting-started/conceptual-overview#what-is-remix)
• To write a Chainlink Functions consumer contract, your contract must import FunctionsClient.sol and FunctionsRequest.sol. You can read the API references: FunctionsClient and FunctionsRequest.
These contracts are available in an NPM package, so you can import them from within your project.
import {FunctionsClient} from "@chainlink/contracts/src/v0.8/functions/v1_0_0/FunctionsClient.sol";
import {FunctionsRequest} from "@chainlink/contracts/src/v0.8/functions/v1_0_0/libraries/FunctionsRequest.sol";
• Use the FunctionsRequest.sol library to get all the functions needed for building a Chainlink Functions request.
using FunctionsRequest for FunctionsRequest.Request;
• The latest request id, latest received response, and latest received error (if any) are defined as state variables:
bytes32 public s_lastRequestId;
bytes public s_lastResponse;
bytes public s_lastError;
• We define the Response event that your smart contract will emit during the callback
event Response(bytes32 indexed requestId, bytes response, bytes err);
• Pass the router address for your network when you deploy the contract:
constructor(address router) FunctionsClient(router)
• The three remaining functions are:

sendRequest for sending a request. It receives the JavaScript source code, encrypted secretsUrls (in case the encrypted secrets are hosted by the user), DON hosted secrets slot id and version (in case the encrypted secrets are hosted by the DON), list of arguments to pass to the source code, subscription id, and callback gas limit as parameters. Then:

It uses the FunctionsRequestlibrary to initialize the request and add any passed encrypted secrets reference or arguments. You can read the API Reference for Initializing a request, adding user hosted secrets, adding DON hosted secrets, adding arguments, and adding bytes arguments.
FunctionsRequest.Request memory req;
req.initializeRequestForInlineJavaScript(source);
if (encryptedSecretsUrls.length > 0)
    req.addSecretsReference(encryptedSecretsUrls);
else if (donHostedSecretsVersion > 0) {
    req.addDONHostedSecrets(
        donHostedSecretsSlotID,
        donHostedSecretsVersion
    );
}
if (args.length > 0) req.setArgs(args);
if (bytesArgs.length > 0) req.setBytesArgs(bytesArgs);

It sends the request to the router by calling the FunctionsClient sendRequest function. You can read the API reference for sending a request. Finally, it stores the request id in s_lastRequestId then return it.
s_lastRequestId = _sendRequest(
    req.encodeCBOR(),
    subscriptionId,
    gasLimit,
    jobId
);
return s_lastRequestId;

Note: _sendRequest accepts requests encoded in bytes. Therefore, you must encode it using encodeCBOR.

sendRequestCBOR for sending a request already encoded in bytes. It receives the request object encoded in bytes, subscription id, and callback gas limit as parameters. Then, it sends the request to the router by calling the FunctionsClient sendRequest function. Note: This function is helpful if you want to encode a request offchain before sending it, saving gas when submitting the request.
• fulfillRequest to be invoked during the callback. This function is defined in FunctionsClient as virtual (read fulfillRequest API reference). So, your smart contract must override the function to implement the callback. The implementation of the callback is straightforward: the contract stores the latest response and error in s_lastResponse and s_lastError before emitting the Response event.
s_lastResponse = response;
s_lastError = err;
emit Response(requestId, s_lastResponse, s_lastError);

### JavaScript example

#### source.js
The Decentralized Oracle Network will run the JavaScript code. The code is self-explanatory and has comments to help you understand all the steps.

[Image: note]note

It is important to understand that importing an NPM package into Deno does not automatically ensure full compatibility. Deno and Node.js have distinct architectures and module systems. While some NPM packages might function without issues, others may need modifications or overrides, especially those relying on Node.js-specific APIs or features Deno does not support.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }This JavaScript source code uses Functions.makeHttpRequest to make HTTP requests. To request the ETH/USD price, the source code calls the https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD URL. If you read the Functions.makeHttpRequest documentation, you see that you must provide the following parameters:

• url: https://min-api.cryptocompare.com/data/pricemultifull
• params: The query parameters object:
{
  fsyms: fromSymbol,
  tsyms: toSymbol
}

To check the expected API response, you can directly paste the following URL in your browser https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD or run the curl command in your terminal:

[Image: copy to clipboard]
```bash
curl -X 'GET' \
  'https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD' \
  -H 'accept: application/json'
```

The response should be similar to the following example:

[Image: copy to clipboard]
```json
{
  "RAW": {
    "ETH": {
      "USD": {
        "TYPE": "5",
        "MARKET": "CCCAGG",
        "FROMSYMBOL": "ETH",
        "TOSYMBOL": "USD",
        "FLAGS": "2049",
        "PRICE": 2867.04,
        "LASTUPDATE": 1650896942,
        "MEDIAN": 2866.2,
        "LASTVOLUME": 0.16533939,
        "LASTVOLUMETO": 474.375243849,
        "LASTTRADEID": "1072154517",
        "VOLUMEDAY": 195241.78281014622,
        "VOLUMEDAYTO": 556240560.4621655,
        "VOLUME24HOUR": 236248.94641103,
        ...
}
```

The price is located at RAW,ETH,USD,PRICE.

The main steps of the scripts are:

• Fetch fromSymbol and toSymbol from args.
• Construct the HTTP object cryptoCompareRequest using Functions.makeHttpRequest.
• Make the HTTP call.
• Read the asset price from the response.
• Return the result as a buffer using the Functions.encodeUint256 helper function. Because solidity doesn't support decimals, multiply the result by 100 and round the result to the nearest integer. Note: Read this article if you are new to Javascript Buffers and want to understand why they are important.

#### request.js
This explanation focuses on the request.js script and shows how to use the Chainlink Functions NPM package in your own JavaScript/TypeScript project to send requests to a DON. The code is self-explanatory and has comments to help you understand all the steps.

The script imports:

• path and fs : Used to read the source file.
• ethers: Ethers.js library, enables the script to interact with the blockchain.
• @chainlink/functions-toolkit: Chainlink Functions NPM package. All its utilities are documented in the NPM README.
• @chainlink/env-enc: A tool for loading and storing encrypted environment variables. Read the official documentation to learn more.
• ../abi/functionsClient.json: The abi of the contract your script will interact with. Note: The script was tested with this FunctionsConsumerExample contract.

The script has two hardcoded values that you have to change using your own Functions consumer contract and subscription ID:

[Image: copy to clipboard]
```javascript
const consumerAddress = "0x8dFf78B7EE3128D00E90611FBeD20A71397064D9" // REPLACE this with your Functions consumer address
const subscriptionId = 3 // REPLACE this with your subscription ID
```

The primary function that the script executes is makeRequestSepolia. This function consists of five main parts:

1. Definition of necessary identifiers:

routerAddress: Chainlink Functions router address on Sepolia.
donId: Identifier of the DON that will fulfill your requests on Sepolia.
explorerUrl: Block explorer URL of the Sepolia testnet.
source: The source code must be a string object. That's why we use fs.readFileSync to read source.js and then call toString() to get the content as a string object.
args: During the execution of your function, These arguments are passed to the source code. The args value is ["ETH", "USD"], which fetches the current ETH/USD price. You can adapt args to fetch another asset price. See the CryptoCompare API docs to get the list of supported symbols.
gasLimit: Maximum gas that Chainlink Functions can use when transmitting the response to your contract.
Initialization of ethers signer and provider objects. The signer is used to make transactions on the blockchain, and the provider reads data from the blockchain.
2. Simulating your request in a local sandbox environment:

Use simulateScript from the Chainlink Functions NPM package.
Read the response of the simulation. If successful, use the Functions NPM package decodeResult function and ReturnType enum to decode the response to the expected returned type (ReturnType.uint256 in this example).
3. Estimating the costs:

Initialize a SubscriptionManager from the Functions NPM package, then call the estimateFunctionsRequestCost.
The response is returned in Juels (1 LINK = 10**18 Juels). Use the ethers.utils.formatEther utility function to convert the output to LINK.
4. Making a Chainlink Functions request:

Initialize your functions consumer contract using the contract address, abi, and ethers signer.
Call the sendRequest function of your consumer contract.
5. Waiting for the response:

Initialize a ResponseListener from the Functions NPM package and then call the listenForResponseFromTransaction function to wait for a response. By default, this function waits for five minutes.
Upon reception of the response, use the Functions NPM package decodeResult function and ReturnType enum to decode the response to the expected returned type (ReturnType.uint256 in this example).

================================================================================

# Request Computation

Source: https://docs.chain.link/chainlink-functions/tutorials/simple-computation
Extraction Method: playwright
Components: code_block(19)

# Request Computation
This tutorial shows you how to run computations on the Chainlink Functions Decentralized Oracle Network (DON). The example code computes the geometric mean of numbers in a list. After OCR completes offchain computation and aggregation, it returns the result to your smart contract.

## Prerequisites
[Image: note]note

You might skip these prerequisites if you have followed one of these guides. You can
check your subscription details (including the balance in LINK) in the Chainlink Functions Subscription
Manager. If your subscription runs out of LINK, follow the Fund a
Subscription guide.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
### Set up your environment
You must provide the private key from a testnet wallet to run the examples in this documentation. Install a Web3 wallet, configure Node.js, clone the smartcontractkit/smart-contract-examples repository, and configure a .env.enc file with the required environment variables.

Install and configure your Web3 wallet for Ethereum Sepolia:

1. Install Deno so you can compile and simulate your Functions source code on your local machine.
2. Install the MetaMask wallet or other Ethereum Web3 wallet.
3. Set the network for your wallet to the Sepolia testnet. If you need to add Sepolia to your wallet, you can find the chain ID and the LINK token contract address on the LINK Token Contracts page.

Sepolia testnet and LINK token contract
4. Request testnet LINK and ETH from faucets.chain.link/sepolia.

Install the required frameworks and dependencies:

1. Install the latest release of Node.js 20. Optionally, you can use the nvm package to switch between Node.js versions with nvm use 20.
Note: To ensure you are running the correct version in a terminal, type node -v.
node -v

$ node -v
v20.9.0
2. In a terminal, clone the smart-contract examples repository and change directories. This example repository imports the Chainlink Functions Toolkit NPM package. You can import this package to your own projects to enable them to work with Chainlink Functions.
git clone https://github.com/smartcontractkit/smart-contract-examples.git && \
cd ./smart-contract-examples/functions-examples/
3. Run npm install to install the dependencies.
npm install
4. For higher security, the examples repository encrypts your environment variables at rest.

Set an encryption password for your environment variables.
npx env-enc set-pw

Run npx env-enc set to configure a .env.enc file with the basic variables that you need to send your requests to the Sepolia network.

ETHEREUM_SEPOLIA_RPC_URL: Set a URL for the Sepolia testnet. You can sign up for a personal endpoint from Alchemy, Infura, or another node provider service.

PRIVATE_KEY: Find the private key for your testnet wallet. If you use MetaMask, follow the instructions to Export a Private Key. Note: Your private key is needed to sign any transactions you make such as making requests.

npx env-enc set

### Configure your onchain resources
After you configure your local environment, configure some onchain resources to process your requests, receive the responses, and pay for the work done by the DON.

#### Deploy a Functions consumer contract on Sepolia

1. Open the FunctionsConsumerExample.sol contract in Remix.

Open in Remix
What is Remix?
2. Compile the contract.
3. Open MetaMask and select the Sepolia network.
4. In Remix under the Deploy & Run Transactions tab, select Injected Provider - MetaMask in the Environment list. Remix will use the MetaMask wallet to communicate with Sepolia.
5. Under the Deploy section, fill in the router address for your specific blockchain. You can find both of these addresses on the Supported Networks page. For Sepolia, the router address is 0xb83E47C2bC239B3bf370bc41e1459A34b41238D0.
6. Click the Deploy button to deploy the contract. MetaMask prompts you to confirm the transaction. Check the transaction details to make sure you are deploying the contract to Sepolia.
7. After you confirm the transaction, the contract address appears in the Deployed Contracts list. Copy the contract address.

#### Create a subscription
Follow the Managing Functions Subscriptions guide to accept the Chainlink Functions Terms of Service (ToS), create a subscription, fund it, then add your consumer contract address to it.

You can find the Chainlink Functions Subscription Manager at functions.chain.link.

## Tutorial
This tutorial is configured to get the average (geometric mean) from a list of numbers 1,2,3,4,5,6,7,8,9,10. Read the Examine the code section for a detailed description of the code example.

You can locate the scripts used in this tutorial in the examples/1-simple-computation directory.

To run the example:

1. Open the file request.js, which is located in the 1-simple-computation folder.
2. Replace the consumer contract address and the subscription ID with your own values.
const consumerAddress = "0x8dFf78B7EE3128D00E90611FBeD20A71397064D9" // REPLACE this with your Functions consumer address
const subscriptionId = 3 // REPLACE this with your subscription ID
3. Make a request:
node examples/1-simple-computation/request.js

The script runs your function in a sandbox environment before making an onchain transaction:
$ node examples/1-simple-computation/request.js

secp256k1 unavailable, reverting to browser version
Start simulation...
Simulation result {
capturedTerminalOutput: 'calculate geometric mean of 1,2,3,4,5,6,7,8,9,10\ngeometric mean is: 4.53\n',
responseBytesHexstring: '0x00000000000000000000000000000000000000000000000000000000000001c5'
}
✅ Decoded response to uint256:  453n

Estimate request costs...
Fulfillment cost estimated to 1.004325887213695 LINK

Make request...

✅ Functions request sent! Transaction hash 0x7df8240d23ef5c951ea73634b2346a459c8cd5b9a0bf76dbe0bb4d912e099b22. Waiting for a response...
See your request in the explorer https://sepolia.etherscan.io/tx/0x7df8240d23ef5c951ea73634b2346a459c8cd5b9a0bf76dbe0bb4d912e099b22

✅ Request 0x91a72a36a94ddedfc9e7bcfe33aaa13dd5747c4e985d9baa8c0c34175ac6c715 successfully fulfilled. Cost is 0.240613623834519812 LINK.Complete response:  {
requestId: '0x91a72a36a94ddedfc9e7bcfe33aaa13dd5747c4e985d9baa8c0c34175ac6c715',
subscriptionId: 2303,
totalCostInJuels: 240613623834519812n,
responseBytesHexstring: '0x00000000000000000000000000000000000000000000000000000000000001c5',
errorString: '',
returnDataBytesHexstring: '0x',
fulfillmentCode: 0
}

✅ Decoded response to uint256:  453n

The output of the example gives you the following information:

Your request is first run on a sandbox environment to ensure it is correctly configured.

The fulfillment costs are estimated before making the request.

Your request was successfully sent to Chainlink Functions. The transaction in this example is 0x7df8240d23ef5c951ea73634b2346a459c8cd5b9a0bf76dbe0bb4d912e099b22 and the request ID is 0x91a72a36a94ddedfc9e7bcfe33aaa13dd5747c4e985d9baa8c0c34175ac6c715.

The DON successfully fulfilled your request. The total cost was: 0.240613623834519812 LINK.

The consumer contract received a response in bytes with a value of 0x00000000000000000000000000000000000000000000000000000000000001c5. Decoding it offchain to uint256 gives you a result: 453.

## Examine the code

### FunctionsConsumerExample.sol
[Image: copy to clipboard]
```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import {FunctionsClient} from "@chainlink/contracts/src/v0.8/functions/v1_0_0/FunctionsClient.sol";
import {ConfirmedOwner} from "@chainlink/contracts/src/v0.8/shared/access/ConfirmedOwner.sol";
import {FunctionsRequest} from "@chainlink/contracts/src/v0.8/functions/v1_0_0/libraries/FunctionsRequest.sol";

/**
 * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
 * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */
contract FunctionsConsumerExample is FunctionsClient, ConfirmedOwner {
    using FunctionsRequest for FunctionsRequest.Request;

    bytes32 public s_lastRequestId;
    bytes public s_lastResponse;
    bytes public s_lastError;

    error UnexpectedRequestID(bytes32 requestId);

    event Response(bytes32 indexed requestId, bytes response, bytes err);

    constructor(
        address router
    ) FunctionsClient(router) ConfirmedOwner(msg.sender) {}

    /**
     * @notice Send a simple request
     * @param source JavaScript source code
     * @param encryptedSecretsUrls Encrypted URLs where to fetch user secrets
     * @param donHostedSecretsSlotID Don hosted secrets slotId
     * @param donHostedSecretsVersion Don hosted secrets version
     * @param args List of arguments accessible from within the source code
     * @param bytesArgs Array of bytes arguments, represented as hex strings
     * @param subscriptionId Billing ID
     */
    function sendRequest(
        string memory source,
        bytes memory encryptedSecretsUrls,
        uint8 donHostedSecretsSlotID,
        uint64 donHostedSecretsVersion,
        string[] memory args,
        bytes[] memory bytesArgs,
        uint64 subscriptionId,
        uint32 gasLimit,
        bytes32 donID
    ) external onlyOwner returns (bytes32 requestId) {
        FunctionsRequest.Request memory req;
        req.initializeRequestForInlineJavaScript(source);
        if (encryptedSecretsUrls.length > 0)
            req.addSecretsReference(encryptedSecretsUrls);
        else if (donHostedSecretsVersion > 0) {
            req.addDONHostedSecrets(
                donHostedSecretsSlotID,
                donHostedSecretsVersion
            );
        }
        if (args.length > 0) req.setArgs(args);
        if (bytesArgs.length > 0) req.setBytesArgs(bytesArgs);
        s_lastRequestId = _sendRequest(
            req.encodeCBOR(),
            subscriptionId,
            gasLimit,
            donID
        );
        return s_lastRequestId;
    }

    /**
     * @notice Send a pre-encoded CBOR request
     * @param request CBOR-encoded request data
     * @param subscriptionId Billing ID
     * @param gasLimit The maximum amount of gas the request can consume
     * @param donID ID of the job to be invoked
     * @return requestId The ID of the sent request
     */
    function sendRequestCBOR(
        bytes memory request,
        uint64 subscriptionId,
        uint32 gasLimit,
        bytes32 donID
    ) external onlyOwner returns (bytes32 requestId) {
        s_lastRequestId = _sendRequest(
            request,
            subscriptionId,
            gasLimit,
            donID
        );
        return s_lastRequestId;
    }

    /**
     * @notice Store latest result/error
     * @param requestId The request ID, returned by sendRequest()
     * @param response Aggregated response from the user code
     * @param err Aggregated error from the user code or from the execution pipeline
     * Either response or error parameter will be set, but never both
     */
    function fulfillRequest(
        bytes32 requestId,
        bytes memory response,
        bytes memory err
    ) internal override {
        if (s_lastRequestId != requestId) {
            revert UnexpectedRequestID(requestId);
        }
        s_lastResponse = response;
        s_lastError = err;
        emit Response(requestId, s_lastResponse, s_lastError);
    }
}
```

[Open in Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/ChainlinkFunctions/FunctionsConsumerExample.sol&autoCompile=true)[What is Remix?](/getting-started/conceptual-overview#what-is-remix)
• To write a Chainlink Functions consumer contract, your contract must import FunctionsClient.sol and FunctionsRequest.sol. You can read the API references: FunctionsClient and FunctionsRequest.
These contracts are available in an NPM package, so you can import them from within your project.
import {FunctionsClient} from "@chainlink/contracts/src/v0.8/functions/v1_0_0/FunctionsClient.sol";
import {FunctionsRequest} from "@chainlink/contracts/src/v0.8/functions/v1_0_0/libraries/FunctionsRequest.sol";
• Use the FunctionsRequest.sol library to get all the functions needed for building a Chainlink Functions request.
using FunctionsRequest for FunctionsRequest.Request;
• The latest request id, latest received response, and latest received error (if any) are defined as state variables:
bytes32 public s_lastRequestId;
bytes public s_lastResponse;
bytes public s_lastError;
• We define the Response event that your smart contract will emit during the callback
event Response(bytes32 indexed requestId, bytes response, bytes err);
• Pass the router address for your network when you deploy the contract:
constructor(address router) FunctionsClient(router)
• The three remaining functions are:

sendRequest for sending a request. It receives the JavaScript source code, encrypted secretsUrls (in case the encrypted secrets are hosted by the user), DON hosted secrets slot id and version (in case the encrypted secrets are hosted by the DON), list of arguments to pass to the source code, subscription id, and callback gas limit as parameters. Then:

It uses the FunctionsRequestlibrary to initialize the request and add any passed encrypted secrets reference or arguments. You can read the API Reference for Initializing a request, adding user hosted secrets, adding DON hosted secrets, adding arguments, and adding bytes arguments.
FunctionsRequest.Request memory req;
req.initializeRequestForInlineJavaScript(source);
if (encryptedSecretsUrls.length > 0)
    req.addSecretsReference(encryptedSecretsUrls);
else if (donHostedSecretsVersion > 0) {
    req.addDONHostedSecrets(
        donHostedSecretsSlotID,
        donHostedSecretsVersion
    );
}
if (args.length > 0) req.setArgs(args);
if (bytesArgs.length > 0) req.setBytesArgs(bytesArgs);

It sends the request to the router by calling the FunctionsClient sendRequest function. You can read the API reference for sending a request. Finally, it stores the request id in s_lastRequestId then return it.
s_lastRequestId = _sendRequest(
    req.encodeCBOR(),
    subscriptionId,
    gasLimit,
    jobId
);
return s_lastRequestId;

Note: _sendRequest accepts requests encoded in bytes. Therefore, you must encode it using encodeCBOR.

sendRequestCBOR for sending a request already encoded in bytes. It receives the request object encoded in bytes, subscription id, and callback gas limit as parameters. Then, it sends the request to the router by calling the FunctionsClient sendRequest function. Note: This function is helpful if you want to encode a request offchain before sending it, saving gas when submitting the request.
• fulfillRequest to be invoked during the callback. This function is defined in FunctionsClient as virtual (read fulfillRequest API reference). So, your smart contract must override the function to implement the callback. The implementation of the callback is straightforward: the contract stores the latest response and error in s_lastResponse and s_lastError before emitting the Response event.
s_lastResponse = response;
s_lastError = err;
emit Response(requestId, s_lastResponse, s_lastError);

### JavaScript example

#### source.js
The Decentralized Oracle Network will run the JavaScript code. The code is self-explanatory and has comments to help you understand all the steps.

The main steps are:

• Read the numbers provided as arguments in the args setting. Because args is an array of string, call parseInt to convert from string to number. Note: args contains string values that are injected into the JavaScript source code when the Decentralized Oracle Network executes your function. You can access theses values from your JavaScript code using the name args.
• Calculate the average (geometric mean): First, compute the product of the numbers. Then, calculate the nth root of the product where n is the length of args.
• Return the result as a buffer using the Functions.encodeUint256 helper function. Because Solidity doesn't support decimals, multiply the result by 100 and round the result to the nearest integer. There are other helper functions that you could use depending on the response type:

Functions.encodeUint256: Takes a positive JavaScript integer number and returns a Buffer of 32 bytes representing a uint256 type in Solidity.
Functions.encodeInt256: Takes a JavaScript integer number and returns a Buffer of 32 bytes representing an int256 type in Solidity.
Functions.encodeString: Takes a JavaScript string and returns a Buffer representing a string type in Solidity.

Note: You are not required to use these encoding functions as long as the JavaScript code returns a Buffer representing the bytes array returned onchain. Read this article if you are new to Javascript Buffers and want to understand why they are important.

#### request.js
This explanation focuses on the request.js script and shows how to use the Chainlink Functions NPM package in your own JavaScript/TypeScript project to send requests to a DON. The code is self-explanatory and has comments to help you understand all the steps.

The script imports:

• path and fs : Used to read the source file.
• ethers: Ethers.js library, enables the script to interact with the blockchain.
• @chainlink/functions-toolkit: Chainlink Functions NPM package. All its utilities are documented in the NPM README.
• @chainlink/env-enc: A tool for loading and storing encrypted environment variables. Read the official documentation to learn more.
• ../abi/functionsClient.json: The abi of the contract your script will interact with. Note: The script was tested with this FunctionsConsumerExample contract.

The script has two hardcoded values that you have to change using your own Functions consumer contract and subscription ID:

[Image: copy to clipboard]
```javascript
const consumerAddress = "0x8dFf78B7EE3128D00E90611FBeD20A71397064D9" // REPLACE this with your Functions consumer address
const subscriptionId = 3 // REPLACE this with your subscription ID
```

The primary function that the script executes is makeRequestSepolia. This function consists of five main parts:

1. Definition of necessary identifiers:

routerAddress: Chainlink Functions router address on the Sepolia testnet.
donId: Identifier of the DON that will fulfill your requests on the Sepolia testnet.
explorerUrl: Block explorer URL of the Sepolia testnet.
source: The source code must be a string object. That's why we use fs.readFileSync to read source.js and then call toString() to get the content as a string object.
args: During the execution of your function, These arguments are passed to the source code.
gasLimit: Maximum gas that Chainlink Functions can use when transmitting the response to your contract.
Initialization of ethers signer and provider objects. The signer is used to make transactions on the blockchain, and the provider reads data from the blockchain.
2. Simulating your request in a local sandbox environment:

Use simulateScript from the Chainlink Functions NPM package.
Read the response of the simulation. If successful, use the Functions NPM package decodeResult function and ReturnType enum to decode the response to the expected returned type (ReturnType.uint256 in this example).
3. Estimating the costs:

Initialize a SubscriptionManager from the Functions NPM package, then call the estimateFunctionsRequestCost.
The response is returned in Juels (1 LINK = 10**18 Juels). Use the ethers.utils.formatEther utility function to convert the output to LINK.
4. Making a Chainlink Functions request:

Initialize your functions consumer contract using the contract address, abi, and ethers signer.
Call the sendRequest function of your consumer contract.
5. Waiting for the response:

Initialize a ResponseListener from the Functions NPM package and then call the listenForResponseFromTransaction function to wait for a response. By default, this function waits for five minutes.
Upon reception of the response, use the Functions NPM package decodeResult function and ReturnType enum to decode the response to the expected returned type (ReturnType.uint256 in this example).

================================================================================

# Chainlink VRF

Source: https://docs.chain.link/vrf
Extraction Method: playwright
Components: table(1)

# Chainlink VRF
[Image: tip]Security Considerations

Be sure to review your contracts with the security considerations in mind.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }Chainlink VRF (Verifiable Random Function) is a provably fair and verifiable random number generator (RNG) that enables smart contracts to access random values without compromising security or usability. For each request, Chainlink VRF generates one or more random values and cryptographic proof of how those values were determined. The proof is published and verified onchain before any consuming applications can use it. This process ensures that results cannot be tampered with or manipulated by any single entity including oracle operators, miners, users, or smart contract developers.

[Image: note]Migrate to V2.5

Follow the migration guide to learn how VRF has changed in V2.5 and to get example
code.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }Use Chainlink VRF to build reliable smart contracts for any applications that rely on unpredictable outcomes:

• Building blockchain games and NFTs.
• Random assignment of duties and resources. For example, randomly assigning judges to cases.
• Choosing a representative sample for consensus mechanisms.

VRF v2.5 includes all the original benefits of v2 and the following additional benefits:

• Easier upgrades to future versions.
• The option to pay for requests in either LINK or native tokens.

Learn how to migrate to VRF v2.5.

For help with your specific use case, contact us to connect with one of our Solutions Architects. You can also ask questions about Chainlink VRF on Stack Overflow.

## Two methods to request randomness
Similarly to VRF v2, VRF v2.5 will offer two methods for requesting randomness:

• Subscription: Create a subscription account and fund its balance with either native tokens or LINK. You can then connect multiple consuming contracts to the subscription account. When the consuming contracts request randomness, the transaction costs are calculated after the randomness requests are fulfilled and the subscription balance is deducted accordingly. This method allows you to fund requests for multiple consumer contracts from a single subscription.
• Direct funding: Consuming contracts directly pay with either native tokens or LINK when they request random values. You must directly fund your consumer contracts and ensure that there are enough funds to pay for randomness requests.

## Choosing the correct method
Depending on your use case, one method might be more suitable than another. Consider the following characteristics when you choose a method:

Subscription method | Direct funding method
--- | ---
Currently available on VRF v2.5 for all supported networks. | Currently available on VRF v2.5 for all supported networks.
Suitable for regular requests | Suitable for infrequent one-off requests
Supports multiple VRF consuming contracts connected to one subscription account | Each VRF consuming contract directly pays for its requests
VRF costs are calculated after requests are fulfilled and then deducted from the subscription balance. Learn how VRF costs are calculated for the subscription method. | VRF costs are estimated and charged at request time, which may make it easier to transfer the cost of VRF to the end user. Learn how VRF costs are calculated for the direct funding method.
Reduced gas overhead and more control over the maximum gas price for requests | Higher gas overhead than the subscription method
More random values returned per single request. See the maximum random values per request for the V2.5 subscription supported networks. | Fewer random values returned per single request than the subscription method, due to higher overhead. See the maximum random values per request and gas overhead for the V2 direct funding supported networks.
You don't have to estimate costs precisely for each request. Ensure that the subscription account has enough funds. | You must estimate transaction costs carefully for each request to ensure the consuming contract has enough funds to pay for the request.
Requires a subscription account | No subscription account required
VRF costs are billed to your subscription account | No refunds for overpayment after requests are completed

## Supported networks
The contract addresses and gas price limits are different depending on which method you use to get randomness. You can find the configuration, addresses, and limits for each method on the Supported networks page.

To learn when VRF v2.5 becomes available on more networks, follow us on Twitter or sign up for our mailing list.

================================================================================

# Getting Started with Chainlink VRF V2.5

Source: https://docs.chain.link/vrf/v2-5/getting-started
Extraction Method: playwright
Components: code_block(7)

# Getting Started with Chainlink VRF V2.5
[Image: note]Requirements

This guide assumes that you have basic knowledge about writing and deploying smart contracts. If you are new to smart
contract development, learn how to Deploy Your First Smart Contract before
you begin.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }In this guide, you will learn about generating randomness on blockchains. This includes learning how to implement a Request and Receive cycle with Chainlink oracles and how to consume random numbers with Chainlink VRF in smart contracts.

## How is randomness generated on blockchains? What is Chainlink VRF?
Randomness is very difficult to generate on blockchains. This is because every node on the blockchain must come to the same conclusion and form a consensus. Even though random numbers are versatile and useful in a variety of blockchain applications, they cannot be generated natively in smart contracts. The solution to this issue is Chainlink VRF, also known as Chainlink Verifiable Random Function.

## What is the Request and Receive cycle?
The Data Feeds Getting Started guide explains how to consume Chainlink Data Feeds, which consist of reference data posted onchain by oracles. This data is stored in a contract and can be referenced by consumers until the oracle updates the data again.

Randomness, on the other hand, cannot be reference data. If the result of randomness is stored onchain, any actor could retrieve the value and predict the outcome. Instead, randomness must be requested from an oracle, which generates a number and a cryptographic proof. Then, the oracle returns that result to the contract that requested it. This sequence is known as the Request and Receive cycle.

## What is the payment process for generating a random number?
VRF requests receive funding from subscription accounts. The Subscription Manager lets you create an account and pre-pay for VRF requests, so that funding of all your application requests are managed in a single location.
To learn more about VRF requests funding, see Subscription limits.

## How can I use Chainlink VRF?
In this section, you will create an application that uses Chainlink VRF to generate randomness. The contract used in this application has a Game of Thrones theme.

After the contract requests randomness from Chainlink VRF, the result of the randomness will transform into a number between 1 and 20, mimicking the rolling of a 20 sided die. Each number represents a Game of Thrones house. If the dice land on the value 1, the user is assigned house Targaryan, 2 for Lannister, and so on. A full list of houses can be found here.

When rolling the dice, it uses an address variable to track which address is assigned to each house.

The contract has the following functions:

• rollDice: This submits a randomness request to Chainlink VRF
• fulfillRandomWords: The function that the Oracle uses to send the result back
• house: To see the assigned house of an address

Note: to jump straight to the entire implementation, you can open the VRFD20.sol contract in Remix.

### Create and fund a subscription
Chainlink VRF requests receive funding from subscription accounts. The Subscription Manager lets you create an account and pre-pay your use of Chainlink VRF requests.
For this example, create a new subscription on the Sepolia testnet as explained here.

Your subscription has two balances - one for LINK and one for the native token you're using (in this case, Sepolia ETH). You can choose to pay for VRF requests using either balance.

### Importing contracts
Chainlink maintains a library of contracts that make consuming data from oracles easier. For Chainlink VRF, you will use:

• VRFConsumerBaseV2Plus that must be imported and extended from the contract that you create.
• VRFV2PlusClient to format your requests to VRF.

[Image: copy to clipboard]
```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import {VRFConsumerBaseV2Plus} from "@chainlink/contracts/src/v0.8/vrf/dev/VRFConsumerBaseV2Plus.sol";
import {VRFV2PlusClient} from "@chainlink/contracts/src/v0.8/vrf/dev/libraries/VRFV2PlusClient.sol";

contract VRFD20 is VRFConsumerBaseV2Plus {

}
```

### Contract variables
This example is adapted for Sepolia testnet but you can change the configuration and make it run for any supported network.

[Image: copy to clipboard]
```solidity
uint256 s_subscriptionId;
address vrfCoordinator = 0x9DdfaCa8183c41ad55329BdeeD9F6A8d53168B1B;
bytes32 s_keyHash = 0x787d74caea10b2b357790d5b5247c2f63d1d91572a9846f780606e4d953677ae;
uint32 callbackGasLimit = 40000;
uint16 requestConfirmations = 3;
uint32 numWords =  1;
```

• uint256 s_subscriptionId: The subscription ID that this contract uses for funding requests. Initialized in the constructor.
• address vrfCoordinator: The address of the Chainlink VRF Coordinator contract.
• bytes32 s_keyHash: The gas lane key hash value, which is the maximum gas price you are willing to pay for a request in wei. It functions as an ID of the offchain VRF job that runs in response to requests.
• uint32 callbackGasLimit: The limit for how much gas to use for the callback request to your contract's fulfillRandomWords function. It must be less than the maxGasLimit on the coordinator contract. Adjust this value for larger requests depending on how your fulfillRandomWords function processes and stores the received random values. If your callbackGasLimit is not sufficient, the callback will fail and your subscription is still charged for the work done to generate your requested random values.
• uint16 requestConfirmations: How many confirmations the Chainlink node should wait before responding. The longer the node waits, the more secure the random value is. It must be greater than the minimumRequestBlockConfirmations value on the coordinator contract. For Sepolia, the minimumRequestBlockConfirmations value is 3. You can check this and the other configuration values on the coordinator contract by querying the s_config value in the Sepolia Etherscan block explorer.
• uint32 numWords: How many random values to request. If you can use several random values in a single callback, you can reduce the amount of gas that you spend per random value. In this example, each transaction requests one random value.

To keep track of addresses that roll the dice, the contract uses mappings. Mappings are unique key-value pair data structures similar to hash tables in Java.

[Image: copy to clipboard]
```solidity
mapping(uint256 => address) private s_rollers;
mapping(address => uint256) private s_results;
```

• s_rollers stores a mapping between the requestID (returned when a request is made), and the address of the roller. This is so the contract can keep track of who to assign the result to when it comes back.
• s_results stores the roller and the result of the dice roll.

### Initializing the contract
The subscription ID must be initialized in the constructor of the contract. To use VRFConsumerBaseV2Plus properly, you must also pass the VRF coordinator address into its constructor.
The address that creates the smart contract is the owner of the contract.

[Image: copy to clipboard]
```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import {VRFConsumerBaseV2Plus} from "@chainlink/contracts/src/v0.8/vrf/dev/VRFConsumerBaseV2Plus.sol";
import {VRFV2PlusClient} from "@chainlink/contracts/src/v0.8/vrf/dev/libraries/VRFV2PlusClient.sol";

contract VRFD20 is VRFConsumerBaseV2Plus {
    // variables
    // ...

    // constructor
    constructor(uint256 subscriptionId) VRFConsumerBaseV2Plus(vrfCoordinator) {
        s_subscriptionId = subscriptionId;
    }
    ...
}
```

### rollDice function
The rollDice function will complete the following tasks:

1. Check if the roller has already rolled since each roller can only ever be assigned to a single house.
2. Request randomness by calling the VRF coordinator.
3. Store the requestId and roller address.
4. Emit an event to signal that the dice is rolling.

You must add a ROLL_IN_PROGRESS constant to signify that the dice has been rolled but the result is not yet returned. Also add a DiceRolled event to the contract.

Only the owner of the contract can execute the rollDice function.

This rollDice function is configured so that you pay for VRF requests using LINK by default. If you want to pay for your VRF request with Sepolia ETH instead, set nativePayment to true.

[Image: copy to clipboard]
```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import {VRFConsumerBaseV2Plus} from "@chainlink/contracts/src/v0.8/vrf/dev/VRFConsumerBaseV2Plus.sol";
import {VRFV2PlusClient} from "@chainlink/contracts/src/v0.8/vrf/dev/libraries/VRFV2PlusClient.sol";

contract VRFD20 is VRFConsumerBaseV2Plus {
    // variables
    uint256 private constant ROLL_IN_PROGRESS = 42;
    // ...

    // events
    event DiceRolled(uint256 indexed requestId, address indexed roller);
    // ...

    // ...
    // { constructor }
    // ...

    // rollDice function
    function rollDice(address roller) public onlyOwner returns (uint256 requestId) {
        require(s_results[roller] == 0, "Already rolled");
        // Will revert if subscription is not set and funded.

       requestId = s_vrfCoordinator.requestRandomWords(
            VRFV2PlusClient.RandomWordsRequest({
                keyHash: s_keyHash,
                subId: s_subscriptionId,
                requestConfirmations: requestConfirmations,
                callbackGasLimit: callbackGasLimit,
                numWords: numWords,
                // Set nativePayment to true to pay for VRF requests with Sepolia ETH instead of LINK
                extraArgs: VRFV2PlusClient._argsToBytes(VRFV2PlusClient.ExtraArgsV1({nativePayment: false}))
            })
        );

        s_rollers[requestId] = roller;
        s_results[roller] = ROLL_IN_PROGRESS;
        emit DiceRolled(requestId, roller);
    }
}
```

### fulfillRandomWords function
fulfillRandomWords is a special function defined within the VRFConsumerBaseV2Plus contract that our contract extends from. The coordinator sends the result of our generated randomWords back to fulfillRandomWords. You will implement some functionality here to deal with the result:

1. Change the result to a number between 1 and 20 inclusively. Note that randomWords is an array that could contain several random values. In this example, request 1 random value.
2. Assign the transformed value to the address in the s_results mapping variable.
3. Emit a DiceLanded event.

[Image: copy to clipboard]
```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import {VRFConsumerBaseV2Plus} from "@chainlink/contracts/src/v0.8/vrf/dev/VRFConsumerBaseV2Plus.sol";
import {VRFV2PlusClient} from "@chainlink/contracts/src/v0.8/vrf/dev/libraries/VRFV2PlusClient.sol";

contract VRFD20 is VRFConsumerBaseV2Plus {
    // ...
    // { variables }
    // ...

    // events
    // ...
    event DiceLanded(uint256 indexed requestId, uint256 indexed result);

    // ...
    // { constructor }
    // ...

    // ...
    // { rollDice function }
    // ...

    // fulfillRandomWords function
    function fulfillRandomWords(uint256 requestId, uint256[] calldata randomWords) internal override {

        // transform the result to a number between 1 and 20 inclusively
        uint256 d20Value = (randomWords[0] % 20) + 1;

        // assign the transformed value to the address in the s_results mapping variable
        s_results[s_rollers[requestId]] = d20Value;

        // emitting event to signal that dice landed
        emit DiceLanded(requestId, d20Value);
    }
}
```

### house function
Finally, the house function returns the house of an address.

To have a list of the house's names, create the getHouseName function that is called in the house function.

[Image: copy to clipboard]
```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import {VRFConsumerBaseV2Plus} from "@chainlink/contracts/src/v0.8/vrf/dev/VRFConsumerBaseV2Plus.sol";
import {VRFV2PlusClient} from "@chainlink/contracts/src/v0.8/vrf/dev/libraries/VRFV2PlusClient.sol";

contract VRFD20 is VRFConsumerBaseV2Plus {
    // ...
    // { variables }
    // ...

    // ...
    // { events }
    // ...

    // ...
    // { constructor }
    // ...

    // ...
    // { rollDice function }
    // ...

    // ...
    // { fulfillRandomWords function }
    // ...

    // house function
    function house(address player) public view returns (string memory) {
        // dice has not yet been rolled to this address
        require(s_results[player] != 0, "Dice not rolled");

        // not waiting for the result of a thrown dice
        require(s_results[player] != ROLL_IN_PROGRESS, "Roll in progress");

        // returns the house name from the name list function
        return getHouseName(s_results[player]);
    }

    // getHouseName function
    function getHouseName(uint256 id) private pure returns (string memory) {
        // array storing the list of house's names
        string[20] memory houseNames = [
            "Targaryen",
            "Lannister",
            "Stark",
            "Tyrell",
            "Baratheon",
            "Martell",
            "Tully",
            "Bolton",
            "Greyjoy",
            "Arryn",
            "Frey",
            "Mormont",
            "Tarley",
            "Dayne",
            "Umber",
            "Valeryon",
            "Manderly",
            "Clegane",
            "Glover",
            "Karstark"
        ];

        // returns the house name given an index
        return houseNames[id - 1];
    }
}
```

[Open in Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/VRF/v2-5/VRFD20.sol&autoCompile=true)[What is Remix?](/getting-started/conceptual-overview#what-is-remix)You have now completed all necessary functions to generate randomness and assign the user a Game of Thrones house. We've added a few helper functions in there to make using the contract easier and more flexible. You can deploy and interact with the complete contract in Remix.

## How do I deploy to testnet?
You will deploy this contract on the Sepolia test network. You must have some Sepolia testnet ETH in your MetaMask account to pay for the gas for each contract interaction with the Sepolia network.

You can choose to pay for your VRF requests in either Sepolia ETH or testnet LINK. The rollDice function is written to use LINK by default. If you want to change to using Sepolia, set nativePayment to true before deploying your contract.

You can request both testnet LINK and testnet ETH from faucets.chain.link/sepolia. Testnet ETH is also available from several public faucets.

This deployment is slightly different than the example in the Deploy Your First Contract guide. In this case, you pass in parameters to the constructor upon deployment.

Once compiled, you'll see a dropdown menu that looks like this in the deploy pane:

astro-island,astro-slot,astro-static-slot{display:contents}(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).only=e;window.dispatchEvent(new Event("astro:only"));})();(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();[Image: Remix contract selected]Select the VRFD20 contract or the name that you gave to your contract.

Click the caret arrow on the right hand side of Deploy to expand the parameter fields, and paste your subscription ID.

[Image: Remix contract parameters to deploy]Then click the Deploy button and use your MetaMask account to confirm the transaction.

[Image: note]Address, Key Hashes and more

For a full reference of the addresses, key hashes and fees for each network, see VRF Supported
Networks.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }At this point, your contract should be successfully deployed. However, it can't request anything because it is not yet approved to use the LINK or Sepolia ETH balance in your subscription. If you click rollDice, the transaction will revert.

## How do I add my contract to my subscription account?
After you deploy your contract, you must add it as an approved consumer contract so it can use the subscription balance when requesting for randomness.

1. Find your contract address in Remix under Deployed Contracts on the bottom left, and copy the contract address:
2. Go to the Subscription Manager, open the details page for your subscription, and add your deployed contract address to the list of consumers:

## How do I test rollDice?
After you open the deployed contract tab in the bottom left, the function buttons are available. Find rollDice and click the caret to expand the parameter fields. Enter an Ethereum address to specify a "dice roller", and click rollDice.

It takes a few minutes for the transaction to confirm and the response to be sent back. You can get your house by clicking the house function button with the address passed in rollDice. After the response is sent back, you'll be assigned a Game of Thrones house!

## Further reading
To read more about generating random numbers in Solidity, read our blog posts:

• 35+ Blockchain RNG Use Cases Enabled by Chainlink VRF
• How to Build Dynamic NFTs on Polygon
• Scaling Onchain Verifiable Randomness With Chainlink VRF v2.5

================================================================================

# VRF Billing

Source: https://docs.chain.link/vrf/v2-5/billing
Extraction Method: playwright
Components: code_block(4), table(21)

# VRF Billing
This guide explains how to estimate VRF 2.5 costs for both the subscription and direct funding methods.

## Understanding transaction costs
SubscriptionDirect fundingFor Chainlink VRF v2.5 to fulfill your requests, you must maintain enough funds in your subscription balance. Gas cost calculation includes the following variables:

• Gas price: The current gas price, which fluctuates depending on network conditions.
• Callback gas: The amount of gas used for the callback request that returns your requested random values.
• Verification gas: The amount of gas used to verify randomness onchain.

The gas price depends on current network conditions. The callback gas depends on your callback function, and the number of random values in your request. The cost of each request is final only after the transaction is complete, but you define the limits you are willing to spend for the request with the following variables:

• Gas lane: The maximum gas price you are willing to pay for a request in wei. Define this limit by specifying the appropriate keyHash in your request. The limits of each gas lane are important for handling gas price spikes when Chainlink VRF bumps the gas price to fulfill your request quickly.
• Callback gas limit: Specifies the maximum amount of gas you are willing to spend on the callback request. Define this limit by specifying the callbackGasLimit value in your request.

For Chainlink VRF v2.5 to fulfill your requests, you must maintain enough funds in your consuming contract.

Gas cost calculation includes the following variables:

• Callback gas: The amount of gas used for the callback request that returns your requested random values. The callback gas depends on your callback function and the number of random values in your request. Set the callback gas limit to specify the maximum amount of gas you are willing to spend on the callback request.
• Number of random values requested: The number of random values (numWords) per request to VRF.
• Gas price: The current gas price, which fluctuates depending on network conditions.
• Coordinator overhead gas: The amount of gas used to verify randomness onchain. This consists of two components:

Coordinator overhead gas (Native or LINK): The coordinator overhead gas has different values depending on whether you're using LINK or native tokens.
Coordinator overhead gas per word: The amount of additional gas the coordinator uses per random value ("word") that you request.
• Wrapper overhead gas: The amount of gas used by the VRF Wrapper contract.

Because the consuming contract directly pays for the request, the cost is calculated during the request and not during the callback when the randomness is fulfilled. Test your callback function to learn how to correctly estimate the callback gas limit.

• If the gas limit is underestimated, the callback fails and the consuming contract is still charged for the work done to generate the requested random values.
• If the gas limit is overestimated, the callback function will be executed but your contract is not refunded for the excess gas amount that you paid.

Make sure that your consuming contracts have enough funds in either LINK or native tokens to cover the transaction costs. If the consuming contract doesn't have enough funds, your request will revert.

astro:end
### Estimate gas costs
astro-island,astro-slot,astro-static-slot{display:contents}(()=>{var a=(s,i,o)=>{let r=async()=>{await(await s())()},t=typeof i.value=="object"?i.value:void 0,c={rootMargin:t==null?void 0:t.rootMargin},n=new IntersectionObserver(e=>{for(let l of e)if(l.isIntersecting){n.disconnect(),r();break}},c);for(let e of o.children)n.observe(e)};(self.Astro||(self.Astro={})).visible=a;window.dispatchEvent(new Event("astro:visible"));})();(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();SubscriptionDirect fundingYou need to pre-fund your subscription enough to meet the minimum subscription balance
in order to have a buffer against gas volatility.

After the request is complete, the final gas cost is recorded based on how much gas is used for the verification and callback.
The actual cost of the request is deducted from your subscription balance.

The total gas cost in wei for your request uses the following formula:

[Image: copy to clipboard]
```plaintext
(Gas price * (Verification gas + Callback gas)) = total gas cost
```

If you're paying for VRF in LINK, the total gas cost is converted to LINK using the ETH/LINK data feed. In the unlikely event that the data feed is
unavailable, the VRF coordinator uses the fallbackWeiPerUnitLink value for the conversion instead. The
fallbackWeiPerUnitLink value is defined in the
coordinator contract for your selected network.

The final gas cost to fulfill randomness is estimated based on how much gas is expected for the verification and callback. The total gas cost in wei uses the following formula:

[Image: copy to clipboard]
```plaintext
(Gas price * (Coordinator gas overhead
              + Callback gas limit
              + Wrapper gas overhead)) = total gas cost
```

The total gas cost is converted to LINK using the ETH/LINK data feed. In the unlikely event that the data feed is unavailable, the VRF Wrapper uses the fallbackWeiPerUnitLink value for the conversion instead. The fallbackWeiPerUnitLink value is defined in the VRF v2.5 Wrapper contract for your selected network.

The maximum allowed callbackGasLimit value for your requests is defined in the Coordinator contract supported networks page. Because the VRF v2.5 Wrapper adds gas overheads, your callbackGasLimit must not exceed maxGasLimit - wrapperGasOverhead.

### Apply premium
SubscriptionDirect fundingThe premium is charged as a percentage of the overall gas cost. The premium is defined in the coordinator contract. Premium percentages are listed there as whole integers. For example, a 20% premium is listed as 20.

[Image: copy to clipboard]
```plaintext
(total gas cost) * ((100 + Premium percentage) / 100) = total request cost
```

The total request cost is charged to your subscription balance. Since you have the option to pay for VRF requests either in LINK or the native token for the network you're using, your subscription can have both a LINK balance and a native token balance. The premium is higher when you pay with native tokens than when you pay with LINK. For example, the premium percentage for using Ethereum is 24 if you pay with Ethereum, and 20 if you pay with LINK.

The premium is divided in two parts:

• Wrapper premium: This premium is charged as a percentage of the overall gas cost. Premium percentages are listed there as whole integers. For example, a 20% premium is listed as 20. You can find the percentage for your network in the Supported networks page.
• Coordinator premium: A flat fee. This premium is defined in the fulfillmentFlatFeeLinkPPMTier1 parameter in millionths of LINK. You can find the flat fee of the coordinator for your network in the Supported networks page.

[Image: copy to clipboard]
```plaintext
(Coordinator premium
  + (total gas cost) * ((100 + Premium percentage) / 100)) = total request cost
```

The total request cost is charged to your consuming contract. The premium is higher when you pay with native tokens than when you pay with LINK. For example, the premium percentage for using Ethereum is 24 if you pay with Ethereum, and 20 if you pay with LINK.

### Subscription cost examples
These are example calculations of a VRF subscription request on Ethereum, shown in both ETH and LINK. The values for other supported networks
are available on the Supported Networks page.
The examples show how to estimate the following:

• The minimum subscription balance, which is a higher amount you need to reserve before your request is processed. This provides a buffer in case gas prices go higher when processing the request. The VRF Subscription Manager displays your minimum subscription balance as Max Cost.
• The actual cost of the request after it is processed, which is lower than the minimum subscription balance.

#### Estimate minimum subscription balance
These example calculations show an estimated minimum subscription balance for using VRF on Ethereum, shown in both ETH and LINK. The premium is higher when you pay with native tokens than when you pay with LINK.

Paying in LINKPaying in ETH
Parameter | Value
--- | ---
Gas lane | 500 gwei
Callback gas limit | 100000
Max verification gas | 200000
Premium percentage | 20

1. Calculate the total gas cost, using the maximum possible gas price for the selected gas lane, the estimated maximum verification gas, and the full callback gas limit:
Gas cost calculationTotal gas costGas price x (Verification gas + Callback gas)500 gwei x (200000 + 100000)150000000 gwei (0.15 ETH)
2. Apply the premium percentage to get the total maximum cost of a request:
Applying premium percentageMaximum request cost (ETH)Total gas cost (ETH) * ((100 + premium percentage)/100)0.15 ETH * ((100 + 20)/100)0.18 ETH
3. Convert the total cost to LINK using the LINK/ETH feed.
For this example, assume the feed returns a conversion value of Ξ0.005 ETH per 1 LINK.
ETH to LINK cost conversionMaximum request cost (LINK)0.18 ETH / 0.005 ETH/LINK36 LINK

For this example request to go through, you need to reserve a minimum subscription balance of 36 LINK, but that does not mean the actual request will cost 36 LINK. Check the Max Cost in the
Subscription Manager to view the minimum subscription balance for all your contracts. When your request is processed, the actual cost of the request is calculated and deducted from your subscription balance. See the next section for an example of how to calculate the actual request cost.

Parameter | Value
--- | ---
Gas lane | 500 gwei
Callback gas limit | 100000
Max verification gas | 200000
Premium percentage | 24

1. Calculate the total gas cost, using the maximum possible gas price for the selected gas lane, the estimated maximum verification gas, and the full callback gas limit:
Gas cost calculationTotal gas costGas price x (Verification gas + Callback gas)500 gwei x (200000 + 100000)150000000 gwei (0.15 ETH)
2. Apply the premium percentage to get the total maximum cost of a request:
Applying premium percentageMaximum request cost (ETH)Total gas cost (ETH) * ((100 + premium percentage)/100)0.15 ETH * ((100 + 24)/100)0.186 ETH

For this example request to go through, you need to reserve a minimum subscription balance of 0.186 ETH, but that does not mean the actual request will cost 0.186 ETH. Check the Max Cost in the Subscription Manager to view the minimum subscription balance for all your contracts. When your request is processed, the actual cost of the request is deducted from your subscription balance. See the next section for an example of how to calculate the actual request cost.

#### Estimate VRF request cost
These example calculations show a cost breakdown of a VRF subscription request on the Ethereum network. Check Etherscan
for current gas prices.

Paying in LINKPaying in ETH
Parameter | Value
--- | ---
Actual gas price | 50 gwei
Callback gas used | 95000
Verification gas used | 115000
Premium percentage | 20

1. Calculate the total gas cost:
Gas cost calculationTotal gas costGas price x (Verification gas + Callback gas)50 gwei x (115000 + 95000)10500000 gwei (0.0105 ETH)
2. Apply the premium percentage to get the total cost of a request:
Applying premium percentageTotal request cost (ETH)Total gas cost (ETH) * ((100 + premium percentage)/100)0.0105 ETH * ((100 + 20)/100)0.0126 ETH
3. Convert the total cost to LINK using the LINK/ETH feed.
For this example, assume the feed returns a conversion value of Ξ0.005 ETH per 1 LINK.
ETH to LINK cost conversionTotal gas cost (LINK)0.0126 ETH / 0.005 ETH/LINK2.52 LINK

This example request would cost 2.52 LINK, which is deducted from your subscription balance.

Parameter | Value
--- | ---
Actual gas price | 50 gwei
Callback gas used | 95000
Verification gas used | 115000
Premium percentage | 24

1. Calculate the total gas cost:
Gas cost calculationTotal gas costGas price x (Verification gas + Callback gas)50 gwei x (115000 + 95000)10500000 gwei (0.0105 ETH)
2. Apply the premium percentage to get the total maximum cost of a request:
Applying premium percentageMaximum request cost (ETH)Total gas cost (ETH) * ((100 + premium percentage)/100)0.0105 ETH * ((100 + 24)/100)0.01302 ETH

This example request would cost 0.01302 ETH, which is deducted from your subscription balance.

### Direct funding cost examples
These are example calculations of a VRF direct funding request on Ethereum, shown in both ETH and LINK. The values for other supported networks
are available on the Supported Networks page.

Paying in LINKPaying in ETH
Parameter | Value
--- | ---
Gas price | 50 gwei
Callback gas limit | 100000
Coordinator gas overhead (LINK) | 112000
Wrapper gas overhead | 13400
Coordinator gas overhead per word | 435
Number of random values (words) | 2
Wrapper premium percentage | 20

1. Calculate the total gas cost:
Gas cost calculationTotal gas costGas price _ (Coordinator overhead gas + Callback gas limit + Wrapper gas overhead + (Coordinator overhead gas per word _ Number of words))50 gwei x (112000 + 100000 + 13400 + (435 * 2))11313500 gwei (0.0113135 ETH)
2. Convert the gas cost to LINK using the LINK/ETH feed.
For this example, assume the feed returns a conversion value of Ξ0.004 ETH per 1 LINK.
ETH to LINK cost conversionTotal gas cost (LINK)0.0113135 ETH / 0.004 ETH/LINK2.828375 LINK
3. Apply the premium percentage to get the total cost of a request:
Applying premium percentageRequest cost (LINK)Total gas cost (LINK) * ((100 + premium percentage)/100)(2.828375 LINK * (100 + 20))/100)3.39405 LINK

This example request would cost 3.39405 LINK.

Parameter | Value
--- | ---
Gas price | 50 gwei
Callback gas limit | 100000
Coordinator gas overhead (Native) | 90000
Wrapper gas overhead | 13400
Coordinator gas overhead per word | 435
Number of random values (words) | 2
Wrapper premium percentage | 24

1. Calculate the total gas cost:
Gas cost calculationTotal gas costGas price _ (Coordinator overhead gas + Callback gas limit + Wrapper gas overhead + (Coordinator overhead gas per word _ Number of words))50 gwei x (90000 + 100000 + 13400 + (435 * 2))10213500 gwei (0.0102135 ETH)
2. Apply the premium percentage to get the total cost of a request:
Applying premium percentageRequest cost (ETH)Total gas cost (ETH) * ((100 + premium percentage)/100)(0.0102135 ETH * (100 + 24))/100)0.01266474 ETH

This example request would cost 0.01266474 ETH.

================================================================================

# Migrating from VRF v2

Source: https://docs.chain.link/vrf/v2-5/migration-from-v2
Extraction Method: playwright
Components: code_block(11)

# Migrating from VRF v2
[Image: tip]Security Considerations

Be sure to review your contracts with the security considerations in mind.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }VRF V2.5 replaces both VRF V1 and VRF V2 on November 29, 2024. Learn more about VRF V2.5.

## Benefits of VRF v2.5
Chainlink VRF v2.5 includes all the same key benefits as VRF v2, along with the following additional benefits and changes:

• Easier upgrades to future versions by using the new setCoordinator function
• The option to pay for requests in either LINK or native tokens
• New, flexible request format in requestRandomWords to make any future upgrades easier

## Code changes
VRF v2.5 introduces a new request format and the setCoordinator function. See the full migration walkthrough or the code example for more details.

### New request format
The request format for VRF v2.5 has changed:

SubscriptionDirect fundingThe requestRandomWords function now uses VRFV2PlusClient.RandomWordsRequest with an object labeling each part of the request:

[Image: copy to clipboard]
```solidity
uint256 requestId = s_vrfCoordinator.requestRandomWords(
    VRFV2PlusClient.RandomWordsRequest({
        keyHash: keyHash,
        subId: s_vrfSubscriptionId,
        requestConfirmations: requestConfirmations,
        callbackGasLimit: callbackGasLimit,
        numWords: numWords,
        extraArgs: VRFV2PlusClient._argsToBytes(VRFV2PlusClient.ExtraArgsV1({nativePayment: true}))
    })
);
```

You must include a value for the new extraArgs key, which allows you to add extra arguments related to new VRF features. Use the nativePayment argument to enable or disable payment in native tokens.

The requestRandomness function in the wrapper contract requires a new extraArgs argument that allows you to add extra arguments related to new VRF features. Use the nativePayment argument to enable or disable payment in native tokens.

Additionally, the requestRandomness function now returns two arguments instead of one: the request ID and the request price.

[Image: copy to clipboard]
```solidity
bytes memory extraArgs = VRFV2PlusClient._argsToBytes(
    VRFV2PlusClient.ExtraArgsV1({nativePayment: false})
);
(uint256 reqId, uint256 reqPrice) = requestRandomness(
    callbackGasLimit,
    requestConfirmations,
    numWords,
    extraArgs
);
```

astro:end
### setCoordinator function
Add the setCoordinator function to your contract so that you can easily update the VRF coordinator for future VRF releases.

### Subscription ID type change
Note that the subscription ID has changed types from uint64 in VRF V2 to uint256 in VRF V2.5.

## Billing changes
You have the option to use either native tokens or LINK to pay for VRF requests. To accommodate this, the premium fee has changed from a flat LINK premium amount per request, to a percentage-based premium per request. Refer to the Billing page for more details. To find out the new premium percentages for the networks you use, see the Supported Networks page.

For direct funding, the configurations for overhead gas have changed:

• The amount of wrapper overhead gas is reduced compared to V2.
• The amount of coordinator overhead gas used varies depending on the network used for your request, whether you're paying in LINK or native tokens, and how many random values you want in each VRF request. Refer to the Billing page for more details and examples, and see the new configurations on the Supported Networks page.

## Migration walkthrough
VRF v2.5 currently supports subscriptions and direct funding on all supported networks. To migrate, you need to update your existing smart contract code and redeploy your contracts.

If using subscriptions, create and fund a new VRF v2.5 subscription.

For direct funding, deploy the DirectFundingConsumer example:

[Open in Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/VRF/v2-5/DirectFundingConsumer.sol&autoCompile=true)[What is Remix?](/getting-started/conceptual-overview#what-is-remix)
### Update your code
To modify your existing smart contract code to work with VRF v2.5, complete the following changes:

SubscriptionDirect funding
1. Import the VRFConsumerBaseV2Plus contract and remove the v2 VRFConsumerBaseV2 import.
2. Import the VRF v2.5 coordinator, VRFCoordinatorV2_5, and update any old references to the VRF V2 coordinator in your contract.
3. Add a VRFConsumerBaseV2Plus constructor, passing in the VRF coordinator address for the network you're using.
4. Update your requestRandomWords function calls to reflect the new request structure for VRF v2.5. Make sure to include the new extraArgs part of the VRFV2PlusClient.RandomWordsRequest object, and specify whether or not you want to pay for VRF requests using native tokens:
LINKNative tokensuint256 requestId = s_vrfCoordinator.requestRandomWords(
    VRFV2PlusClient.RandomWordsRequest({
        keyHash: keyHash,
        subId: s_vrfSubscriptionId,
        requestConfirmations: requestConfirmations,
        callbackGasLimit: callbackGasLimit,
        numWords: numWords,
        extraArgs: VRFV2PlusClient._argsToBytes(VRFV2PlusClient.ExtraArgsV1({nativePayment: false}))
    })
);
uint256 requestId = s_vrfCoordinator.requestRandomWords(
    VRFV2PlusClient.RandomWordsRequest({
        keyHash: keyHash,
        subId: s_vrfSubscriptionId,
        requestConfirmations: requestConfirmations,
        callbackGasLimit: callbackGasLimit,
        numWords: numWords,
        extraArgs: VRFV2PlusClient._argsToBytes(VRFV2PlusClient.ExtraArgsV1({nativePayment: true}))
    })
);
5. When using the @chainlink/contracts package version 1.1.1 and later, update your fulfillRandomWords function signature to match the VRFConsumerBaseV2Plus contract, which has changed to:
function fulfillRandomWords(uint256 requestId, uint256[] calldata randomWords)

In the @chainlink/contracts package version 1.1.0 and earlier, the randomWords parameter has a memory storage location.

1. Import the VRFV2PlusWrapperConsumerBase contract and remove the v2 VRFV2WrapperConsumerBase import.
2. Add a VRFV2PlusWrapperConsumerBase constructor, passing in the VRF wrapper address for the network you're using. Unlike in V2, you don't have to pass the LINK token address to the constructor.
3. If you're paying for requests with LINK, you can still call the requestRandomness function. However, if you're paying with native tokens, call the requestRandomnessPayInNative function instead.
Both functions require one additional parameter, extraArgs. Use nativePayment to specify whether or not you want to pay for VRF requests using native tokens:
LINKNative tokensbytes memory extraArgs = VRFV2PlusClient._argsToBytes(
    VRFV2PlusClient.ExtraArgsV1({nativePayment: false})
);
(uint256 reqId, uint256 reqPrice) = requestRandomness(
    callbackGasLimit,
    requestConfirmations,
    numWords,
    extraArgs
);
bytes memory extraArgs = VRFV2PlusClient._argsToBytes(
    VRFV2PlusClient.ExtraArgsV1({nativePayment: true})
);
(uint256 reqId, uint256 reqPrice) = requestRandomnessPayInNative(
    callbackGasLimit,
    requestConfirmations,
    numWords,
    extraArgs
);
4. The V2.5 requestRandomness and requestRandomnessPayInNative functions both return a tuple: (uint256 requestId, uint256 requestPrice). Adjust your requestRandomWords function or any other functions in your code where you call the V2.5 wrapper's requestRandomness or requestRandomnessPayInNative functions.
5. Make sure your contract has a withdraw function for both native tokens and LINK. Both are included in the direct funding example code and the VRFV2PlusWrapperConsumerExample contract.

### Compare example code

#### Subscription example code
The example SubscriptionConsumer contract shows the migration steps above, applied to the example code from this VRF V2 tutorial. Both of these examples use the subscription method.

Open the full example SubscriptionConsumer contract:

[Open in Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/VRF/v2-5/SubscriptionConsumer.sol&autoCompile=true)[What is Remix?](/getting-started/conceptual-overview#what-is-remix)Compare the major changes between V2.5 and V2:

VRF V2.5 example codeVRF V2 example code[Image: copy to clipboard]
```solidity
// SPDX-License-Identifier: MIT
// An example of a consumer contract that relies on a subscription for funding.
pragma solidity 0.8.19;

///// UPDATE IMPORTS TO V2.5 /////
import {VRFConsumerBaseV2Plus} from "@chainlink/contracts/src/v0.8/vrf/dev/VRFConsumerBaseV2Plus.sol";
import {VRFV2PlusClient} from "@chainlink/contracts/src/v0.8/vrf/dev/libraries/VRFV2PlusClient.sol";

...

/\*\*

- THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
- THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
- DO NOT USE THIS CODE IN PRODUCTION.
  \*/

///// INHERIT NEW CONSUMER BASE CONTRACT /////
contract SubscriptionConsumer is VRFConsumerBaseV2Plus {
...
    ///// No need to declare a coordinator variable /////
    ///// Use the `s_vrfCoordinator` from VRFConsumerBaseV2Plus.sol /////

    ///// SUBSCRIPTION ID IS NOW UINT256 /////
    uint256 s_subscriptionId;

    ...

    ///// USE NEW KEYHASH FOR VRF 2.5 GAS LANE /////
    // For a list of available gas lanes on each network,
    // see https://docs.chain.link/docs/vrf/v2-5/supported-networks
    bytes32 keyHash =
        0x787d74caea10b2b357790d5b5247c2f63d1d91572a9846f780606e4d953677ae;

    ...

    ///// USE NEW CONSUMER BASE CONSTRUCTOR /////
    constructor(
        ///// UPDATE TO UINT256 /////
        uint256 subscriptionId
    )
        VRFConsumerBaseV2Plus(0x9DdfaCa8183c41ad55329BdeeD9F6A8d53168B1B)
    {
        s_subscriptionId = subscriptionId;
    }

    function requestRandomWords()
        external
        onlyOwner
        returns (uint256 requestId)
    {
        ///// UPDATE TO NEW V2.5 REQUEST FORMAT /////
        // To enable payment in native tokens, set nativePayment to true.
        // Use the `s_vrfCoordinator` from VRFConsumerBaseV2Plus.sol
        requestId = s_vrfCoordinator.requestRandomWords(
            VRFV2PlusClient.RandomWordsRequest({
                keyHash: keyHash,
                subId: s_subscriptionId,
                requestConfirmations: requestConfirmations,
                callbackGasLimit: callbackGasLimit,
                numWords: numWords,
                extraArgs: VRFV2PlusClient._argsToBytes(
                    VRFV2PlusClient.ExtraArgsV1({nativePayment: false})
                )
            })
        );
        ...
    }
    ...

}
```

[Image: copy to clipboard]
```solidity
// SPDX-License-Identifier: MIT
// An example of a consumer contract that relies on a subscription for funding.
pragma solidity ^0.8.7;

///// USES V2 IMPORTS /////
import {VRFCoordinatorV2Interface} from "@chainlink/contracts/src/v0.8/vrf/interfaces/VRFCoordinatorV2Interface.sol";
import {VRFConsumerBaseV2} from "@chainlink/contracts/src/v0.8/vrf/VRFConsumerBaseV2.sol";
import {ConfirmedOwner} from "@chainlink/contracts/src/v0.8/shared/access/ConfirmedOwner.sol";

/\*\*

- THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
- THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
- DO NOT USE THIS CODE IN PRODUCTION.
  \*/

///// USES V2 CONSUMER BASE CONTRACT /////
contract VRFv2Consumer is VRFConsumerBaseV2, ConfirmedOwner {
...

    ///// OLD TYPE FOR SUBSCRIPTION ID /////
    uint64 s_subscriptionId;

    ...

    ///// KEYHASH FOR VRF V2 GAS LANE /////
    // The gas lane to use, which specifies the maximum gas price to bump to.
    // For a list of available gas lanes on each network,
    // see https://docs.chain.link/docs/vrf/v2/subscription/supported-networks/#configurations
    bytes32 keyHash =
        0x474e34a077df58807dbe9c96d3c009b23b3c6d0cce433e59bbf5b34f823bc56c;

    ...

     ///// USES V2 CONSUMER BASE AND COORDINATOR CONSTRUCTORS /////
    constructor(
        uint64 subscriptionId
    )
        VRFConsumerBaseV2(0x8103B0A8A00be2DDC778e6e7eaa21791Cd364625)
        ConfirmedOwner(msg.sender)
    {
        COORDINATOR = VRFCoordinatorV2Interface(
            0x8103B0A8A00be2DDC778e6e7eaa21791Cd364625
        );
        s_subscriptionId = subscriptionId;
    }

    ...

    function requestRandomWords()
        external
        onlyOwner
        returns (uint256 requestId)
    {   ///// USES V2 REQUEST FORMAT /////
        requestId = COORDINATOR.requestRandomWords(
            keyHash,
            s_subscriptionId,
            requestConfirmations,
            callbackGasLimit,
            numWords
        );
        ...
    }

...
}
```

#### Direct funding example code
The example DirectFundingConsumer contract shows the migration steps above, applied to the example code from this VRF V2 tutorial. Both of these examples use the direct funding method.

Open the full example DirectFundingConsumer contract:

[Open in Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/VRF/v2-5/DirectFundingConsumer.sol&autoCompile=true)[What is Remix?](/getting-started/conceptual-overview#what-is-remix)Compare the major changes between V2.5 and V2:

VRF V2.5 example codeVRF V2 example code[Image: copy to clipboard]
```solidity
// SPDX-License-Identifier: MIT
// An example of a consumer contract that directly pays for each request.
pragma solidity 0.8.20;

///// UPDATE IMPORTS TO V2.5 /////
import {ConfirmedOwner} from "@chainlink/contracts/src/v0.8/shared/access/ConfirmedOwner.sol";
import {VRFV2PlusWrapperConsumerBase} from "@chainlink/contracts/src/v0.8/vrf/dev/VRFV2PlusWrapperConsumerBase.sol";
import {LinkTokenInterface} from "@chainlink/contracts/src/v0.8/shared/interfaces/LinkTokenInterface.sol";
import {VRFV2PlusClient} from "@chainlink/contracts/src/v0.8/vrf/dev/libraries/VRFV2PlusClient.sol";

/**
 * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
 * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

 ///// INHERIT NEW WRAPPER CONSUMER BASE CONTRACT /////
contract DirectFundingConsumer is VRFV2PlusWrapperConsumerBase, ConfirmedOwner {

    ...
    ///// USE NEW WRAPPER CONSUMER BASE CONSTRUCTOR /////
    constructor()
        ConfirmedOwner(msg.sender)
        VRFV2PlusWrapperConsumerBase(wrapperAddress) ///// ONLY PASS IN WRAPPER ADDRESS /////
    {}

    function requestRandomWords(
        bool enableNativePayment
    ) external onlyOwner returns (uint256) {
        ///// UPDATE TO NEW V2.5 REQUEST FORMAT: ADD EXTRA ARGS /////
        bytes memory extraArgs = VRFV2PlusClient._argsToBytes(
            VRFV2PlusClient.ExtraArgsV1({nativePayment: enableNativePayment})
        );
        uint256 requestId;
        uint256 reqPrice;
        if (enableNativePayment) { 
            ///// USE THIS FUNCTION TO PAY IN NATIVE TOKENS /////
            (requestId, reqPrice) = requestRandomnessPayInNative(
                callbackGasLimit,
                requestConfirmations,
                numWords,
                extraArgs ///// PASS IN EXTRA ARGS /////
            );
        } else {
            ///// USE THIS FUNCTION TO PAY IN LINK /////
            (requestId, reqPrice) = requestRandomness(
                callbackGasLimit,
                requestConfirmations,
                numWords,
                extraArgs ///// PASS IN EXTRA ARGS /////
            );
        }
        ...
        return requestId;
    }
   ...
}
```

[Image: copy to clipboard]
```solidity
// SPDX-License-Identifier: MIT
// An example of a consumer contract that directly pays for each request.
pragma solidity ^0.8.7;

///// USES V2 IMPORTS /////
import {ConfirmedOwner} from "@chainlink/contracts/src/v0.8/shared/access/ConfirmedOwner.sol";
import {VRFV2WrapperConsumerBase} from "@chainlink/contracts/src/v0.8/vrf/VRFV2WrapperConsumerBase.sol";
import {LinkTokenInterface} from "@chainlink/contracts/src/v0.8/shared/interfaces/LinkTokenInterface.sol";

/\*\*

- THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
- THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
- DO NOT USE THIS CODE IN PRODUCTION.
  \*/

///// USES V2 WRAPPER CONSUMER BASE CONTRACT /////
contract VRFv2DirectFundingConsumer is
VRFV2WrapperConsumerBase,
ConfirmedOwner
{
...

    ///// USES V2 WRAPPER CONSUMER BASE CONSTRUCTOR /////
    constructor()
        ConfirmedOwner(msg.sender)
        VRFV2WrapperConsumerBase(linkAddress, wrapperAddress) ///// TWO PARAMETERS /////
    {}

    function requestRandomWords()
        external
        onlyOwner
        returns (uint256 requestId)
    {
        ///// USES V2 REQUEST FORMAT /////
        requestId = requestRandomness(
            callbackGasLimit,
            requestConfirmations,
            numWords
        );
        ...
        return requestId;
    }

...

}
```

================================================================================

# Subscription Method

Source: https://docs.chain.link/vrf/v2-5/overview/subscription
Extraction Method: playwright
Components: code_block(5)

# Subscription Method
[Image: tip]Security Considerations

Be sure to review your contracts with the security considerations in mind.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }This section explains how to generate random numbers using the subscription method.

[Image: note]Migrate to V2.5

Follow the migration guide to learn how VRF has changed in V2.5 and to get example
code.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
## Subscriptions
VRF v2.5 requests receive funding from subscription accounts. Creating a VRF subscription lets you create an account and pre-pay for VRF v2.5, so you don't provide funding each time your application requests randomness. This reduces the total gas cost to use VRF v2.5. It also provides a simple way to fund your use of Chainlink products from a single location, so you don't have to manage multiple wallets across several different systems and applications.

Subscriptions have the following core concepts:

• Subscription id: 256-bit unsigned integer representing the unique identifier of the subscription.
• Subscription accounts: An account that holds LINK and native tokens and makes them available to fund requests to Chainlink VRF v2.5 coordinators.
• Subscription owner: The wallet address that creates and manages a subscription account. Any account can add LINK or native tokens to the subscription balance, but only the owner can add approved consuming contracts or withdraw funds.
• Consumers: Consuming contracts that are approved to use funding from your subscription account.
• Subscription balance: The amount of funds in LINK or native tokens maintained on your subscription account. Your subscription can maintain balances for both LINK and native tokens. Requests from consuming contracts will continue to be funded until the balance runs out, so be sure to maintain sufficient funds in your subscription balance to pay for the requests and keep your applications running.

For Chainlink VRF v2.5 to fulfill your requests, you must maintain a sufficient amount of LINK or native tokens in your subscription balance. Gas cost calculation includes the following variables:

• Gas price: The current gas price, which fluctuates depending on network conditions.
• Callback gas: The amount of gas used for the callback request that returns your requested random values.
• Verification gas: The amount of gas used to verify randomness onchain.

The gas price depends on current network conditions. The callback gas depends on your callback function, and the number of random values in your request. The cost of each request is final only after the transaction is complete, but you define the limits you are willing to spend for the request with the following variables:

• Gas lane: The maximum gas price you are willing to pay for a request in wei. Define this limit by specifying the appropriate keyHash in your request. The limits of each gas lane are important for handling gas price spikes when Chainlink VRF bumps the gas price to fulfill your request quickly.
• Callback gas limit: Specifies the maximum amount of gas you are willing to spend on the callback request. Define this limit by specifying the callbackGasLimit value in your request.

## Request and receive data
Requests to Chainlink VRF v2.5 follow the request and receive data cycle similarly to VRF V2. This end-to-end diagram shows each step in the lifecycle of a VRF subscription request, and registering a smart contract with a VRF subscription account:

astro-island,astro-slot,astro-static-slot{display:contents}(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).only=e;window.dispatchEvent(new Event("astro:only"));})();(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();VRF v2.5 uses both offchain and onchain components:

• VRF v2.5 Coordinator (onchain component): A contract designed to interact with the VRF service. It emits an event when a request for randomness is made, and then verifies the random number and proof of how it was generated by the VRF service.
• VRF service (offchain component): Listens for requests by subscribing to the VRF Coordinator event logs and calculates a random number based on the block hash and nonce. The VRF service then sends a transaction to the VRFCoordinator including the random number and a proof of how it was generated.

### Account types used in VRF
Two types of accounts exist in the Ethereum ecosystem, and both are used in VRF:

• Externally Owned Account (EOA): An externally owned account that has a private key and can control a smart contract. Transactions can only be initiated by EOAs.
• Smart contract: A contract that does not have a private key and executes what it has been designed for as a decentralized application.

While only EOAs can initiate transactions, do not attempt to use EOAs to send VRF requests directly. Instead, your EOA should interact with your consuming contract: the smart contract that is consuming the random values you request from VRF. Your EOA initiates the transaction, and then your consuming contract sends the VRF request.

### Set up your contract and request
Set up your consuming contract:

1. Your contract must inherit VRFConsumerBaseV2Plus.
2. Your contract must implement the fulfillRandomWords function, which is the callback VRF function. Here, you add logic to handle the random values after they are returned to your contract.
3. Submit your VRF request by calling requestRandomWords of the VRF Coordinator. Include the following parameters in your request:

keyHash: Identifier that maps to a job and a private key on the VRF service and that represents a specified gas lane. If your request is urgent, specify a gas lane with a higher gas price limit. The configuration for your network can be found here.
s_subscriptionId: The subscription ID that the consuming contract is registered to. LINK funds are deducted from this subscription.
requestConfirmations: The number of block confirmations the VRF service will wait to respond. The minimum and maximum confirmations for your network can be found here.
callbackGasLimit: The maximum amount of gas a user is willing to pay for completing the callback VRF function. Note that you cannot put a value larger than maxGasLimit of the VRF Coordinator contract (read coordinator contract limits for more details).
numWords: The number of random numbers to request. The maximum random values that can be requested for your network can be found here.

In VRF 2.5, the request format has changed:

[Image: copy to clipboard]
```solidity
uint256 requestID = s_vrfCoordinator.requestRandomWords(VRFV2PlusClient.RandomWordsRequest({
    keyHash: keyHash,
    subId: subId,
    requestConfirmations: requestConfirmations,
    callbackGasLimit: callbackGasLimit,
    numWords: numWords,
    extraArgs: VRFV2PlusClient._argsToBytes(VRFV2PlusClient.ExtraArgsV1({nativePayment: true})) // new parameter
  })
);
```

1. Add the setCoordinator method to your contract. This makes it easier to update your contract for future VRF releases by setting the new coordinator.

### How VRF processes your request
After you submit your request, it is processed using the Request & Receive Data cycle. The VRF coordinator processes the request and determines the final charge to your subscription using the following steps:

1. The VRF coordinator emits an event.
2. The VRF service picks up the event and waits for the specified number of block confirmations to respond back to the VRF coordinator with the random values and a proof (requestConfirmations).
3. The VRF coordinator verifies the proof onchain, then it calls back the consuming contract fulfillRandomWords function.

## Limits
Chainlink VRF v2.5 has subscription limits and coordinator contract limits.

### Subscription limits
Subscriptions are required to maintain a minimum balance, and they can support a limited number of consuming contracts.

#### Minimum subscription balance
Each subscription must maintain a minimum balance to fund requests from consuming contracts. This minimum balance requirement serves as a buffer against gas volatility by ensuring that all your requests have more than enough funding to go through. If your balance is below the minimum, your requests remain pending for up to 24 hours before they expire. After you add sufficient LINK or native tokens to a subscription, pending requests automatically process as long as they have not expired.

In the Subscription Manager, the minimum subscription balance is displayed as the Max Cost, and it indicates the amount of LINK or native tokens you need to add for a pending request to process. After the request is processed, only the amount actually consumed by the request is deducted from your balance. For example, if you are paying for your VRF requests in LINK and your minimum balance is 10 LINK, but your subscription balance is 5 LINK, you need to add at least 5 more LINK for your request to process. This does not mean that your request will ultimately cost 10 LINK. If the request ultimately costs 3 LINK after it has processed, then 3 LINK is deducted from your subscription balance. The same concept applies if you are paying in native tokens.

The minimum subscription balance must be sufficient for each new consuming contract that you add to a subscription. For example, the minimum balance for a subscription that supports 20 consuming contracts needs to cover all the requests for all 20 contracts, while a subscription with one consuming contract only needs to cover that one contract.

For one request, the required size of the minimum balance depends on the gas lane and the size of the request. For example, a consuming contract that requests one random value will require a smaller minimum balance than a consuming contract that requests 50 random values. In general, you can estimate the required minimum balance using the following formula where max verification gas is always 200,000 gwei.

The following formulas show how the minimum subscription balance is calculated for LINK and native tokens in general. Specific examples of each are available on the Billing page, where you can compare the higher minimum subscription balance with the lower amount for an actual request.

(()=>{var a=(s,i,o)=>{let r=async()=>{await(await s())()},t=typeof i.value=="object"?i.value:void 0,c={rootMargin:t==null?void 0:t.rootMargin},n=new IntersectionObserver(e=>{for(let l of e)if(l.isIntersecting){n.disconnect(),r();break}},c);for(let e of o.children)n.observe(e)};(self.Astro||(self.Astro={})).visible=a;window.dispatchEvent(new Event("astro:visible"));})();LINKNative tokens[Image: copy to clipboard]
```plaintext
(((Gas lane maximum * (Max verification gas + Callback gas limit)) * (100 + premium %)/100) / (1,000,000,000 Gwei/ETH)) / (ETH/LINK price) = Minimum LINK
```

Here is the same formula, broken out into steps:

[Image: copy to clipboard]
```plaintext
Gas lane maximum * (Max verification gas + Callback gas limit) = Total estimated gas (Gwei)
Total estimated gas (Gwei) * ((100 + premium %)/100) = Total estimated gas with premium (Gwei)
Total estimated gas with premium (Gwei) / 1,000,000,000 Gwei/ETH = Total estimated gas with premium (ETH)
Total estimated gas with premium (ETH) / (ETH/LINK price) = Total estimated gas with premium (LINK)
```

[Image: copy to clipboard]
```plaintext
(((Gas lane maximum * (Max verification gas + Callback gas limit)) * (100 + premium %)/100) / (1,000,000,000 Gwei/ETH)) / (ETH/[Native token] price) = Minimum [Native token]
```

Here is the same formula, broken out into steps:

[Image: copy to clipboard]
```plaintext
Gas lane maximum * (Max verification gas + Callback gas limit) = Total estimated gas (Gwei)
Total estimated gas (Gwei) * ((100 + premium %)/100) = Total estimated gas with premium (Gwei)
Total estimated gas with premium (Gwei) / 1,000,000,000 Gwei/ETH = Total estimated gas with premium (ETH)
Total estimated gas with premium (ETH) / (ETH/[Native token] price) = Total estimated gas with premium (Native token)
```

#### Maximum consuming contracts
Each subscription supports up to 100 consuming contracts. If you need more than 100 consuming contracts, create multiple subscriptions.

### Coordinator contract limits
You can see the configuration for each network on the Supported networks page. You can also view the full configuration for each coordinator contract directly in the block explorer for that network, for example, Etherscan or Polygonscan.

• Each coordinator has a MAX_NUM_WORDS parameter that limits the maximum number of random values you can receive in each request.
• Each coordinator has a maxGasLimit parameter, which is the maximum allowed callbackGasLimit value for your requests. You must specify a sufficient callbackGasLimit to fund the callback request to your consuming contract. This depends on the number of random values you request and how you process them in your fulfillRandomWords() function. If your callbackGasLimit is not sufficient, the callback fails but your subscription is still charged for the work done to generate your requested random values.

================================================================================

# Create and manage VRF V2.5 subscriptions

Source: https://docs.chain.link/vrf/v2-5/subscription/create-manage
Extraction Method: playwright

# Create and manage VRF V2.5 subscriptions
[Image: tip]Security Considerations

Be sure to review your contracts with the security considerations in mind.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
## Using the VRF Subscription Manager
The VRF Subscription Manager is available to help you create and manage VRF V2.5 subscriptions. You can create and manage new V2.5 subscriptions, and manage existing V2 subscriptions, but you can no longer create new V2 subscriptions in the VRF Subscription Manager. Alternatively, you can create and manage subscriptions programmatically.

### Create a subscription
To create a VRF 2.5 subscription:

1. Use the VRF Subscription Manager at vrf.chain.link. Connect your wallet in the upper right corner and then click Create subscription. The address of your connected wallet is automatically filled in the Admin address field.
2. When the subscription is successfully created, there will be an alert in the upper right corner telling you that the subscription was successfully created. Click Home to navigate back to your main dashboard.
3. Your new subscription shows in the My Subscriptions list, along with any previous V2 subscriptions you might have. Click the Subscription ID for your new subscription in the list.

### Add a consumer
To add a consuming contract:

1. On the details page for your subscription, select Add Consumer.
2. Provide the address of your consuming contract, and then select Add Consumer again. Confirm the resulting prompts in MetaMask or other wallet browser extension.

### Fund your subscription
To fund your subscription:

1. On the page for your subscription, select the Actions menu and then select Fund subscription.
2. Your subscription has two balances: one for LINK, and one for the native token. Expand the Asset menu to select either LINK or the native token.
3. In Amount to fund, enter the amount you want to fund your subscription. Your wallet balance is displayed below the Asset field for easier reference. Select Confirm to fund your wallet, and then confirm the resulting prompts in MetaMask or other wallet browser extension.

### Cancel your subscription and withdraw funds
To withdraw your funds from a subscription, you must cancel the subscription.

1. Open the Subscription Manager at vrf.chain.link and click the ID of your new subscription under the My Subscriptions list. The subscription details page opens.
2. On your subscription details page, expand the Actions menu and select Cancel subscription. A field displays, prompting you to add the wallet address you want to send the remaining funds to.
3. Enter your wallet address and click Cancel subscription. MetaMask opens and asks you to confirm the transaction. After you approve the transaction, Chainlink VRF closes your subscription account and sends the remaining LINK to your wallet.

If your subscription's admin address is a contract instead of an EOA, you may not be able to cancel the subscription directly. In this case, you must transfer ownership of your subscription to an EOA so that you can cancel the subscription and withdraw your funds.

## Create a subscription programmatically
If you prefer to create, fund and manage your subscriptions programmatically, you can either deploy a subscription manager contract or use your network's block explorer:

1. Create a new subscription for VRF v2.5:
Subscription contractUsing a block explorerDeploy the SubscriptionManager contract. On deployment, the contract creates a new subscription and adds itself as a consumer to the new subscription.
Navigate to the VRF coordinator contract on the block explorer for the network you want to use (for example, Etherscan or Polygonscan). You can find the coordinator addresses with links to the block explorers on the Supported Networks page.
In the Contract tab, select the Write contract tab. Connect your wallet to the block explorer.
Expand the createSubscription function and select the Write button. Follow the prompts in MetaMask to confirm the transaction.
Get your subscription ID for the next step, funding your subscription.
2. Fund your new VRF v2.5 subscription:
Subscription contractUsing a block explorer
Fund your new VRFv2PlusSubscriptionManager contract.
Call topUpSubscription from the VRFv2PlusSubscriptionManager contract. This function uses the LINK token contract's transferAndCall function to fund your new subscription.

Fund your new VRFv2PlusSubscriptionManager contract.
Navigate to the LINK token contract on the block explorer for the network you want to use (for example, Etherscan or Polygonscan). You can find the LINK token contract addresses with links to the block explorers on the Supported Networks page.
In the Contract tab, select the Write contract tab. Connect your wallet to the block explorer.
Expand the transferAndCall function and fill in the following parameters:

to(address): The address of the VRF coordinator.
value(uint256): The amount you want to fund your subscription with.
data(bytes): The ABI-encoded subscription ID.

Select the Write button and follow the prompts in MetaMask to confirm the transaction.

================================================================================

# Get a Random Number

Source: https://docs.chain.link/vrf/v2-5/subscription/get-a-random-number
Extraction Method: playwright
Components: code_block(1)

# Get a Random Number
This guide explains how to get random values using a simple contract to request and receive random values from Chainlink VRF v2.5. The guide uses the Subscription Manager to create and manage your subscription. Alternatively, you can also create and manage subscriptions programmatically. To explore more applications of VRF, refer to our blog.

[Image: note]VRF Subscription Manager limitations

The VRF Subscription Manager is available to help you create and manage VRF subscriptions.
You can create and manage new V2.5 subscriptions, and manage existing V2 subscriptions, but you can no longer create
new V2 subscriptions in the VRF Subscription Manager. Alternatively, you can create and manage V2 subscriptions
programmatically.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
## Requirements
This guide assumes that you know how to create and deploy smart contracts on Ethereum testnets using the following tools:

• The Remix IDE
• MetaMask
• Sepolia testnet ETH

If you are new to developing smart contracts on Ethereum, see the Getting Started guide to learn the basics.

## Create and fund a subscription
For this example, create a new subscription on the Sepolia testnet.

1. Open MetaMask and set it to use the Sepolia testnet. The Subscription Manager detects your network based on the active network in MetaMask.
2. Check MetaMask to make sure you have testnet ETH and LINK on Sepolia. You can get testnet ETH and LINK at faucets.chain.link/sepolia.
3. Open the Subscription Manager at vrf.chain.link.
Open the Subscription Manager
4. Click Create Subscription and follow the instructions to create a new subscription account. If you connect your wallet to the Subscription Manager, the Admin address for your subscription is prefilled and not editable. Optionally, you can enter an email address and a project name for your subscription, and both of these are private. MetaMask opens and asks you to confirm payment to create the account onchain. After you approve the transaction, the network confirms the creation of your subscription account onchain.
5. After the subscription is created, click Add funds and follow the instructions to fund your subscription.
For your request to go through, you need to fund your subscription with enough testnet funds to meet your minimum subscription balance to serve as a buffer against gas volatility.

If you're paying with testnet LINK, fund your contract with 7 LINK. (After your request is processed, the actual cost will be around 0.06 LINK, and that amount will be deducted from your subscription balance.)
If you're paying with testnet ETH, fund your contract with 0.03 ETH. (After your request is processed, the actual cost will be around 0.000247 ETH, and that amount will be deducted from your subscription balance.)

MetaMask opens to confirm the token transfer to your subscription. After you approve the transaction, the network confirms the transfer of your testnet funds to your subscription account.
6. After you add funds, click Add consumer. A page opens with your account details and subscription ID.
7. Record your subscription ID, which you need for your consuming contract. You will add the consuming contract to your subscription later.

You can always find your subscription IDs, balances, and consumers at vrf.chain.link.

Now that you have a funded subscription account and your subscription ID, create and deploy a VRF compatible contract.

## Create and deploy a VRF compatible contract
For this example, use the SubscriptionConsumer.sol sample contract. This contract imports the following dependencies:

• VRFConsumerBaseV2Plus.sol(link)
• VRFV2PlusClient.sol(link)

The contract also includes pre-configured values for the necessary request parameters such as vrfCoordinator address, gas lane keyHash, callbackGasLimit, requestConfirmations and number of random words numWords. You can change these parameters if you want to experiment on different testnets, but for this example you only need to specify subscriptionId when you deploy the contract.

Build and deploy the contract on Sepolia.

1. Open the SubscriptionConsumer.sol in Remix.

Open in Remix
What is Remix?
2. On the Compile tab in Remix, compile the SubscriptionConsumer.sol contract.
3. Configure your deployment. On the Deploy tab in Remix, select the Injected Provider environment, select the SubscriptionConsumer contract from the contract list, and specify your subscriptionId so the constructor can set it.
4. Click the Deploy button to deploy your contract onchain. MetaMask opens and asks you to confirm the transaction.
5. After you deploy your contract, copy the address from the Deployed Contracts list in Remix. Before you can request randomness from VRF v2.5, you must add this address as an approved consuming contract on your subscription account.
6. Open the Subscription Manager at vrf.chain.link and click the ID of your new subscription under the My Subscriptions list. The subscription details page opens.
7. Under the Consumers section, click Add consumer.
8. Enter the address of your consuming contract that you just deployed and click Add consumer. MetaMask opens and asks you to confirm the transaction.

Your example contract is deployed and approved to use your subscription balance to pay for VRF v2.5 requests. Next, request random values from Chainlink VRF.

## Request random values
The deployed contract requests random values from Chainlink VRF, receives those values, builds a struct RequestStatus containing them and stores the struct in a mapping s_requests. Run the requestRandomWords() function on your contract to start the request.

1. Return to Remix and view your deployed contract functions in the Deployed Contracts list.
2. Expand the requestRandomWords() function to send the request for random values to Chainlink VRF. Use enableNativePayment to specify whether you want to pay in native tokens or LINK:

To use native tokens, set enableNativePayment to true.
To use LINK, set enableNativePayment to false.

When you click transact, MetaMask opens and asks you to confirm the transaction. After you approve the transaction, Chainlink VRF processes your request. Chainlink VRF fulfills the request and returns the random values to your contract in a callback to the fulfillRandomWords() function. At this point, a new key requestId is added to the mapping s_requests.
Depending on current testnet conditions, it might take a few minutes for the callback to return the requested random values to your contract. You can see a list of pending requests for your subscription ID at vrf.chain.link.
3. To fetch the request ID of your request, call lastRequestId().
4. After the oracle returns the random values to your contract, the mapping s_requests is updated: The received random values are stored in s_requests[_requestId].randomWords.
5. Call getRequestStatus() specifying the requestId to display the random words.

You deployed a simple contract that can request and receive random values from Chainlink VRF. Next, learn how to create and manage subscriptions programmatically by using a smart contract instead of the Subscription Manager.

[Image: note]Note on Requesting Randomness

Do not allow re-requesting or cancellation of randomness. For more information, see the VRF Security
Considerations page.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
## Analyzing the contract
In this example, your MetaMask wallet is the subscription owner and you created a consuming contract to use that subscription. The consuming contract uses static configuration parameters.

[Image: copy to clipboard]
```solidity
// SPDX-License-Identifier: MIT
// An example of a consumer contract that relies on a subscription for funding.
pragma solidity 0.8.19;

import {VRFConsumerBaseV2Plus} from "@chainlink/contracts/src/v0.8/vrf/dev/VRFConsumerBaseV2Plus.sol";
import {VRFV2PlusClient} from "@chainlink/contracts/src/v0.8/vrf/dev/libraries/VRFV2PlusClient.sol";

/**
 * Request testnet LINK and ETH here: https://faucets.chain.link/
 * Find information on LINK Token Contracts and get the latest ETH and LINK faucets here: https://docs.chain.link/docs/link-token-contracts/
 */

/**
 * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
 * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

contract SubscriptionConsumer is VRFConsumerBaseV2Plus {
    event RequestSent(uint256 requestId, uint32 numWords);
    event RequestFulfilled(uint256 requestId, uint256[] randomWords);

    struct RequestStatus {
        bool fulfilled; // whether the request has been successfully fulfilled
        bool exists; // whether a requestId exists
        uint256[] randomWords;
    }
    mapping(uint256 => RequestStatus)
        public s_requests; /* requestId --> requestStatus */

    // Your subscription ID.
    uint256 public s_subscriptionId;

    // Past request IDs.
    uint256[] public requestIds;
    uint256 public lastRequestId;

    // The gas lane to use, which specifies the maximum gas price to bump to.
    // For a list of available gas lanes on each network,
    // see https://docs.chain.link/vrf/v2-5/supported-networks
    bytes32 public keyHash =
        0x787d74caea10b2b357790d5b5247c2f63d1d91572a9846f780606e4d953677ae;

    // Depends on the number of requested values that you want sent to the
    // fulfillRandomWords() function. Storing each word costs about 20,000 gas,
    // so 100,000 is a safe default for this example contract. Test and adjust
    // this limit based on the network that you select, the size of the request,
    // and the processing of the callback request in the fulfillRandomWords()
    // function.
    uint32 public callbackGasLimit = 100000;

    // The default is 3, but you can set this higher.
    uint16 public requestConfirmations = 3;

    // For this example, retrieve 2 random values in one request.
    // Cannot exceed VRFCoordinatorV2_5.MAX_NUM_WORDS.
    uint32 public numWords = 2;

    /**
     * HARDCODED FOR SEPOLIA
     * COORDINATOR: 0x9DdfaCa8183c41ad55329BdeeD9F6A8d53168B1B
     */
    constructor(
        uint256 subscriptionId
    ) VRFConsumerBaseV2Plus(0x9DdfaCa8183c41ad55329BdeeD9F6A8d53168B1B) {
        s_subscriptionId = subscriptionId;
    }

    // Assumes the subscription is funded sufficiently.
    // @param enableNativePayment: Set to `true` to enable payment in native tokens, or
    // `false` to pay in LINK
    function requestRandomWords(
        bool enableNativePayment
    ) external onlyOwner returns (uint256 requestId) {
        // Will revert if subscription is not set and funded.
        requestId = s_vrfCoordinator.requestRandomWords(
            VRFV2PlusClient.RandomWordsRequest({
                keyHash: keyHash,
                subId: s_subscriptionId,
                requestConfirmations: requestConfirmations,
                callbackGasLimit: callbackGasLimit,
                numWords: numWords,
                extraArgs: VRFV2PlusClient._argsToBytes(
                    VRFV2PlusClient.ExtraArgsV1({
                        nativePayment: enableNativePayment
                    })
                )
            })
        );
        s_requests[requestId] = RequestStatus({
            randomWords: new uint256[](0),
            exists: true,
            fulfilled: false
        });
        requestIds.push(requestId);
        lastRequestId = requestId;
        emit RequestSent(requestId, numWords);
        return requestId;
    }

    function fulfillRandomWords(
        uint256 _requestId,
        uint256[] calldata _randomWords
    ) internal override {
        require(s_requests[_requestId].exists, "request not found");
        s_requests[_requestId].fulfilled = true;
        s_requests[_requestId].randomWords = _randomWords;
        emit RequestFulfilled(_requestId, _randomWords);
    }

    function getRequestStatus(
        uint256 _requestId
    ) external view returns (bool fulfilled, uint256[] memory randomWords) {
        require(s_requests[_requestId].exists, "request not found");
        RequestStatus memory request = s_requests[_requestId];
        return (request.fulfilled, request.randomWords);
    }
}
```

[Open in Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/VRF/v2-5/SubscriptionConsumer.sol&autoCompile=true)[What is Remix?](/getting-started/conceptual-overview#what-is-remix)The parameters define how your requests will be processed. You can find the values for your network in the Configuration page.

• uint256 s_subscriptionId: The subscription ID that this contract uses for funding requests.
• bytes32 keyHash: The gas lane key hash value, which is the maximum gas price you are willing to pay for a request in wei. It functions as an ID of the offchain VRF job that runs in response to requests.
• uint32 callbackGasLimit: The limit for how much gas to use for the callback request to your contract's fulfillRandomWords() function. It must be less than the maxGasLimit limit on the coordinator contract. Adjust this value for larger requests depending on how your fulfillRandomWords() function processes and stores the received random values. If your callbackGasLimit is not sufficient, the callback will fail and your subscription is still charged for the work done to generate your requested random values.
• uint16 requestConfirmations: How many confirmations the Chainlink node should wait before responding. The longer the node waits, the more secure the random value is. It must be greater than the minimumRequestBlockConfirmations limit on the coordinator contract.
• uint32 numWords: How many random values to request. If you can use several random values in a single callback, you can reduce the amount of gas that you spend per random value. The total cost of the callback request depends on how your fulfillRandomWords() function processes and stores the received random values, so adjust your callbackGasLimit accordingly.

The contract includes the following functions:

• requestRandomWords(bool enableNativePayment): Takes your specified parameters and submits the request to the VRF coordinator contract. Use enableNativePayment to specify for each request whether you want to pay in native tokens or LINK:

To use native tokens, set enableNativePayment to true.
To use LINK, set enableNativePayment to false.
• fulfillRandomWords(): Receives random values and stores them with your contract.
• getRequestStatus(): Retrieve request details for a given _requestId.

[Image: note]Security Considerations

Be sure to review your contracts to make sure they follow the best practices on the security
considerations page.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
## Clean up
After you are done with this contract and the subscription, you can retrieve the remaining testnet tokens to use with other examples.

1. Open the Subscription Manager at vrf.chain.link and click the ID of your new subscription under the My Subscriptions list. The subscription details page opens.
2. On your subscription details page, expand the Actions menu and select Cancel subscription. A field displays, prompting you to add the wallet address you want to send the remaining funds to.
3. Enter your wallet address and click Cancel subscription. MetaMask opens and asks you to confirm the transaction. After you approve the transaction, Chainlink VRF closes your subscription account and sends the remaining LINK to your wallet.

================================================================================

# Supported Networks

Source: https://docs.chain.link/vrf/v2-5/supported-networks
Extraction Method: playwright
Components: table(36)

# Supported Networks
Chainlink VRF allows you to integrate provably fair and verifiably random data in your smart contract. For implementation details, read Introduction to Chainlink VRF.

VRF v2.5 coordinators for subscription funding are available on several networks. To use Chainlink VRF on certain networks, you may need to conduct token transfers. You can transfer tokens by using Chainlink CCIP, Transporter or third-party applications such as XSwap.

[Image: tip]Security Considerations

Be sure to review your contracts with the security considerations in mind.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }[Image: note]Interfaces and Applications

Chainlink CCIP is a messaging protocol. Third parties may build user interfaces or other applications on top of CCIP.
Neither Chainlink Labs nor the Chainlink Foundation owns, controls, endorses, or assumes any responsibility for any
such interfaces or applications. You are solely responsible for your use of such interfaces or applications. Please
visit the Chainlink Foundation Terms of Service for more information.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }[Image: caution]Understand Risks associated with Bridges

If you are using a cross-chain bridge to transfer your LINK tokens, read the Bridges and Associated Risks guide to understand what cross-chain bridges are and the risks associated with using them.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
## Coordinator parameters
These parameters are configured in the coordinator contract. You can view these values by running getConfig on the coordinator or by viewing the coordinator contracts in a blockchain explorer.

• uint16 minimumRequestConfirmations: The minimum number of confirmation blocks on VRF requests before oracles respond
• uint32 maxGasLimit: The maximum gas limit supported for a fulfillRandomWords callback.
• uint32 stalenessSeconds: How long the coordinator waits until we consider the ETH/LINK price used for converting gas costs to LINK is stale and use fallbackWeiPerUnitLink
• uint32 gasAfterPaymentCalculation: How much gas is used outside of the payment calculation. This covers the additional operations required to decrement the subscription balance and increment the balance for the oracle that handled the request.

## Arbitrum

### Arbitrum Mainnet
astro-island,astro-slot,astro-static-slot{display:contents}(()=>{var a=(s,i,o)=>{let r=async()=>{await(await s())()},t=typeof i.value=="object"?i.value:void 0,c={rootMargin:t==null?void 0:t.rootMargin},n=new IntersectionObserver(e=>{for(let l of e)if(l.isIntersecting){n.disconnect(),r();break}},c);for(let e of o.children)n.observe(e)};(self.Astro||(self.Astro={})).visible=a;window.dispatchEvent(new Event("astro:visible"));})();(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();SubscriptionDirect funding
Item | Value
--- | ---
LINK Token | 0xf97f4df75117a78c1A5a0DBb814Af92458539FB4
VRF Coordinator | 0x3C0Ca683b403E37668AE3DC4FB62F4B29B6f7a3e
2 gwei Key Hash | 0x9e9e46732b32662b9adc6f3abdf6c5e926a666d174a4d6b8e39c4cca76a38897
30 gwei Key Hash | 0x8472ba59cf7134dfe321f4d61a430c4857e8b19cdd5230b09952a92671c24409
150 gwei Key Hash | 0xe9f223d7d83ec85c4f78042a4845af3a1c8df7757b4997b815ce4b8d07aca68c
Premium percentage  (paying with ETH) | 60
Premium percentage  (paying with LINK) | 50
Max Gas Limit | 2,500,000
Minimum Confirmations | 1
Maximum Confirmations | 200
Maximum Random Values | 500

Item | Value
--- | ---
LINK Token | 0xf97f4df75117a78c1A5a0DBb814Af92458539FB4
VRF Wrapper | 0x14632CD5c12eC5875D41350B55e825c54406BaaB
VRF Coordinator | 0x3C0Ca683b403E37668AE3DC4FB62F4B29B6f7a3e
2 gwei Key Hash | 0x9e9e46732b32662b9adc6f3abdf6c5e926a666d174a4d6b8e39c4cca76a38897
30 gwei Key Hash | 0x8472ba59cf7134dfe321f4d61a430c4857e8b19cdd5230b09952a92671c24409
150 gwei Key Hash | 0xe9f223d7d83ec85c4f78042a4845af3a1c8df7757b4997b815ce4b8d07aca68c
Premium percentage  (paying with ETH) | 60
Premium percentage  (paying with LINK) | 50
Minimum Confirmations | 0
Maximum Confirmations | 200
Maximum Random Values | 10
Wrapper Gas overhead | 13400
Coordinator Gas Overhead (Native) | 104500
Coordinator Gas Overhead (LINK) | 126500
Coordinator Gas Overhead per Word | 435

### Arbitrum Sepolia Testnet
Testnet ETH and LINK are available from https://faucets.chain.link/arbitrum-sepolia

SubscriptionDirect funding
Item | Value
--- | ---
LINK Token | 0xb1D4538B4571d411F07960EF2838Ce337FE1E80E
VRF Coordinator | 0x5CE8D5A2BC84beb22a398CCA51996F7930313D61
50 gwei Key Hash | 0x1770bdc7eec7771f7ba4ffd640f34260d7f095b79c92d34a5b2551d6f6cfd2be
Premium percentage  (paying with Sepolia ETH) | 60
Premium percentage  (paying with testnet LINK) | 50
Max Gas Limit | 2,500,000
Minimum Confirmations | 1
Maximum Confirmations | 200
Maximum Random Values | 500

Item | Value
--- | ---
LINK Token | 0xb1D4538B4571d411F07960EF2838Ce337FE1E80E
VRF Wrapper | 0x29576aB8152A09b9DC634804e4aDE73dA1f3a3CC
VRF Coordinator | 0x5CE8D5A2BC84beb22a398CCA51996F7930313D61
50 gwei Key Hash | 0x1770bdc7eec7771f7ba4ffd640f34260d7f095b79c92d34a5b2551d6f6cfd2be
Premium percentage  (paying with Sepolia ETH) | 60
Premium percentage  (paying with testnet LINK) | 50
Minimum Confirmations | 0
Maximum Confirmations | 200
Maximum Random Values | 10
Wrapper Gas overhead | 13400
Coordinator Gas Overhead (Native) | 104500
Coordinator Gas Overhead (LINK) | 126500
Coordinator Gas Overhead per Word | 435

## Avalanche

### Avalanche Mainnet
SubscriptionDirect funding
Item | Value
--- | ---
LINK Token | 0x5947BB275c521040051D82396192181b413227A3
VRF Coordinator | 0xE40895D055bccd2053dD0638C9695E326152b1A4
200 gwei Key Hash | 0xea7f56be19583eeb8255aa79f16d8bd8a64cedf68e42fefee1c9ac5372b1a102
500 gwei Key Hash | 0x84213dcadf1f89e4097eb654e3f284d7d5d5bda2bd4748d8b7fada5b3a6eaa0d
1000 gwei Key Hash | 0xe227ebd10a873dde8e58841197a07b410038e405f1180bd117be6f6557fa491c
Premium percentage  (paying with AVAX) | 60
Premium percentage  (paying with LINK) | 50
Max Gas Limit | 2,500,000
Minimum Confirmations | 0
Maximum Confirmations | 200
Maximum Random Values | 500

Item | Value
--- | ---
LINK Token | 0x5947BB275c521040051D82396192181b413227A3
VRF Wrapper | 0x62Fb87c10A917580cA99AB9a86E213Eb98aa820C
VRF Coordinator | 0xE40895D055bccd2053dD0638C9695E326152b1A4
200 gwei Key Hash | 0xea7f56be19583eeb8255aa79f16d8bd8a64cedf68e42fefee1c9ac5372b1a102
500 gwei Key Hash | 0x84213dcadf1f89e4097eb654e3f284d7d5d5bda2bd4748d8b7fada5b3a6eaa0d
1000 gwei Key Hash | 0xe227ebd10a873dde8e58841197a07b410038e405f1180bd117be6f6557fa491c
Premium percentage  (paying with AVAX) | 60
Premium percentage  (paying with LINK) | 50
Minimum Confirmations | 0
Maximum Confirmations | 200
Maximum Random Values | 10
Wrapper Gas overhead | 13400
Coordinator Gas Overhead (Native) | 107000
Coordinator Gas Overhead (LINK) | 129000
Coordinator Gas Overhead per Word | 435

### Avalanche Fuji Testnet
Testnet LINK is available from https://faucets.chain.link/fuji

SubscriptionDirect funding
Item | Value
--- | ---
LINK Token | 0x0b9d5D9136855f6FEc3c0993feE6E9CE8a297846
VRF Coordinator | 0x5C210eF41CD1a72de73bF76eC39637bB0d3d7BEE
300 gwei Key Hash | 0xc799bd1e3bd4d1a41cd4968997a4e03dfd2a3c7c04b695881138580163f42887
Premium percentage  (paying with testnet AVAX) | 60
Premium percentage  (paying with testnet LINK) | 50
Max Gas Limit | 2,500,000
Minimum Confirmations | 1
Maximum Confirmations | 200
Maximum Random Values | 500

Item | Value
--- | ---
LINK Token | 0x0b9d5D9136855f6FEc3c0993feE6E9CE8a297846
VRF Wrapper | 0x327B83F409E1D5f13985c6d0584420FA648f1F56
VRF Coordinator | 0x5C210eF41CD1a72de73bF76eC39637bB0d3d7BEE
300 gwei Key Hash | 0xc799bd1e3bd4d1a41cd4968997a4e03dfd2a3c7c04b695881138580163f42887
Premium percentage  (paying with testnet AVAX) | 60
Premium percentage  (paying with testnet LINK) | 50
Minimum Confirmations | 0
Maximum Confirmations | 200
Maximum Random Values | 10
Wrapper Gas overhead | 13400
Coordinator Gas Overhead (Native) | 104500
Coordinator Gas Overhead (LINK) | 126500
Coordinator Gas Overhead per Word | 435

## BASE

### BASE Mainnet
SubscriptionDirect funding
Item | Value
--- | ---
LINK Token | 0x88Fb150BDc53A65fe94Dea0c9BA0a6dAf8C6e196
VRF Coordinator | 0xd5D517aBE5cF79B7e95eC98dB0f0277788aFF634
2 gwei Key Hash | 0x00b81b5a830cb0a4009fbd8904de511e28631e62ce5ad231373d3cdad373ccab
30 gwei Key Hash | 0xdc2f87677b01473c763cb0aee938ed3341512f6057324a584e5944e786144d70
Premium percentage  (paying with BASE) | 60
Premium percentage  (paying with LINK) | 50
Max Gas Limit | 2,500,000
Minimum Confirmations | 0
Maximum Confirmations | 200
Maximum Random Values | 500

Item | Value
--- | ---
LINK Token | 0x88Fb150BDc53A65fe94Dea0c9BA0a6dAf8C6e196
VRF Wrapper | 0xb0407dbe851f8318bd31404A49e658143C982F23
VRF Coordinator | 0xd5D517aBE5cF79B7e95eC98dB0f0277788aFF634
2 gwei Key Hash | 0x00b81b5a830cb0a4009fbd8904de511e28631e62ce5ad231373d3cdad373ccab
30 gwei Key Hash | 0xdc2f87677b01473c763cb0aee938ed3341512f6057324a584e5944e786144d70
Premium percentage  (paying with BASE) | 60
Premium percentage  (paying with LINK) | 50
Minimum Confirmations | 0
Maximum Confirmations | 200
Maximum Random Values | 10
Wrapper Gas overhead | 13400
Coordinator Gas Overhead (Native) | 128500
Coordinator Gas Overhead (LINK) | 150400
Coordinator Gas Overhead per Word | 435

### BASE Sepolia Testnet
SubscriptionDirect funding
Item | Value
--- | ---
LINK Token | 0xE4aB69C077896252FAFBD49EFD26B5D171A32410
VRF Coordinator | 0x5C210eF41CD1a72de73bF76eC39637bB0d3d7BEE
30 gwei Key Hash | 0x9e1344a1247c8a1785d0a4681a27152bffdb43666ae5bf7d14d24a5efd44bf71
Premium percentage  (paying with Sepolia BASE ETH) | 60
Premium percentage  (paying with LINK) | 50
Max Gas Limit | 2,500,000
Minimum Confirmations | 0
Maximum Confirmations | 200
Maximum Random Values | 500

Item | Value
--- | ---
LINK Token | 0xE4aB69C077896252FAFBD49EFD26B5D171A32410
VRF Wrapper | 0x7a1BaC17Ccc5b313516C5E16fb24f7659aA5ebed
VRF Coordinator | 0x5C210eF41CD1a72de73bF76eC39637bB0d3d7BEE
30 gwei Key Hash | 0x9e1344a1247c8a1785d0a4681a27152bffdb43666ae5bf7d14d24a5efd44bf71
Premium percentage  (paying with Sepolia BASE ETH) | 60
Premium percentage  (paying with LINK) | 50
Minimum Confirmations | 0
Maximum Confirmations | 200
Maximum Random Values | 10
Wrapper Gas overhead | 13400
Coordinator Gas Overhead (Native) | 128500
Coordinator Gas Overhead (LINK) | 150400
Coordinator Gas Overhead per Word | 435

## BNB Chain

### BNB Chain Mainnet
The LINK provided by the BNB Chain Bridge is not ERC-677 compatible, so cannot
be used with Chainlink oracles. However, it can be converted to the official LINK token on BNB Chain using Chainlink's PegSwap service.

SubscriptionDirect funding
Item | Value
--- | ---
LINK Token | 0x404460C6A5EdE2D891e8297795264fDe62ADBB75
VRF Coordinator | 0xd691f04bc0C9a24Edb78af9E005Cf85768F694C9
200 gwei Key Hash | 0x130dba50ad435d4ecc214aad0d5820474137bd68e7e77724144f27c3c377d3d4
500 gwei Key Hash | 0xeb0f72532fed5c94b4caf7b49caf454b35a729608a441101b9269efb7efe2c6c
1000 gwei Key Hash | 0xb94a4fdb12830e15846df59b27d7c5d92c9c24c10cf6ae49655681ba560848dd
Premium percentage  (paying with BNB) | 60
Premium percentage  (paying with LINK) | 50
Max Gas Limit | 2,500,000
Minimum Confirmations | 3
Maximum Confirmations | 200
Maximum Random Values | 500

Item | Value
--- | ---
LINK Token | 0x404460C6A5EdE2D891e8297795264fDe62ADBB75
VRF Wrapper | 0x471506e6ADED0b9811D05B8cAc8Db25eE839Ac94
VRF Coordinator | 0xd691f04bc0C9a24Edb78af9E005Cf85768F694C9
200 gwei Key Hash | 0x130dba50ad435d4ecc214aad0d5820474137bd68e7e77724144f27c3c377d3d4
500 gwei Key Hash | 0xeb0f72532fed5c94b4caf7b49caf454b35a729608a441101b9269efb7efe2c6c
1000 gwei Key Hash | 0xb94a4fdb12830e15846df59b27d7c5d92c9c24c10cf6ae49655681ba560848dd
Premium percentage  (paying with testnet BNB) | 60
Premium percentage  (paying with testnet LINK) | 50
Minimum Confirmations | 3
Maximum Confirmations | 200
Maximum Random Values | 10
Wrapper Gas overhead | 13400
Coordinator Gas Overhead (Native) | 99500
Coordinator Gas Overhead (LINK) | 121500
Coordinator Gas Overhead per Word | 435

### BNB Chain Testnet
SubscriptionDirect fundingTestnet LINK is available from https://faucets.chain.link/bnb-chain-testnet

Item | Value
--- | ---
LINK Token | 0x84b9B910527Ad5C03A9Ca831909E21e236EA7b06
VRF Coordinator | 0xDA3b641D438362C440Ac5458c57e00a712b66700
50 gwei Key Hash | 0x8596b430971ac45bdf6088665b9ad8e8630c9d5049ab54b14dff711bee7c0e26
Premium percentage  (paying with testnet BNB) | 60
Premium percentage  (paying with testnet LINK) | 50
Max Gas Limit | 2,500,000
Minimum Confirmations | 3
Maximum Confirmations | 200
Maximum Random Values | 500

Item | Value
--- | ---
LINK Token | 0x84b9B910527Ad5C03A9Ca831909E21e236EA7b06
VRF Wrapper | 0x471506e6ADED0b9811D05B8cAc8Db25eE839Ac94
VRF Coordinator | 0xDA3b641D438362C440Ac5458c57e00a712b66700
50 gwei Key Hash | 0x8596b430971ac45bdf6088665b9ad8e8630c9d5049ab54b14dff711bee7c0e26
Premium percentage  (paying with testnet BNB) | 60
Premium percentage  (paying with testnet LINK) | 50
Minimum Confirmations | 3
Maximum Confirmations | 200
Maximum Random Values | 10
Wrapper Gas overhead | 13400
Coordinator Gas Overhead (Native) | 99500
Coordinator Gas Overhead (LINK) | 121500
Coordinator Gas Overhead per Word | 435

## Ethereum

### Ethereum Mainnet
SubscriptionDirect funding
Item | Value
--- | ---
LINK Token | 0x514910771AF9Ca656af840dff83E8264EcF986CA
VRF Coordinator | 0xD7f86b4b8Cae7D942340FF628F82735b7a20893a
200 gwei Key Hash | 0x8077df514608a09f83e4e8d300645594e5d7234665448ba83f51a50f842bd3d9
500 gwei Key Hash | 0x3fd2fec10d06ee8f65e7f2e95f5c56511359ece3f33960ad8a866ae24a8ff10b
1000 gwei Key Hash | 0xc6bf2e7b88e5cfbb4946ff23af846494ae1f3c65270b79ee7876c9aa99d3d45f
Premium percentage  (paying with ETH) | 24
Premium percentage  (paying with LINK) | 20
Max Gas Limit | 2,500,000
Minimum Confirmations | 3
Maximum Confirmations | 200
Maximum Random Values | 500

Item | Value
--- | ---
LINK Token | 0x514910771AF9Ca656af840dff83E8264EcF986CA
VRF Wrapper | 0x02aae1A04f9828517b3007f83f6181900CaD910c
VRF Coordinator | 0xD7f86b4b8Cae7D942340FF628F82735b7a20893a
200 gwei Key Hash | 0x8077df514608a09f83e4e8d300645594e5d7234665448ba83f51a50f842bd3d9
500 gwei Key Hash | 0x3fd2fec10d06ee8f65e7f2e95f5c56511359ece3f33960ad8a866ae24a8ff10b
1000 gwei Key Hash | 0xc6bf2e7b88e5cfbb4946ff23af846494ae1f3c65270b79ee7876c9aa99d3d45f
Premium percentage  (paying with ETH) | 24
Premium percentage  (paying with LINK) | 20
Minimum Confirmations | 3
Maximum Confirmations | 200
Maximum Random Values | 10
Wrapper Gas overhead | 13400
Coordinator Gas Overhead (Native) | 90000
Coordinator Gas Overhead (LINK) | 112000
Coordinator Gas Overhead per Word | 435

### Ethereum Sepolia Testnet
Testnet LINK and ETH are available from faucets.chain.link.

Testnet ETH is also available from several public ETH faucets.

SubscriptionDirect funding
Item | Value
--- | ---
LINK Token | 0x779877A7B0D9E8603169DdbD7836e478b4624789
VRF Coordinator | 0x9DdfaCa8183c41ad55329BdeeD9F6A8d53168B1B
500 gwei Key Hash | 0x787d74caea10b2b357790d5b5247c2f63d1d91572a9846f780606e4d953677ae
Premium percentage  (paying with Sepolia ETH) | 24
Premium percentage  (paying with testnet LINK) | 20
Max Gas Limit | 2,500,000
Minimum Confirmations | 3
Maximum Confirmations | 200
Maximum Random Values | 500

Item | Value
--- | ---
LINK Token | 0x779877A7B0D9E8603169DdbD7836e478b4624789
VRF Wrapper | 0x195f15F2d49d693cE265b4fB0fdDbE15b1850Cc1
VRF Coordinator | 0x9DdfaCa8183c41ad55329BdeeD9F6A8d53168B1B
500 gwei Key Hash | 0x787d74caea10b2b357790d5b5247c2f63d1d91572a9846f780606e4d953677ae
Premium percentage  (paying with Sepolia ETH) | 24
Premium percentage  (paying with testnet LINK) | 20
Minimum Confirmations | 3
Maximum Confirmations | 200
Maximum Random Values | 10
Wrapper Gas overhead | 13400
Coordinator Gas Overhead (Native) | 90000
Coordinator Gas Overhead (LINK) | 112000
Coordinator Gas Overhead per Word | 435

## OP

### OP Mainnet
SubscriptionDirect funding
Item | Value
--- | ---
LINK Token | 0x350a791bfc2c21f9ed5d10980dad2e2638ffa7f6
VRF Coordinator | 0x5FE58960F730153eb5A84a47C51BD4E58302E1c8
2 gwei Key Hash | 0xa16a2316f92fa0abfd0029eea74e947d0613728e934d9794cd78bc02e2f69de4
30 gwei Key Hash | 0x8e7a847ba0757d1c302a3f0fde7b868ef8cf4acc32e48505f1a1d53693a10a19
Premium percentage  (paying with OP Mainnet) | 60
Premium percentage  (paying with LINK) | 50
Max Gas Limit | 2,500,000
Minimum Confirmations | 0
Maximum Confirmations | 200
Maximum Random Values | 500

Item | Value
--- | ---
LINK Token | 0x350a791bfc2c21f9ed5d10980dad2e2638ffa7f6
VRF Wrapper | 0x6A39cE9604FAD060B32bc35BE2e0D3825B2b8D4B
VRF Coordinator | 0x5FE58960F730153eb5A84a47C51BD4E58302E1c8
2 gwei Key Hash | 0xa16a2316f92fa0abfd0029eea74e947d0613728e934d9794cd78bc02e2f69de4
30 gwei Key Hash | 0x8e7a847ba0757d1c302a3f0fde7b868ef8cf4acc32e48505f1a1d53693a10a19
Premium percentage  (paying with OP Mainnet) | 60
Premium percentage  (paying with LINK) | 50
Minimum Confirmations | 0
Maximum Confirmations | 200
Maximum Random Values | 10
Wrapper Gas overhead | 13400
Coordinator Gas Overhead (Native) | 128500
Coordinator Gas Overhead (LINK) | 150400
Coordinator Gas Overhead per Word | 435

### OP Sepolia Testnet
SubscriptionDirect funding
Item | Value
--- | ---
LINK Token | 0xE4aB69C077896252FAFBD49EFD26B5D171A32410
VRF Coordinator | 0x02667f44a6a44E4BDddCF80e724512Ad3426B17d
30 gwei Key Hash | 0xc3d5bc4d5600fa71f7a50b9ad841f14f24f9ca4236fd00bdb5fda56b052b28a4
Premium percentage  (paying with OP Sepolia ETH) | 60
Premium percentage  (paying with LINK) | 50
Max Gas Limit | 2,500,000
Minimum Confirmations | 0
Maximum Confirmations | 200
Maximum Random Values | 500

Item | Value
--- | ---
LINK Token | 0xE4aB69C077896252FAFBD49EFD26B5D171A32410
VRF Wrapper | 0xA8A278BF534BCa72eFd6e6C9ac573E98c21A6171
VRF Coordinator | 0x02667f44a6a44E4BDddCF80e724512Ad3426B17d
30 gwei Key Hash | 0xc3d5bc4d5600fa71f7a50b9ad841f14f24f9ca4236fd00bdb5fda56b052b28a4
Premium percentage  (paying with OP Sepolia ETH) | 60
Premium percentage  (paying with testnet LINK) | 50
Minimum Confirmations | 0
Maximum Confirmations | 200
Maximum Random Values | 10
Wrapper Gas overhead | 13400
Coordinator Gas Overhead (Native) | 128500
Coordinator Gas Overhead (LINK) | 150400
Coordinator Gas Overhead per Word | 435

## Polygon

### Polygon Mainnet
The LINK provided by the Polygon Bridge is not ERC-677 compatible,
so cannot be used with Chainlink oracles. However, it can be converted to the official LINK token on Polygon using
Chainlink's PegSwap service

SubscriptionDirect funding
Item | Value
--- | ---
LINK Token | 0xb0897686c545045aFc77CF20eC7A532E3120E0F1
VRF Coordinator | 0xec0Ed46f36576541C75739E915ADbCb3DE24bD77
200 gwei Key Hash | 0x0ffbbd0c1c18c0263dd778dadd1d64240d7bc338d95fec1cf0473928ca7eaf9e
500 gwei Key Hash | 0x719ed7d7664abc3001c18aac8130a2265e1e70b7e036ae20f3ca8b92b3154d86
1000 gwei Key Hash | 0x192234a5cda4cc07c0b66dfbcfbb785341cc790edc50032e842667dbb506cada
Premium percentage  (paying with POL) | 84
Premium percentage  (paying with LINK) | 70
Max Gas Limit | 2,500,000
Minimum Confirmations | 3
Maximum Confirmations | 200
Maximum Random Values | 500

Item | Value
--- | ---
LINK Token | 0xb0897686c545045aFc77CF20eC7A532E3120E0F1
VRF Wrapper | 0xc8F13422c49909F4Ec24BF65EDFBEbe410BB9D7c
VRF Coordinator | 0xec0Ed46f36576541C75739E915ADbCb3DE24bD77
200 gwei Key Hash | 0x0ffbbd0c1c18c0263dd778dadd1d64240d7bc338d95fec1cf0473928ca7eaf9e
500 gwei Key Hash | 0x719ed7d7664abc3001c18aac8130a2265e1e70b7e036ae20f3ca8b92b3154d86
1000 gwei Key Hash | 0x192234a5cda4cc07c0b66dfbcfbb785341cc790edc50032e842667dbb506cada
Premium percentage  (paying with POL) | 84
Premium percentage  (paying with LINK) | 70
Minimum Confirmations | 3
Maximum Confirmations | 200
Maximum Random Values | 10
Wrapper Gas overhead | 13400
Coordinator Gas Overhead (Native) | 99500
Coordinator Gas Overhead (LINK) | 121500
Coordinator Gas Overhead per Word | 435

### Polygon Amoy Testnet
SubscriptionDirect funding
Item | Value
--- | ---
LINK Token | 0x0fd9e8d3af1aaee056eb9e802c3a762a667b1904
VRF Coordinator | 0x343300b5d84D444B2ADc9116FEF1bED02BE49Cf2
500 gwei Key Hash | 0x816bedba8a50b294e5cbd47842baf240c2385f2eaf719edbd4f250a137a8c899
Premium percentage  (paying with testnet POL) | 84
Premium percentage  (paying with testnet LINK) | 70
Max Gas Limit | 2,500,000
Minimum Confirmations | 3
Maximum Confirmations | 200
Maximum Random Values | 500

Item | Value
--- | ---
LINK Token | 0x0fd9e8d3af1aaee056eb9e802c3a762a667b1904
VRF Wrapper | 0x6e6c366a1cd1F92ba87Fd6f96F743B0e6c967Bf0
VRF Coordinator | 0x343300b5d84D444B2ADc9116FEF1bED02BE49Cf2
500 gwei Key Hash | 0x816bedba8a50b294e5cbd47842baf240c2385f2eaf719edbd4f250a137a8c899
Premium percentage  (paying with testnet POL) | 84
Premium percentage  (paying with testnet LINK) | 70
Minimum Confirmations | 3
Maximum Confirmations | 200
Maximum Random Values | 10
Wrapper Gas overhead | 13400
Coordinator Gas Overhead (Native) | 99500
Coordinator Gas Overhead (LINK) | 121500
Coordinator Gas Overhead per Word | 435

## Ronin

### Ronin Mainnet
SubscriptionDirect funding
Item | Value
--- | ---
LINK Token | 0x3902228D6A3d2Dc44731fD9d45FeE6a61c722D0b
VRF Coordinator | 0xa18FD3db9B869AD2A8c55267e0D54dbf6ECEbEda
50 gwei Key Hash | 0x1aefc70f3533a251306d6b85a6b336ba0ae2e384226274b236f42c3d5366dbbd
200 gwei Key Hash | 0x01753ec79fbf37f6332977d62f25c6d701b11bac255d7e79674fd2886622b0cc
1000 gwei Key Hash | 0xdb64d2a17ee501f6c6a8c090e058dfa39ea79d5fd121185bb903f5a69b8038a3
Premium percentage  (paying with testnet ETH) | 60
Premium percentage  (paying with LINK) | 50
Max Gas Limit | 2,500,000
Minimum Confirmations | 3
Maximum Confirmations | 200
Maximum Random Values | 500

Item | Value
--- | ---
LINK Token | 0x3902228D6A3d2Dc44731fD9d45FeE6a61c722D0b
VRF Wrapper | 0x3B7d0d0CeC08eBF8dad58aCCa4719791378b2329
VRF Coordinator | 0xa18FD3db9B869AD2A8c55267e0D54dbf6ECEbEda
50 gwei Key Hash | 0x1aefc70f3533a251306d6b85a6b336ba0ae2e384226274b236f42c3d5366dbbd
200 gwei Key Hash | 0x01753ec79fbf37f6332977d62f25c6d701b11bac255d7e79674fd2886622b0cc
1000 gwei Key Hash | 0xdb64d2a17ee501f6c6a8c090e058dfa39ea79d5fd121185bb903f5a69b8038a3
Premium percentage  (paying with ETH) | 60
Premium percentage  (paying with LINK) | 50
Minimum Confirmations | 3
Maximum Confirmations | 200
Maximum Random Values | 10
Wrapper Gas overhead | 13400
Coordinator Gas Overhead (Native) | 99500
Coordinator Gas Overhead (LINK) | 121500
Coordinator Gas Overhead per Word | 435

### Ronin Saigon Testnet
SubscriptionDirect funding
Item | Value
--- | ---
LINK Token | 0x5bB50A6888ee6a67E22afFDFD9513be7740F1c15
VRF Coordinator | 0xc052324E6A27D0E4b2CbF0FdFFBCb3796ea8f8B8
200 gwei Key Hash | 0x0a79a60cc054d8da06a5050a1d07f0fec08088ca64192cf67477f8cc3e549f71
Premium percentage  (paying with testnet ETH) | 60
Premium percentage  (paying with LINK) | 50
Max Gas Limit | 2,500,000
Minimum Confirmations | 3
Maximum Confirmations | 200
Maximum Random Values | 500

Item | Value
--- | ---
LINK Token | 0x5bB50A6888ee6a67E22afFDFD9513be7740F1c15
VRF Wrapper | 0x4664273cf5Eb350c864c2F37F63b045a883F93C6
VRF Coordinator | 0xc052324E6A27D0E4b2CbF0FdFFBCb3796ea8f8B8
200 gwei Key Hash | 0x0a79a60cc054d8da06a5050a1d07f0fec08088ca64192cf67477f8cc3e549f71
Premium percentage  (paying with testnet ETH) | 60
Premium percentage  (paying with LINK) | 50
Minimum Confirmations | 3
Maximum Confirmations | 200
Maximum Random Values | 10
Wrapper Gas overhead | 13400
Coordinator Gas Overhead (Native) | 99500
Coordinator Gas Overhead (LINK) | 121500
Coordinator Gas Overhead per Word | 435

## Soneium

### Soneium Mainnet
SubscriptionDirect funding
Item | Value
--- | ---
LINK Token | 0x32D8F819C8080ae44375F8d383Ffd39FC642f3Ec
VRF Coordinator | 0xb89BB0aB64b219Ba7702f862020d879786a2BC49
2 gwei Key Hash | 0x508b86c17b9abbdef2b903bd4f1b03ae321d7c1431b9ccac97d5927b4619e050
30 gwei Key Hash | 0x7611210a5ac0abd39b581bd4ce1108aa0b9e63994daa32cc7302d98ed47747c1
Premium percentage  (paying with testnet ETH) | 60
Premium percentage  (paying with LINK) | 50
Max Gas Limit | 2,500,000
Minimum Confirmations | 0
Maximum Confirmations | 200
Maximum Random Values | 500

Item | Value
--- | ---
LINK Token | 0x32D8F819C8080ae44375F8d383Ffd39FC642f3Ec
VRF Wrapper | 0x656155C8bD09d1741385C525010590522758345c
VRF Coordinator | 0xb89BB0aB64b219Ba7702f862020d879786a2BC49
2 gwei Key Hash | 0x508b86c17b9abbdef2b903bd4f1b03ae321d7c1431b9ccac97d5927b4619e050
30 gwei Key Hash | 0x7611210a5ac0abd39b581bd4ce1108aa0b9e63994daa32cc7302d98ed47747c1
Premium percentage  (paying with ETH) | 60
Premium percentage  (paying with LINK) | 50
Minimum Confirmations | 0
Maximum Confirmations | 200
Maximum Random Values | 10
Wrapper Gas overhead | 13400
Coordinator Gas Overhead (Native) | 128500
Coordinator Gas Overhead (LINK) | 150400
Coordinator Gas Overhead per Word | 435

### Soneium Minato Testnet
SubscriptionDirect funding
Item | Value
--- | ---
LINK Token | 0x7ea13478Ea3961A0e8b538cb05a9DF0477c79Cd2
VRF Coordinator | 0x3Fa01AB73beB4EA09e78FC0849FCe31d0b035b47
30 gwei Key Hash | 0x0c970a50393bea0011d5cec18c15c80c6deb37888b9ff579f476b3e52f6d3922
Premium percentage  (paying with testnet ETH) | 60
Premium percentage  (paying with LINK) | 50
Max Gas Limit | 2,500,000
Minimum Confirmations | 0
Maximum Confirmations | 200
Maximum Random Values | 500

Item | Value
--- | ---
LINK Token | 0x7ea13478Ea3961A0e8b538cb05a9DF0477c79Cd2
VRF Wrapper | 0xB64019F234f2A4951261B111C6B43eb0d8f33b76
VRF Coordinator | 0x3Fa01AB73beB4EA09e78FC0849FCe31d0b035b47
30 gwei Key Hash | 0x0c970a50393bea0011d5cec18c15c80c6deb37888b9ff579f476b3e52f6d3922
Premium percentage  (paying with testnet ETH) | 60
Premium percentage  (paying with LINK) | 50
Minimum Confirmations | 0
Maximum Confirmations | 200
Maximum Random Values | 10
Wrapper Gas overhead | 13400
Coordinator Gas Overhead (Native) | 128500
Coordinator Gas Overhead (LINK) | 150400
Coordinator Gas Overhead per Word | 435

================================================================================

# Decentralized Data Model

Source: https://docs.chain.link/architecture-overview/architecture-decentralized-model
Extraction Method: playwright
Components: code_block(1)

# Decentralized Data Model
This page describes how data aggregation is applied to produce Chainlink Data Feeds and provides more insight as to how Data Feeds are updated.

## Data aggregation
Each data feed is updated by multiple, independent Chainlink oracle operators. The AccessControlledOffchainAggregator aggregates the data onchain.

Offchain Reporting (OCR) further enhances the aggregation process. To learn more about OCR and how it works, see the Offchain Reporting page.

astro-island,astro-slot,astro-static-slot{display:contents}(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).only=e;window.dispatchEvent(new Event("astro:only"));})();(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();
## Shared data resource
Each data feed is built and funded by the community of users who rely on accurate, up-to-date data in their smart contracts. As more users rely on and contribute to a data feed, the quality of the data feed improves. For this reason, each data feed has its own properties depending on the needs of its community of users.

## Decentralized Oracle Network
Each data feed is updated by a decentralized oracle network. Each oracle operator is rewarded for publishing data. The number of oracles contributing to each feed varies. In order for an update to take place, the data feed aggregator contract must receive responses from a minimum number of oracles or the latest answer will not be updated. You can see the minimum number of oracles for the corresponding feed at data.chain.link.

Each oracle in the set publishes data during an aggregation round. That data is validated and aggregated by a smart contract, which forms the feed's latest and trusted answer.

## Components of a Decentralized Oracle Network
Data Feeds are an example of a decentralized oracle network, and include the following components:

• A consumer contract
• A proxy contract
• An aggregator contract

To learn how to create a consumer contract that uses an existing data feed, read the Using Data Feeds documentation.

### Consumer
A Consumer contract is any contract that uses Chainlink Data Feeds to consume aggregated data. Consumer contracts must reference the correct AggregatorV3Interface contract and call one of the exposed functions.

[Image: copy to clipboard]
```solidity
...
AggregatorV3Interface feed = AggregatorV3Interface(address);
return feed.latestRoundData();
```

Offchain applications can also consume data feeds. See the Javascript and Python example code on the Using Data Feeds page to learn more.

### Proxy
Proxy contracts are onchain proxies that point to the aggregator for a particular data feed. Using proxies enables the underlying aggregator to be upgraded without any service interruption to consuming contracts.

Proxy contracts can vary from one data feed to another, but the EACAggregatorProxy.sol contract on Github is a common example.

### Aggregator
An aggregator is the contract that receives periodic data updates from the oracle network. Aggregators store aggregated data onchain so that consumers can retrieve it and act upon it within the same transaction.

You can access this data using the Data Feed address and the AggregatorV3Interface contract.

Aggregators receive updates from the oracle network only when the Deviation Threshold or Heartbeat Threshold triggers an update during an aggregation round. The first condition that is met triggers an update to the data.

• Deviation Threshold: A new aggregation round starts when a node identifies that the off-chain values deviate by more than the defined deviation threshold from the onchain value. Individual nodes monitor one or more data providers for each feed.
• Heartbeat Threshold: A new aggregation round starts after a specified amount of time from the last update.

================================================================================

# Data Feeds Architecture

Source: https://docs.chain.link/architecture-overview/architecture-overview
Extraction Method: playwright

# Data Feeds Architecture

## Basic request model
Chainlink connects smart contracts with external data using its decentralized oracle network. Chainlink API requests are handled 1:1 by an oracle.

The Basic Request Model describes the onchain architecture of requesting data from a single oracle source.

To learn how to make a GET request using a single oracle, see Make a GET Request.

## Decentralized data model
For a more robust and trustworthy answer, you can aggregate data from many oracles. With onchain aggregation, data is aggregated from a decentralized network of independent oracle nodes. This architecture is applied to Chainlink Data Feeds, which can aggregate data such as asset price data.

The Decentralized Data Model describes how data is aggregated, and how consumer contracts can retrieve this data.

## Offchain reporting
Offchain Reporting (OCR) is an improvement on the decentralization and scalability of Chainlink networks. With our Offchain Reporting aggregators, all nodes communicate using a peer to peer network. During the communication process, a lightweight consensus algorithm runs where each node reports its price observation and signs it. A single aggregate transaction is then transmitted, which saves a significant amount of gas.

To learn more about OCR and how it works, see the Offchain Reporting page.

================================================================================

# Basic Request Model

Source: https://docs.chain.link/architecture-overview/architecture-request-model
Extraction Method: playwright

# Basic Request Model

## Contracts overview
All source code is open source and available in the Chainlink Github repository.

astro-island,astro-slot,astro-static-slot{display:contents}(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).only=e;window.dispatchEvent(new Event("astro:only"));})();(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();
### ChainlinkClient
ChainlinkClient is a parent contract that enables smart contracts to consume data from oracles. It's available in the Chainlink smart contract library which can be installed using the latest package managers.

The client constructs and makes a request to a known Chainlink oracle through the transferAndCall function, implemented by the LINK token. This request contains encoded information that is required for the cycle to succeed. In the ChainlinkClient contract, this call is initiated with a call to sendChainlinkRequestTo.

To build your own client contract using ChainlinkClient, see Introduction to Using Any API, or view the ChainlinkClient API Reference for the ChainlinkClient contract.

### LINK Token
LINK is an ERC-677 compliant token which implements transferAndCall, a function that allows tokens to be transferred whilst also triggering logic in the receiving contract within a single transaction.

Learn more about ERC-677 and the LINK token.

### Operator Contract
Operator contracts are owned by oracle node operators, which run alongside offchain oracle nodes.

#### Request
The client contract that initiates this cycle must create a request with the following items:

• The oracle address.
• The job ID, so the oracle knows which tasks to perform.
• The callback function, which the oracle sends the response to.

To learn about how to find oracles to suit your needs, see Find Existing Jobs.

Operator contracts are responsible for handling onchain requests made through the LINK token, by implementing onTokenTransfer as a LinkTokenReceiver. Upon execution of this function, the operator contract emits an OracleRequest event containing information about the request. This event is crucial, as it is monitored by the offchain oracle node which acts upon it.

#### Fulfillment
For fulfillment, the operator contract has a fulfillOracleRequest function which is used by the node to fulfill a request once it has the result of the job. This function returns the result to the ChainlinkClient using the callback function defined in the original request.

### Offchain oracle node
The offchain oracle node is responsible for listening for events emitted by its corresponding onchain smart contract. Once it detects an OracleRequest event, it uses the data emitted to perform a job.

The most common job type for a Node is to make a GET request to an API, retrieve some data from it, parse the response, convert the result into blockchain compatible data, then submit it in a transaction back to the operator contract, using the fulfillOracleRequest function.

For more information on how to become a node operator, learn how to run a Chainlink node.

## Consumer UML
Below is a UML diagram describing the contract structure of ATestnetConsumer, a deployed example contract implementing ChainlinkClient.

================================================================================

# Offchain Reporting

Source: https://docs.chain.link/architecture-overview/off-chain-reporting
Extraction Method: playwright

# Offchain Reporting
Offchain Reporting (OCR) is a significant step towards increasing the decentralization and scalability of Chainlink networks. See the OCR Protocol Paper for a technical deep dive.

For Offchain Reporting aggregators, all nodes communicate using a peer to peer network. During the communication process, a lightweight consensus algorithm runs where each node reports its data observation and signs it. A single aggregate transaction is then transmitted, which saves a significant amount of gas.

The report contained in the aggregate transaction is signed by a quorum of oracles and contains all oracles' observations. By validating the report onchain and checking the quorum's signatures onchain, we preserve the trustlessness properties of Chainlink oracle networks.

## What is OCR?
[Image: note]A simple analogy

Imagine ordering 10 items from an online store. Each item is packaged separately and posted separately, meaning
postage and packaging costs must be applied to each one, and the carrier has to transport 10 different boxes.

OCR, on the other hand, packages all of these items into a single box and posts that. This saves postage and packaging
fees and all effort the carrier associates with transporting 9 fewer boxes.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }The OCR protocol allows nodes to aggregate their observations into a single report offchain using a secure P2P network. A single node then submits a transaction with the aggregated report to the chain. Each report consists of many nodes' observations and has to be signed by a quorum of nodes. These signatures are verified onchain.

Submitting only one transaction per round achieves the following benefits:

• Overall network congestion from Chainlink oracle networks is reduced dramatically
• Individual node operators spend far less on gas costs
• Node networks are more scalable because data feeds can accommodate more nodes
• Data feeds can be updated in a more timely manner since each round needn't wait for multiple transactions to be confirmed before a price is confirmed onchain.

## How does OCR work?
Protocol execution happens mostly offchain over a peer to peer network between Chainlink nodes. The nodes regularly elect a new leader node that drives the rest of the protocol.

The leader regularly requests followers to provide freshly signed observations and aggregates them into a report. It then sends this report back to the followers and asks them to verify the report's validity. If a quorum of followers approves the report by sending a signed copy back to the leader, the leader assembles a final report with the quorum's signatures and broadcasts it to all followers.

The nodes attempt to transmit the final report to the aggregator contract according to a randomized schedule. The aggregator verifies that a quorum of nodes signed the report and exposes the median value to consumers as an answer with a block timestamp and a round ID.

All nodes watch the blockchain for the final report to remove any single point of failure during transmission. If the designated node fails to get their transmission confirmed within a determined period, a round-robin protocol kicks in so other nodes can also transmit the final report until one of them is confirmed.

================================================================================

# Chainlink Nodes

Source: https://docs.chain.link/chainlink-nodes
Extraction Method: playwright

# Chainlink Nodes
Operating a Chainlink node allows you to be part of the Chainlink Network, helping developers build hybrid smart
    contracts, giving them access to real-world data and services. Learn more about Chainlink nodes with our
    step-by-step tutorials and documentation:

### Set Up a Chainlink Node
Install and Run your own node on a local machine or remote server.

[Learn More](/chainlink-nodes/v1/running-a-chainlink-node)
### Fulfill Your First Job Request
Deploy an Oracle contract and make job requests to your node.

[Learn More](/chainlink-nodes/v1/fulfilling-requests)
### Add External Adapters to Your Node
Bring high-quality data and premium web APIs to contract developers.

[Learn More](/chainlink-nodes/external-adapters/node-operators)
## New to Chainlink and Smart Contracts?
Learn the basics in the Getting Started Guide. Build your first smart contract on Ethereum.

[Getting Started Guide](/getting-started/conceptual-overview)

================================================================================

# Configuring Nodes

Source: https://docs.chain.link/chainlink-nodes/configuring-nodes
Extraction Method: playwright
Components: code_block(14)

# Configuring Nodes
Starting with Chainlink v2.0.0, TOML configuration is the only supported configuration method. You can switch to TOML format using the Chainlink v1.13.0 image. After your Chainlink node is running stable on v1.13.0, you can continue to use the TOML config on future images where support for .env configs are no longer supported.

You can see the available config options on the Node Config and Node Secrets pages.

## Migrating from environment variables to TOML
Before you begin, update your Chainlink Node to v1.13.0 and ensure that it operates as expected. This is the last version that supports environment variable configuration, and the best version to use for TOML migration before you update the node to future versions.

### Export your current config
You can generate the config.toml file using the chainlink config dump command. This guide shows you how to do this for a Chainlink node running in a Docker container:

1. Open an interactive shell inside the Docker container that runs your node:
docker exec -it chainlink bash
2. Log in to the Chainlink CLI with an account that has admin access:
chainlink admin login
3. Export the current config to a config.toml file:
chainlink config dump > config.toml
4. Log out of the Chainlink CLI and close the shell on the Docker container.
chainlink admin logout && exit
5. Change to the directory where your .env file is located. This is the directory that you mount to Docker when you run the node. You will create your config.toml and secrets.toml files here so Docker can provide them to your node container.
cd ~/.chainlink
6. Write the config file from the container to your host:
docker exec -it chainlink cat /home/chainlink/config.toml > ./config.toml
7. Create a secrets.toml file with the minimum required secrets, which are [Database] and [Password].
If you are working on a test node, you can use ?sslmode=disable in the database URL. You might also need AllowSimplePasswords = true in the [Database] section so you can start the node, but you should make the database password sufficiently complex as a best practice:
echo "[Database]
URL = 'postgresql://user:pass@localhost:5432/dbname'

[Password]
Keystore = 'keystore_pass'" > ./secrets.toml
8. Edit the secrets.toml file to include the secrets you need for your specific Chainlink node. See the Node Secrets page for a full list of available options.

### Validate the configuration
After you have the config.toml file and the secrets.toml files on the host system, you can validate these files using a temporary Docker container.

1. Validate the configuration by running the config validate command in the Docker container. This command changes to node validate when you upgrade your node to version 2.0.0 or later.
docker run --platform linux/x86_64/v8 --name chainlink-config-validator -v ~/.chainlink:/chainlink -it --rm smartcontract/chainlink:1.13.0 -config /chainlink/config.toml -secrets /chainlink/secrets.toml config validate

You will likely see some invalid config errors. For example:
Invalid configuration: EVM.3.Nodes: missing: must have at least one node
2. Edit the config.toml and secrets.toml files to manually correct any errors. See the Node Config and Node Secrets pages to learn which settings are valid. For the error in this example, an EVM chain was configured with no nodes. Removing this from the config made the config valid:
[[EVM]]
ChainID = '421613'
Enabled = false
Nodes = []
3. Run the config validate command again and make additional changes until you have a valid config message:
Valid configuration.

### Restart your Chainlink node using the TOML config
With your valid config and secrets files, you can migrate your Chainlink node to use the new config.

1. Stop your existing Chainlink node:
docker stop chainlink
2. Make a Postgres database snapshot so you can restore your previous Chainlink node if necessary.
3. Start a new Chainlink node Docker container named using the new config.toml and secrets.toml files. This example uses chainlink-toml as the container name:
docker run --platform linux/x86_64/v8 --name chainlink-toml  -v ~/.chainlink:/chainlink -it -p 6688:6688 --add-host=host.docker.internal:host-gateway smartcontract/chainlink:1.13.0 -config /chainlink/config.toml -secrets /chainlink/secrets.toml node start

Test your node to verify that it works as intended. If you are using a VPS, open an SSH tunnel using ssh -i $KEY $USER@$REMOTE-IP -L 6688:localhost:6688 -N. Connect to the Operator UI in your browser at localhost:6688.

## Using multiple config files
You can use multiple config and secrets files. The config settings from each file are applied in the order that you specify when you run your node. Duplicated fields override values specified in earlier config files. This allows you to create a common config that applies to many nodes with specific configs for nodes that need unique configuration settings. Specifying multiple secrets files is invalid.

To specify multiple config files, add additional -config flags to the docker run command:

[Image: copy to clipboard]
```shell
docker run --platform linux/x86_64/v8 --name chainlink -v ~/.chainlink:/chainlink -it -p 6688:6688 --add-host=host.docker.internal:host-gateway smartcontract/chainlink:1.13.0 -config /chainlink/config.toml -config /chainlink/config2.toml -config /chainlink/config3.toml -secrets /chainlink/secrets.toml node start
```

================================================================================

# Job Types

Source: https://docs.chain.link/chainlink-nodes/oracle-jobs/all-jobs
Extraction Method: playwright
Components: code_block(7)

# Job Types
This guide outlines different job types.

## Solidity cron jobs
[Image: note]Chainlink Job Scheduler

If you need to schedule a contract function call, use the Chainlink Job
Scheduler. The Job Scheduler uses the Chainlink
Automation network to execute deployed contract calls on a cron schedule that you define, such
as an Ethereum cron job for your dApp.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }Executes a job on a schedule. Does not rely on any kind of external trigger.

### Spec format
[Image: copy to clipboard]
```toml
type            = "cron"
schemaVersion   = 1
evmChainID      = 1
schedule        = "CRON_TZ=UTC * */20 * * * *"
externalJobID       = "0EEC7E1D-D0D2-476C-A1A8-72DFB6633F01"
observationSource   = """
    fetch    [type="http" method=GET url="https://chain.link/ETH-USD"]
    parse    [type="jsonparse" path="data,price"]
    multiply [type="multiply" times=100]

    fetch -> parse -> multiply
"""
```

### Shared fields
See shared fields.

### Unique fields

• schedule: the frequency with which the job is to be run. There are two ways to specify this:

Traditional UNIX cron format, but with 6 fields, not 5. The extra field allows for "seconds" granularity. Note: you must specify the CRON_TZ=... parameter if you use this format.
@ shorthand, e.g. @every 1h. This shorthand does not take account of the node's timezone, rather, it simply begins counting down the moment that the job is added to the node (or the node is rebooted). As such, no CRON_TZ parameter is needed.

For all supported schedules, please refer to the cron library documentation.

### Job type specific pipeline variables

• $(jobSpec.databaseID): the ID of the job spec in the local database. You shouldn't need this in 99% of cases.
• $(jobSpec.externalJobID): the globally-unique job ID for this job. Used to coordinate between node operators in certain cases.
• $(jobSpec.name): the local name of the job.
• $(jobRun.meta): a map of metadata that can be sent to a bridge, etc.

## Direct request jobs
Executes a job upon receipt of an explicit request made by a user. The request is detected via a log emitted by an Oracle or Operator contract. This is similar to the legacy ethlog/runlog style of jobs.

### Spec format
[Image: copy to clipboard]
```toml
type                = "directrequest"
schemaVersion       = 1
evmChainID          = 1
name                = "example eth request event spec"
contractAddress     = "0x613a38AC1659769640aaE063C651F48E0250454C"

# Optional fields:
# requesters        = [
#   "0xAaAA1F8ee20f5565510b84f9353F1E333e753B7a",
#   "0xBbBb70f0E81c6F3430dfDc9fa02fB22bDD818c4E"
# ]
# minContractPaymentLinkJuels = "100000000000000"
# externalJobID = "0EEC7E1D-D0D2-476C-A1A8-72DFB6633F02"
# minIncomingConfirmations = 10

observationSource   = """
    ds          [type="http" method=GET url="http://example.com"]
    ds_parse    [type="jsonparse" path="USD"]
    ds_multiply [type="multiply" times=100]

    ds -> ds_parse -> ds_multiply
"""
```

#### Shared fields
See shared fields.

#### Unique fields

• contractAddress: The Oracle or Operator contract to monitor for requests
• requesters: Optional - Allows whitelisting requesters
• minContractPaymentLinkJuels Optional - Allows you to specify a job-specific minimum contract payment
• minIncomingConfirmations Optional - Allows you to specify a job-specific MIN_INCOMING_CONFIRMATIONS value, must be greater than global MIN_INCOMING_CONFIRMATIONS

#### Job type specific pipeline variables

• $(jobSpec.databaseID): the ID of the job spec in the local database. You shouldn't need this in 99% of cases.
• $(jobSpec.externalJobID): the globally-unique job ID for this job. Used to coordinate between node operators in certain cases.
• $(jobSpec.name): the local name of the job.
• $(jobRun.meta): a map of metadata that can be sent to a bridge, etc.
• $(jobRun.logBlockHash): the block hash in which the initiating log was received.
• $(jobRun.logBlockNumber): the block number in which the initiating log was received.
• $(jobRun.logTxHash): the transaction hash that generated the initiating log.
• $(jobRun.logAddress): the address of the contract to which the initiating transaction was sent.
• $(jobRun.logTopics): the log's topics (indexed fields).
• $(jobRun.logData): the log's data (non-indexed fields).
• $(jobRun.blockReceiptsRoot) : the root of the receipts trie of the block (hash).
• $(jobRun.blockTransactionsRoot) : the root of the transaction trie of the block (hash).
• $(jobRun.blockStateRoot) : the root of the final state trie of the block (hash).

### Examples

#### Get > Uint256 job
Let's assume that a user makes a request to an oracle to call a public API, retrieve a number from the response, remove any decimals and return uint256.

• The smart contract example can be found here.
• The job spec example can be found here.

#### Get > Int256 job
Let's assume that a user makes a request to an oracle to call a public API, retrieve a number from the response, remove any decimals and return int256.

• The job spec example can be found here.

#### Get > Bool job
Let's assume that a user makes a request to an oracle to call a public API, retrieve a boolean from the response and return bool.

• The job spec example can be found here.

#### Get > String job
Let's assume that a user makes a request to an oracle and would like to fetch a string from the response.

• The smart contract example can be found here.
• The job spec example can be found here.

#### Get > Bytes job
Let's assume that a user makes a request to an oracle and would like to fetch bytes from the response (meaning a response that contains an arbitrary-length raw byte data).

• The smart contract example can be found here.
• The job spec example can be found here.

#### Multi-Word job
Let's assume that a user makes a request to an oracle and would like to fetch multiple words in one single request.

• The smart contract example can be found here.
• The job spec example can be found here.

#### Existing job
Using an existing Oracle Job makes your smart contract code more succinct. Let's assume that a user makes a request to an oracle that leverages Etherscan External Adapter to retrieve the gas price.

• The smart contract example can be found here.
• The job spec example can be found here.

## Flux Monitor Jobs
The Flux Monitor job type is for continually-updating data feeds that aggregate responses from multiple oracles. The oracles servicing the feed submit rounds based on several triggers:

• An occasional poll, which must show that there has been sufficient deviation from an offchain data source before a new result is submitted
• New rounds initiated by other oracles on the feeds. If another oracle notices sufficient deviation, all other oracles will submit their current observations as well.
• A heartbeat, which ensures that even if no deviation occurs, we submit a new result to prove liveness. This can take one of two forms:

The "idle timer", which begins counting down each time a round is started
The "drumbeat", which simply ticks at a steady interval, much like a cron job

### Spec format
[Image: copy to clipboard]
```toml
type              = "fluxmonitor"
schemaVersion     = 1
name              = "example flux monitor spec"
contractAddress   = "0x3cCad4715152693fE3BC4460591e3D3Fbd071b42"
externalJobID     = "0EEC7E1D-D0D2-476C-A1A8-72DFB6633F03"

threshold = 0.5
absoluteThreshold = 0.0 # optional

idleTimerPeriod   = "1s"
idleTimerDisabled = false

pollTimerPeriod   = "1m"
pollTimerDisabled = false

drumbeatEnabled  = true
drumbeatSchedule = "CRON_TZ=UTC * */20 * * * *"

observationSource = """
    // data source 1
    ds1 [type="http" method=GET url="https://pricesource1.com"
         requestData="{\\"coin\\": \\"ETH\\", \\"market\\": \\"USD\\"}"]
    ds1_parse [type="jsonparse" path="data,result"]

    // data source 2
    ds2 [type="http" method=GET url="https://pricesource2.com"
         requestData="{\\"coin\\": \\"ETH\\", \\"market\\": \\"USD\\"}"]
    ds2_parse [type="jsonparse" path="data,result"]

    ds1 -> ds1_parse -> medianized_answer
    ds2 -> ds2_parse -> medianized_answer

    medianized_answer [type=median]
"""
```

### Shared fields
See shared fields.

### Unique fields

• contractAddress: the address of the FluxAggregator contract that manages the feed.
• threshold: the percentage threshold of deviation from the previous onchain answer that must be observed before a new set of observations are submitted to the contract.
• absoluteThreshold: the absolute numerical deviation that must be observed from the previous onchain answer before a new set of observations are submitted to the contract. This is primarily useful with data that can legitimately sometimes hit 0, as it's impossible to calculate a percentage deviation from 0.
• idleTimerPeriod: the amount of time (after the start of the last round) after which a new round will be automatically initiated, regardless of any observed offchain deviation.
• idleTimerDisabled: whether the idle timer is used to trigger new rounds.
• drumbeatEnabled: whether the drumbeat is used to trigger new rounds.
• drumbeatSchedule: the cron schedule of the drumbeat. This field supports the same syntax as the cron job type (see the cron library documentation for details). CRON_TZ is required.
• pollTimerPeriod: the frequency with which the offchain data source is checked for deviation against the previously submitted onchain answer.
• pollTimerDisabled: whether the occasional deviation check is used to trigger new rounds.
• Notes:

For duration parameters, the maximum unit of time is h (hour). Durations of a day or longer must be expressed in hours.
If no time unit is provided, the default unit is nanoseconds, which is almost never what you want.

### Job type specific pipeline variables

• $(jobSpec.databaseID): the ID of the job spec in the local database. You shouldn't need this in 99% of cases.
• $(jobSpec.externalJobID): the globally-unique job ID for this job. Used to coordinate between node operators in certain cases.
• $(jobSpec.name): the local name of the job.
• $(jobRun.meta): a map of metadata that can be sent to a bridge, etc.

## Keeper jobs
Keeper jobs occasionally poll a smart contract method that expresses whether something in the contract is ready for some onchain action to be performed. When it's ready, the job executes that onchain action.

Examples:

• Liquidations
• Rebalancing portfolios
• Rebase token supply adjustments
• Auto-compounding
• Limit orders

### Spec format
[Image: copy to clipboard]
```toml
type            = "keeper"
schemaVersion   = 1
evmChainID      = 1
name            = "example keeper spec"
contractAddress = "0x7b3EC232b08BD7b4b3305BE0C044D907B2DF960B"
fromAddress     = "0xa8037A20989AFcBC51798de9762b351D63ff462e"
```

### Shared fields
See shared fields.

### Unique fields

• evmChainID: The numeric chain ID of the chain on which Chainlink Automation Registry is deployed
• contractAddress: The address of the Chainlink Automation Registry contract to poll and update
• fromAddress: The Oracle node address from which to send updates
• externalJobID: This is an optional field. When omitted it will be generated

## Offchain reporting jobs
Offchain Reporting (OCR) jobs are used very similarly to Flux Monitor jobs. They update data feeds with aggregated data from many Chainlink oracle nodes. However, they do this aggregation using a cryptographically-secure offchain protocol that makes it possible for only a single node to submit all answers from all participating nodes during each round (with proofs that the other nodes' answers were legitimately provided by those nodes), which saves a significant amount of gas.

Offchain reporting jobs require the FEATURE_OFFCHAIN_REPORTING=true environment variable.

### Bootstrap node
Every OCR cluster requires at least one bootstrap node as a kind of "rallying point" that enables the other nodes to find one another. Bootstrap nodes do not participate in the aggregation protocol and do not submit answers to the feed.

#### Spec format
[Image: copy to clipboard]
```toml
type               = "offchainreporting"
schemaVersion      = 1
evmChainID         = 1
contractAddress    = "0x27548a32b9aD5D64c5945EaE9Da5337bc3169D15"
p2pBootstrapPeers  = [
    "/dns4/chain.link/tcp/1234/p2p/16Uiu2HAm58SP7UL8zsnpeuwHfytLocaqgnyaYKP8wu7qRdrixLju",
]
isBootstrapPeer = true
externalJobID   = "0EEC7E1D-D0D2-476C-A1A8-72DFB6633F05"
```

#### Shared fields
See shared fields.

#### Unique fields

• contractAddress: The address of the OffchainReportingAggregator contract.
• evmChainID: The chain ID of the EVM chain in which the job will operate.
• p2pBootstrapPeers: A list of libp2p dial addresses of the other bootstrap nodes helping oracle nodes find one another on the network. It is used with P2P networking stack V1 as follows:
p2pBootstrapPeers = [ "/dns4/HOST_NAME_OR_IP/tcp/PORT/p2p/BOOTSTRAP_NODE'S_P2P_ID" ]
• p2pv2Bootstrappers: A list of libp2p dial addresses of the other bootstrap nodes helping oracle nodes find one another on the network. It is used with P2P networking stack V2 as follows:
p2pv2Bootstrappers = [ "BOOTSTRAP_NODE'S_P2P_ID@HOST_NAME_OR_IP:PORT" ]
• isBootstrapPeer: This must be set to true.

#### Job type specific pipeline variables

• $(jobSpec.databaseID): The ID of the job spec in the local database. You shouldn't need this in 99% of cases.
• $(jobSpec.externalJobID): The globally-unique job ID for this job. Used to coordinate between node operators in certain cases.
• $(jobSpec.name): The local name of the job.
• $(jobRun.meta): A map of metadata that can be sent to a bridge, etc.

### Oracle node
Oracle nodes, on the other hand, are responsible for submitting answers.

### Spec format
[Image: copy to clipboard]
```toml
type               = "offchainreporting"
schemaVersion      = 1
evmChainID         = 1
name               = "OCR: ETH/USD"
contractAddress    = "0x613a38AC1659769640aaE063C651F48E0250454C"
externalJobID      = "0EEC7E1D-D0D2-476C-A1A8-72DFB6633F06"
p2pPeerID          = "12D3KooWApUJaQB2saFjyEUfq6BmysnsSnhLnY5CF9tURYVKgoXK"
p2pBootstrapPeers  = [
    "/dns4/chain.link/tcp/1234/p2p/16Uiu2HAm58SP7UL8zsnpeuwHfytLocaqgnyaYKP8wu7qRdrixLju",
]
isBootstrapPeer    = false
keyBundleID        = "7f993fb701b3410b1f6e8d4d93a7462754d24609b9b31a4fe64a0cb475a4d934"
monitoringEndpoint = "chain.link:4321"
transmitterAddress = "0xF67D0290337bca0847005C7ffD1BC75BA9AAE6e4"
observationTimeout = "10s"
blockchainTimeout  = "20s"
contractConfigTrackerSubscribeInterval = "2m"
contractConfigTrackerPollInterval = "1m"
contractConfigConfirmations = 3
observationSource = """
    // data source 1
    ds1          [type="bridge" name=eth_usd]
    ds1_parse    [type="jsonparse" path="one,two"]
    ds1_multiply [type="multiply" times=100]

    // data source 2
    ds2          [type="http" method=GET url="https://chain.link/eth_usd"
                  requestData="{\\"hi\\": \\"hello\\"}"]
    ds2_parse    [type="jsonparse" path="three,four"]
    ds2_multiply [type="multiply" times=100]

    ds1 -> ds1_parse -> ds1_multiply -> answer
    ds2 -> ds2_parse -> ds2_multiply -> answer

    answer [type=median]
"""
```

#### Shared fields
See shared fields.

#### Unique fields

• contractAddress: The address of the OffchainReportingAggregator contract.
• evmChainID: The chain ID of the EVM chain in which the job will operate.
• p2pPeerID: The base58-encoded libp2p public key of this node.
• p2pBootstrapPeers: A list of libp2p dial addresses of the other bootstrap nodes helping oracle nodes find one another on the network. It is used with P2P networking stack V1 as follows:
p2pBootstrapPeers = [ "/dns4/<host name or ip>/tcp/<port>/p2p/<bootstrap node's P2P ID>" ]
• p2pv2Bootstrappers: A list of libp2p dial addresses of the other bootstrap nodes helping oracle nodes find one another on the network. It is used with P2P networking stack V2 as follows:
p2pv2Bootstrappers = [ "<bootstrap node's P2P ID>@<host name or ip>:<port>" ]
• keyBundleID: The hash of the OCR key bundle to be used by this node. The Chainlink node keystore manages these key bundles. Use the node Key Management UI or the chainlink keys ocr sub-commands in the CLI to create and manage key bundles.
• monitoringEndpoint: The URL of the telemetry endpoint to send OCR metrics to.
• transmitterAddress: The Ethereum address from which to send aggregated submissions to the OCR contract.
• observationTimeout: The maximum duration to wait before an offchain request for data is considered to be failed/unfulfillable.
• blockchainTimeout: The maximum duration to wait before an onchain request for data is considered to be failed/unfulfillable.
• contractConfigTrackerSubscribeInterval: The interval at which to retry subscribing to onchain config changes if a subscription has not yet successfully been made.
• contractConfigTrackerPollInterval: The interval at which to proactively poll the onchain config for changes.
• contractConfigConfirmations: The number of blocks to wait after an onchain config change before considering it worthy of acting upon.

#### Job type specific pipeline variables

• $(jobSpec.databaseID): The ID of the job spec in the local database. You shouldn't need this in 99% of cases.
• $(jobSpec.externalJobID): The globally-unique job ID for this job. Used to coordinate between node operators in certain cases.
• $(jobSpec.name): The local name of the job.
• $(jobRun.meta): A map of metadata that can be sent to a bridge, etc.

## Webhook Jobs
Webhook jobs can be initiated by HTTP request, either by a user or external initiator.

[Image: note]note

You must have ExternalInitiatorsEnabled = true in your config to enable these jobs. See 
ExternalInitiatorsEnabled in the config
reference for details.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }This is an example webhook job:

[Image: copy to clipboard]
```toml
type            = "webhook"
schemaVersion   = 1
externalInitiators = [
  { name = "my-external-initiator-1", spec = "{\"foo\": 42}" },
  { name = "my-external-initiator-2", spec = "{}" }
]
observationSource   = """
    parse_request  [type="jsonparse" path="data,result" data="$(jobRun.requestBody)"]
    multiply       [type="multiply" input="$(parse_request)" times="100"]
    send_to_bridge [type="bridge" name="my_bridge" requestData="{ \\"result\\": $(multiply) }"]

    parse_request -> multiply -> send_to_bridge
"""
```

All webhook jobs can have runs triggered by a logged in user.

Webhook jobs may additionally specify zero or more external initiators, which can also trigger runs for this job. The name must exactly match the name of the referred external initiator. The external initiator definition here must contain a spec which defines the JSON payload that will be sent to the External Initiator on job creation if the external initiator has a URL. If you don't care about the spec, you can simply use the empty JSON object.

### Unique fields

• externalInitiators - an array of {name, spec} objects, where name is the name registered with the node, and spec is the job spec to be forwarded to the external initiator when it is created.

### Shared fields
See shared fields.

### Job type specific pipeline variables

• $(jobSpec.databaseID): the ID of the job spec in the local database. You shouldn't need this in 99% of cases.
• $(jobSpec.externalJobID): the globally-unique job ID for this job. Used to coordinate between node operators in certain cases.
• $(jobSpec.name): the local name of the job.
• $(jobRun.meta): a map of metadata that can be sent to a bridge, etc.
• $(jobRun.requestBody): the body of the request that initiated the job run.

================================================================================

# Task Types

Source: https://docs.chain.link/chainlink-nodes/oracle-jobs/all-tasks
Extraction Method: playwright
Components: code_block(34)

# Task Types
This guide outlines different task types.

## 'Any' task
Returns a random value from the set of inputs passed in.

Parameters

None.

Inputs

Can be anything.

Outputs

A randomly-selected value from the set of inputs.

Example

[Image: copy to clipboard]
```toml
fetch1   [type="http" ...]
fetch2   [type="http" ...]
fetch3   [type="http" ...]
pick_any [type="any"]

fetch1 -> pick_any
fetch2 -> pick_any
fetch3 -> pick_any
```

pick_any will return either the result of fetch1, fetch2, or fetch3.

## Base64 Decode task
Accepts a base64 encoded string and returns decoded bytes.

Parameters

• input: a base64 encoded string.

Outputs

Decoded bytes.

Example

[Image: copy to clipboard]
```toml
my_base64decode_task [type="base64decode" input="SGVsbG8sIHBsYXlncm91bmQ="]
```

Given the input SGVsbG8sIHBsYXlncm91bmQ=, the task will return Hello, playground (as ASCII bytes).

## Base64 Encode task
Encodes bytes/string into a Base64 string.

Parameters

• input: Byte array or string to be encoded.

Outputs

String with Base64 encoding of input.

Example

[Image: copy to clipboard]
```toml
my_base64encode_task [type="base64encode" input="Hello, playground"]
```

Given the input string "Hello, playground", the task will return "SGVsbG8sIHBsYXlncm91bmQ=".

## Bridge task
Bridge tasks make HTTP POST requests to pre-configured URLs. Bridges can be configured via the UI or the CLI, and are referred to by a simple user-specified name. This is the way that most jobs interact with External Adapters.

Parameters

• name: an arbitrary name given to the bridge by the node operator.
• requestData (optional): a statically-defined payload to be sent to the external adapter.
• cacheTTL (optional): a duration-formatted string indicating the maximum acceptable staleness for cached bridge responses in case of intermittent failures. This is disabled by default.
• headers (optional): an array of strings. The number of strings must be even. Example: foo [type="bridge" name="foo" headers="[\\"X-Header-1\\", \\"value1\\", \\"X-Header-2\\", \\"value2\\"]"]

Outputs

A string containing the response body.

Example

[Image: copy to clipboard]
```toml
my_bridge_task [type="bridge"
                name="some_bridge"
                requestData="{\\"data\\":{\\"foo\\": $(foo), \\"bar\\": $(bar)}}"
                ]
```

## CBOR Parse task
CBOR Parse tasks parse a CBOR payload, typically as part of a Direct Request workflow. In Direct Request, a user makes an onchain request using a ChainlinkClient contract, which encodes the request parameters as CBOR. See below for an example.

Parameters

• data: A byte array containing the CBOR payload.
• mode: An optional parameter that specifies how to parse the incoming CBOR. The default mode is diet, which expects the input to be a map. Set the mode to standard to pass literal values through "as-is". Empty inputs return nil.

Outputs

A map containing the request parameters. Parameters can be individually accessed using $(dot.accessors).

Example

[Image: copy to clipboard]
```toml
// First, we parse the request log and the CBOR payload inside of it
decode_log  [type="ethabidecodelog"
             data="$(jobRun.logData)"
             topics="$(jobRun.logTopics)"
             abi="SomeContractEvent(bytes32 requestID, bytes cborPayload)"]

decode_cbor [type="cborparse"
             data="$(decode_log.cborPayload)"]

// Then, we use the decoded request parameters to make an HTTP fetch
fetch [type="http" url="$(decode_cbor.fetchURL)" method=GET]
parse [type="jsonparse" path="$(decode_cbor.jsonPath)" data="$(fetch)"]

// ... etc ...
```

See the Direct Request page for a more comprehensive example.

## Divide task
Divides the provided input by the divisor and returns the result with a number of decimal places defined in the precision value.

Parameters

• input: The value to be divided

number
stringified number
bytes-ified number
$(variable)
• divisor: The value by which to divide the input

number
stringified number
bytes-ified number
$(variable)
• precision: The number of decimal places to retain in the result

number
stringified number
bytes-ified number
$(variable)

Outputs

The result of the division.

Example

[Image: copy to clipboard]
```toml
my_divide_task [type="divide"
                input="$(json_parse_result)"
                divisor="3"
                precision="2"]
```

Given the input 10, this example returns 3.33.

## ETH ABI Decode Log task
Decodes a log emitted by an ETH contract.

Parameters

• abi: a canonical ETH log event definition. Should be formatted exactly as in Solidity. Each argument must be named. Examples:

NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt)
AuthorizedSendersChanged(address[] senders)
• data: the ABI-encoded log data. Can be:

a byte array
a hex-encoded string beginning with 0x
... but generally should just be set to $(jobRun.logData) (see the Direct Request page)
• topics: the ABI-encoded log topics (i.e., the indexed parameters)

an array of bytes32 values
an array of hex-encoded bytes32 values beginning with 0x
... but generally should just be set to $(jobRun.logTopics) (see the Direct Request page)

Outputs

A map containing the decoded values.

Example

[Image: copy to clipboard]
```toml
decode [type="ethabidecodelog"
        abi="NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt)"
        data="$(jobRun.logData)"
        topics="$(jobRun.logTopics)"]
```

This task will return a map with the following schema:

[Image: copy to clipboard]
```json
{
    "roundId": ...,   // a number
    "startedBy": ..., // an address
    "startedAt": ..., // a number
}
```

## ETH ABI Decode task
Decodes a ETH ABI-encoded payload, typically the result of an ETH Call task.

Parameters

• abi: a canonical ETH ABI argument string. Should be formatted exactly as in Solidity. Each argument must be named. Examples:

uint256 foo, bytes32 bar, address[] baz
address a, uint80[3][] u, bytes b, bytes32 b32
• data: the ABI-encoded payload to decode. Can be:

a byte array
a hex-encoded string beginning with 0x

Outputs

A map containing the decoded values.

Example

[Image: copy to clipboard]
```toml
decode [type="ethabidecode"
        abi="bytes32 requestID, uint256 price, address[] oracles"
        data="$(eth_call_result)"]
```

This task will return a map with the following schema:

[Image: copy to clipboard]
```json
{
    "requestID": ..., // [32]byte value
    "price": ...,     // a number
    "oracles": [
        "0x859AAa51961284C94d970B47E82b8771942F1980",
        "0x51DE85B0cD5B3684865ECfEedfBAF12777cd0Ff8",
        ...
    ]
}
```

## ETH ABI Encode task
Encodes a bytes payload according to ETH ABI encoding, typically in order to perform an ETH Call or an ETH Tx.

Parameters

• abi: a canonical ETH ABI argument string. Should be formatted exactly as in Solidity. Each argument must be named. If a method name is provided, the 4-byte method signature is prepended to the result. Examples:

uint256 foo, bytes32 bar, address[] baz
fulfillRequest(bytes32 requestID, uint256 answer)
• data: a map of the values to be encoded. The task will make a best effort at converting values to the appropriate types.

Outputs

A byte array.

Example

[Image: copy to clipboard]
```toml
encode [type="ethabiencode"
        abi="fulfillRequest(bytes32 requestID, uint256 answer)"
        data="{\\"requestID\\": $(foo), \\"answer\\": $(bar)}"
        ]
```

## ETH Call task
Makes a non-mutating contract call to the specified contract with the specified data payload.

Parameters

• contract: the address of the contract to call.
• data: the data to attach to the call (including the function selector).
• gas: the amount of gas to attach to the transaction.
• from: The from address with which the call should be made. Defaults to zero address.
• gasPrice: The gasPrice for the call. Defaults to zero.
• gasTipCap: The gasTipCap (EIP-1559) for the call. Defaults to zero.
• gasFeeCap: The gasFeeCap (EIP-1559) for the call. Defaults to zero.
• gasUnlimited: A boolean indicating if unlimited gas should be provided for the call. If set to true, do not pass the gas parameter.
• evmChainID: Set this optional parameter to transmit on the given chain. You must have the chain configured with RPC nodes for this to work. If left blank, it will use the default chain.

Outputs

An ABI-encoded byte array containing the return value of the contract function.

Example

[Image: copy to clipboard]
```toml
encode_call  [type="ethabiencode"
              abi="checkUpkeep(bytes data)"
              data="{ \\"data\\": $(upkeep_data) }"]

call          [type="ethcall"
               contract="0xa36085F69e2889c224210F603D836748e7dC0088"
               data="$(encode_call)"
               gas="1000"]

decode_result [type="ethabidecode"
               abi="bool upkeepNeeded, bytes performData"
               data="$(call)"]

encode_call -> call -> decode_result
```

## ETH Tx task
Makes a mutating transaction to the specified contract with the specified data payload. The transaction is guaranteed to succeed eventually.

Parameters

• from: one or more addresses of the externally-owned account from which to send the transaction. If left blank, it will select a random address on every send for the given chain ID.
• to: the address of the contract to make a transaction to.
• data: the data to attach to the call (including the function selector). Most likely, this will be the output of an ethabiencode task.
• gasLimit: the amount of gas to attach to the transaction.
• txMeta: a map of metadata that is saved into the database for debugging.
• minConfirmations: minimum number of confirmations required before this task will continue. Set to zero to continue immediately. Note that this does not affect transaction inclusion. All transactions will always be included in the chain up to the configured finality depth.
• evmChainID: set this optional parameter to transmit on the given chain. You must have the chain configured with RPC nodes for this to work. If left blank, it will use the default chain.
• failOnRevert: an optional parameter, a boolean, that allows a ChainLink node operator's UI to display and color the status of the task within a job's pipeline depending on a transaction status. default: false.

Outputs

The hash of the transaction attempt that eventually succeeds (after potentially going through a gas bumping process to ensure confirmation).

Example

[Image: copy to clipboard]
```toml
encode_tx    [type="ethabiencode"
              abi="performUpkeep(bytes performData)"
              data="{ \\"data\\": $(upkeep_data) }"]

submit_tx    [type="ethtx"
               to="0xa36085F69e2889c224210F603D836748e7dC0088"
               data="$(encode_tx)"
               failOnRevert="true"]

encode_tx -> submit_tx
```

## Hex Decode task
Accepts a hexadecimal encoded string and returns decoded bytes.

Parameters

• input: a hexadecimal encoded string, must have prefix 0x.

Outputs

Decoded bytes.

Example

[Image: copy to clipboard]
```toml
my_hexdecode_task [type="hexdecode" input="0x12345678"]
```

Given the input 0x12345678, the task will return [0x12, 0x34, 0x56, 0x78].

## Hex Encode task
Encodes bytes/string/integer into a hexadecimal string.

Parameters

• input: Byte array, string or integer to be encoded.

Outputs

Hexadecimal string prefixed with "0x" (or empty string if input was empty).

Example

[Image: copy to clipboard]
```toml
my_hexencode_task [type="hexencode" input="xyz"]
```

Given the input string "xyz", the task will return "0x78797a", which are the ascii values of characters in the string.

## HTTP task
HTTP tasks make HTTP requests to arbitrary URLs.

Parameters

• method: the HTTP method that the request should use.
• url: the URL to make the HTTP request to.
• requestData (optional): a statically-defined payload to be sent to the external adapter.
• allowUnrestrictedNetworkAccess (optional): permits the task to access a URL at localhost, which could present a security risk. Note that Bridge tasks allow this by default.
• headers (optional): an array of strings. The number of strings must be even. Example: foo [type=http headers="[\\"X-Header-1\\", \\"value1\\", \\"X-Header-2\\", \\"value2\\"]"]

Outputs

A string containing the response body.

Example

[Image: copy to clipboard]
```toml
my_http_task [type="http"
              method=PUT
              url="http://chain.link"
              requestData="{\\"foo\\": $(foo), \\"bar\\": $(bar), \\"jobID\\": 123}"
              allowUnrestrictedNetworkAccess=true
              ]
```

## JSON Parse task
JSON Parse tasks parse a JSON payload and extract a value at a given keypath.

Parameters

• data: the JSON string. Can be:

string
byte array
• path: the keypath to extract. Must be a comma-delimited list of keys, or specify a custom separator alternative.
• separator: (optional) custom path key separator. Defaults to comma (,).
• lax (optional): if false (or omitted), and the keypath doesn't exist, the task will error. If true, the task will return nil to the next task.

Outputs

The value at the provided keypath.

Example

[Image: copy to clipboard]
```toml
my_json_task [type="jsonparse"
              data="$(http_fetch_result)"
              path="data,0,price"]
```

This task returns 123.45 (float64) when given the following example data value:

[Image: copy to clipboard]
```json
{
  "data": [{ "price": 123.45 }, { "price": 678.9 }]
}
```

## Length task
Returns the length of a byte array or string.

Parameters

• input: Byte array, or string to get the length for.

Outputs

The length of the byte array or string.

Note: For strings containing multi-byte unicode characters, the output is the length in bytes and not number of characters.

Example

[Image: copy to clipboard]
```toml
my_length_task [type="length" input="xyz"]
```

Given the input string "xyz", the task will return 3, length of the string.

## Less Than task
Returns a boolean, result of computing left LESS_THAN right.

Parameters

• left: the left hand side of comparison. Possible values:

number
stringified number
bytes-ified number
$(variable)
• right: the right hand side of comparison. Possible values:

number
stringified number
bytes-ified number
$(variable)

Outputs

The result of less than comparison.

Example

[Image: copy to clipboard]
```toml
my_lessthan_task [type="lessthan" left="3" right="10"]
```

the task will return true which is the result of 3 LESS_THAN 10

## Lowercase task
Accepts a string and returns a lowercase string.

Parameters

• input: a string.

Outputs

Lowercase string.

Example

[Image: copy to clipboard]
```toml
my_lowercase_task [type="lowercase" input="Hello World!"]
```

Given the input Hello World!, the task will return hello world!.

## Mean task
Accepts multiple numerical inputs and returns the mean (average) of them.

Parameters

• values: an array of values to be averaged.
• allowedFaults (optional): the maximum number of input tasks that can error without the Mean task erroring. If not specified, this value defaults to N - 1, where N is the number of inputs.
• precision: the number of decimal places in the result.

Outputs

The average of the values in the values array.

Example

[Image: copy to clipboard]
```toml
my_mean_task [type="mean"
              values=<[ $(fetch1), $(fetch2), $(fetch3) ]>
              precision=2
              allowedFaults=1]
```

Given the inputs 2, 5, and 20, the task will return 9.

## Median task
Accepts multiple numerical inputs and returns the median of them.

Parameters

• values: an array of values from which to select a median.
• allowedFaults (optional): the maximum number of input tasks that can error without the Median task erroring. If not specified, this value defaults to N - 1, where N is the number of inputs.

Outputs

The median of the values in the values array.

Example

[Image: copy to clipboard]
```toml
my_median_task [type="median"
                values=<[ $(fetch1), $(fetch2), $(fetch3) ]>
                allowedFaults=1]
```

Given the inputs 2, 5, and 20, the task will return 5.

## Memo task
The memo task returns its value as a result.

Parameters

• value: value to return. Possible values:

number
boolean
float
string
array

Outputs

The value.

Example

[Image: copy to clipboard]
```toml
memo [type="memo" value="10"]
```

The task will return the value 10

## Merge task
Merge task returns the merged value of two maps.

Parameters

• left: The left map.
• right: The right map, which overwrites the left side.

Outputs

Returns the combined map of left and right. If the merged map is invalid, it returns null.

Example

[Image: copy to clipboard]
```toml
merge [type="merge" left="{\\"foo\\":\\"abc\\", \\"bar\\":\\"123\\"}" right="{\\"bar\\":\\"xyz\\", \\"biz\\":\\"buzz\\"}"]
```

This example task returns the following map:

[Image: copy to clipboard]
```json
{ "foo": "abc", "bar": "xyz", "biz": "buzz" }
```

## Mode task
Accepts multiple numerical inputs and returns the mode (most common) of them. If more than one value occur the maximum number of times, it returns all of them.

Parameters

• values: an array of values from which to select a mode.
• allowedFaults (optional): the maximum number of input tasks that can error without the Mode task erroring. If not specified, this value defaults to N - 1, where N is the number of inputs.

Outputs

A map containing two keys:

[Image: copy to clipboard]
```json
{
    "results": [ ... ], // An array containing all of the values that occurred the maximum number of times
    "occurrences": ..., // The number of times those values occurred
}
```

Example

[Image: copy to clipboard]
```toml
my_mode_task [type="mode"
                values=<[ $(fetch1), $(fetch2), $(fetch3), $(fetch4), $(fetch5), $(fetch6), $(fetch7), $(fetch8) ]>
                allowedFaults=3]
```

This task can handle arrays with mixed types. For example, given a values array containing both strings and ints like [ 2, 5, 2, "foo", "foo" "bar", "foo", 2 ], the task returns the following JSON:

[Image: copy to clipboard]
```json
{
  "occurrences": 3,
  "results": [2, "foo"]
}
```

To encode the results array into the ethabiencode task, specify that the data is an array in the abi and point the data parameter to the results from your mode task. Because argument encoding enforces types, all of the values in the array must be of the same type. As an example, you can encode the results of a mode task with an array of integers:

[Image: copy to clipboard]
```toml
mode_task [type="mode" values=<[ 1, 2, 2, 3, 1 ]>]

encode_mode_task [type="ethabiencode" abi="(bytes32 requestId, uint64 occurrences, uint256[] results)" data="{\\"requestId\\": $(decode_log.requestId), \\"occurrences\\": $(mode_task.occurrences), \\"results\\": $(mode_task.results) }"]
```

In this example, the mode task returns the following result:

[Image: copy to clipboard]
```json
{
  "occurrences": 2,
  "results": [2, 1]
}
```

The ethabiencode task encodes results as a uint256[] array.

## Multiply task
Multiplies the provided input and times values.

Parameters

• input: the value to be multiplied. Possible values:

number
stringified number
bytes-ified number
$(variable)
• times: the value to multiply the input with.

number
stringified number
bytes-ified number
$(variable)

Outputs

The result of the multiplication.

Example

[Image: copy to clipboard]
```toml
my_multiply_task [type="multiply" input="$(json_parse_result)" times=3]
```

Given the input 10, the task will return 30.

## Sum Task
Accepts multiple numerical inputs and returns the sum of them.

Parameters

• values: an array of values to sum.
• allowedFaults (optional): the maximum number of input tasks that can error without the Sum task erroring. If not specified, this value defaults to N - 1, where N is the number of inputs.

Outputs

The sum of the values in the values array.

Example

[Image: copy to clipboard]
```toml
my_sum_task [type="sum"
             values=<[ $(fetch1), $(fetch2), $(fetch3) ]>
             allowedFaults=1]
```

Given the inputs 2, 5, and 20, the task will return 27.

## Uppercase task
Accepts a string and returns an uppercase string.

Parameters

• input: a string.

Outputs

Uppercase string.

Example

[Image: copy to clipboard]
```toml
my_uppercase_task [type="uppercase" input="Hello World!"]
```

Given the input Hello World!, the task will return HELLO WORLD!.

================================================================================

# Requirements

Source: https://docs.chain.link/chainlink-nodes/resources/requirements
Extraction Method: playwright

# Requirements

## Hardware
The requirements for running a Chainlink node scale with the as the number of jobs that your node services. CPUs with the x86 architecture is recommended for production environments, but you can use Apple M1 systems for development if you run the Chainlink node in Docker.

• Minimum: At least 2 CPU cores and 4 GB of RAM will allow you to get a node running for testing and basic development.
• Recommended: For nodes in a production environment with over 100 jobs, you will need at least 4 CPU cores and 8GB of RAM.

If you run your PostgreSQL database locally, you will need additional hardware. To support more than 100 jobs, your database server will need at least 4 cores, 16 GB of RAM, and 100 GB of storage.

If you run your node on AWS or another cloud platform, use a VM instance type with dedicated core time. Burstable Performance Instances and VM instances with shared cores often have a limited number of CPU credits, which do not perform well for Chainlink nodes that require consistent performance.

## Software
Chainlink nodes have the following software dependencies:

• Operating System: Linux, MacOS, or the WSL (Windows Subsystem for Linux)

For production environments, Linux is recommended.
• Docker: Although it is possible to build Chainlink nodes from source, the best practice is to use the Chainlink Docker Images without -root.
• PostgreSQL versions >= 12 (Version 12 and later).

If you use a database as a service, your database host must provide access to logs.
If you run the database on a separate system, secure the TCP/IP connection with SSL.

## Blockchain connectivity
Chainlink nodes require a fully-synced network client so that they can run onchain transactions and interact with deployed contracts. For Ethereum, see the list of supported clients. Other L1s, L2s, and side-chains use different clients. See your network's documentation to learn how to run a client for your specific network.

The client must meet the following requirements:

• You can use a provider like Alchemy or Infura, but running your own client can provide lower latency and greater decentralization.
• Run your Chainlink nodes on their own separate VM or system. Hardware and storage requirements for these clients will change over time, so you will likely need to scale their capacity separately from the system where you run your Chainlink nodes.
• The client must provide both HTTP and WebSocket connections secured with SSL. Most providers give you https:// and wss:// connections by default. If you run your own client, you must create a reverse proxy for your client using a web server like Nginx. The web server handles the SSL encryption and forwards the connection to your client.

See Running Ethereum Clients for more details.

================================================================================

# Fulfilling Requests

Source: https://docs.chain.link/chainlink-nodes/v1/fulfilling-requests
Extraction Method: playwright
Components: code_block(2)

# Fulfilling Requests
[Image: note]Run a Chainlink node

This guide assumes you have a running Chainlink node. To learn how to run a node, see the Running a Chainlink Node
locally guide.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }You can use your Chainlink nodes to fulfill requests. This guide shows you how to deploy your own operator contract and add jobs to your node so that it can provide data to smart contracts.

Chainlink nodes can fulfill requests from open or unauthenticated APIs without the need for External Adapters as long as you've added the jobs to the node. For these requests, requesters supply the URL to the open API that they want each node to retrieve. The Chainlink node will use tasks to fulfill the request.

Some APIs require authentication by providing request headers for the operator's API key, which the Chainlink node supports. If you would like to provide access to an API that requires authentication, you must create a job that is specific for that API either using an external adapter or by using the parameters of the HTTP task.

## Requirements
Before you begin this guide, complete the following tasks to make sure you have all of the tools that you need:

• Set up MetaMask and obtain testnet LINK.
• Run a Chainlink Node.
• Fund the Ethereum address that your Chainlink node uses. You can find the address in the node Operator GUI under the Key Management configuration. The address of the node is the Regular type. You can obtain test ETH from several faucets. For this tutorial to work, you will have to fund the node's Ethereum address with Sepolia ETH. Here is an example:

## Address types
Your node works with several different types of addresses. Each address type has a specific function:

• Node address: This is the address for your Chainlink node wallet. The node requires native gas tokens at all times to respond to requests. For this example, the node uses Sepolia ETH. When you start a Chainlink node, it automatically generates this address. You can find this address on the Node Operator GUI under Key Management > EVM Chain Accounts.
• Oracle contract address: This is the address for contracts like Operator.sol that are deployed to a blockchain. Do not fund these addresses with native gas tokens such as ETH. When you make API call requests, the funds pass through this contract to interact with your Chainlink node. This will be the address that smart contract developers point to when they choose a node for an API call.
• Admin wallet address: This is the address that owns your Operator.sol contract addresses. If you're on OCR, this is the wallet address that receives LINK tokens.

## Set up your Operator contract

### Deploy your own Operator contract

1. Go to Remix and open the Operator.sol smart contract.
2. On the Compile tab, click the Compile button for Operator.sol. Remix automatically selects the compiler version and language from the pragma line unless you select a specific version manually.
3. On the Deploy and Run tab, configure the following settings:

Select "Injected Provider" as your Environment. The Javascript VM environment cannot access your oracle node. Make sure your Metamask is connected to Sepolia testnet.

Select the "Operator" contract from the Contract menu.

Copy the LINK token contract address for the network you are using and paste it into the LINK field next to the Deploy button. For Sepolia, you can use this address:
0x779877A7B0D9E8603169DdbD7836e478b4624789

Copy the Admin wallet address into the OWNER field.
4. Click transact. MetaMask prompts you to confirm the transaction.
      MetaMask doesn't pop up?  If MetaMask does not prompt you and instead displays the error below, disable "Privacy Mode" in MetaMask. You can
do this by clicking on your unique account icon at the top-right, then go to the Settings. Privacy Mode will be a
switch near the bottom.Error: Send transaction failed: Invalid address. If you use an injected provider, please check it is properly
unlocked.
5. If the transaction is successful, a new address displays in the Deployed Contracts section.
6. Keep note of the Operator contract address. You need it later for your consuming contract.

### Whitelist your node address in the Operator contract

1. In the Chainlink node GUI, find and copy the address of your chainlink node. see Requirements.
2. In Remix, call the setAuthorizedSenders function with the address of your node. Note the function expects an array.
3. Click the transact function to run it. Approve the transaction in MetaMask and wait for it to confirm on the blockchain.
4. Call isAuthorizedSender function with the address of your node to verify that your chainlink node address can call the operator contract. The function must return true.

## Add a job to the node
You will create a job that calls an OpenAPI , parses the response and then returns a uint256.

1. In the Chainlink Operator UI on the Jobs tab, click New Job.
2. Paste the job specification from above into the text field.
# THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
# THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
# DO NOT USE THIS CODE IN PRODUCTION.

name = "Get > Uint256 - (TOML)"
schemaVersion = 1
type = "directrequest"
# evmChainID for Sepolia Testnet
evmChainID = "11155111"
# Optional External Job ID: Automatically generated if unspecified
# externalJobID = "b1d42cd5-4a3a-4200-b1f7-25a68e48aad8"
contractAddress = "YOUR_OPERATOR_CONTRACT_ADDRESS"
maxTaskDuration = "0s"
minIncomingConfirmations = 0
observationSource = """
    decode_log   [type="ethabidecodelog"
                  abi="OracleRequest(bytes32 indexed specId, address requester, bytes32 requestId, uint256 payment, address callbackAddr, bytes4 callbackFunctionId, uint256 cancelExpiration, uint256 dataVersion, bytes data)"
                  data="$(jobRun.logData)"
                  topics="$(jobRun.logTopics)"]

    decode_cbor  [type="cborparse" data="$(decode_log.data)"]
    fetch        [type="http" method=GET url="$(decode_cbor.get)" allowUnrestrictedNetworkAccess="true"]
    parse        [type="jsonparse" path="$(decode_cbor.path)" data="$(fetch)"]

    multiply     [type="multiply" input="$(parse)" times="$(decode_cbor.times)"]

    encode_data  [type="ethabiencode" abi="(bytes32 requestId, uint256 value)" data="{ \\"requestId\\": $(decode_log.requestId), \\"value\\": $(multiply) }"]
    encode_tx    [type="ethabiencode"
                  abi="fulfillOracleRequest2(bytes32 requestId, uint256 payment, address callbackAddress, bytes4 callbackFunctionId, uint256 expiration, bytes calldata data)"
                  data="{\\"requestId\\": $(decode_log.requestId), \\"payment\\":   $(decode_log.payment), \\"callbackAddress\\": $(decode_log.callbackAddr), \\"callbackFunctionId\\": $(decode_log.callbackFunctionId), \\"expiration\\": $(decode_log.cancelExpiration), \\"data\\": $(encode_data)}"
                  ]
    submit_tx    [type="ethtx" to="YOUR_OPERATOR_CONTRACT_ADDRESS" data="$(encode_tx)"]

    decode_log -> decode_cbor -> fetch -> parse -> multiply -> encode_data -> encode_tx -> submit_tx
"""
3. Replace YOUR_OPERATOR_CONTRACT_ADDRESS with the address of your deployed operator contract address from the previous steps.
4. Click Create Job. If the node creates the job successfully, a notice with the job number appears.
5. Click the job number to view the job details. You can also find the job listed on the Jobs tab in the Node Operators UI. Save the externalJobID value because you will need it later to tell your consumer contract what job ID to request from your node.

## Create a request to your node
After you add jobs to your node, you can use the node to fulfill requests. This section shows what a requester does when they send requests to your node. It is also a way to test and make sure that your node is functioning correctly.

1. Open ATestnetConsumer.sol in Remix.
2. Note that _setChainlinkToken(0x779877A7B0D9E8603169DdbD7836e478b4624789) is configured for Sepolia.
3. On the Compiler tab, click the Compile button for ATestnetConsumer.sol.
4. On the Deploy and Run tab, configure the following settings:

Select Injected Provider as your environment. Make sure your metamask is connected to Sepolia.
Select ATestnetConsumer from the Contract menu.
5. Click Deploy. MetaMask prompts you to confirm the transaction.
6. Fund the contract by sending LINK to the contract's address. See the Fund your contract page for instructions. The address for the ATestnetConsumer contract is on the list of your deployed contracts in Remix. You can fund your contract with 1 LINK.
7. After you fund the contract, create a request. Input your operator contract address and the job ID for the Get > Uint256 job into the requestEthereumPrice request method without dashes. The job ID is the externalJobID parameter, which you can find on your job's definition page in the Node Operators UI.
8. Click the transact button for the requestEthereumPrice function and approve the transaction in Metamask. The requestEthereumPrice function asks the node to retrieve uint256 data specifically from https://min-api.cryptocompare.com/data/price?fsym=ETH&tsyms=USD.
9. After the transaction processes, you can see the details for the complete the job run the Runs page in the Node Operators UI.
10. In Remix, click the currentPrice variable to see the current price updated on your consumer contract.

## Withdrawing LINK
You can withdraw LINK from the operator contract. In Remix under the list of deployed contracts, click on your Operator contract and find the withdraw function in the function list. Note that only the admin (see Admin wallet address) can withdraw LINK.

Paste the address you want to withdraw to, and specify the amount of LINK that you want to withdraw. Then, click withdraw. Confirm the transaction in MetaMask when the popup appears.

================================================================================

# Node Config (TOML)

Source: https://docs.chain.link/chainlink-nodes/v1/node-config
Extraction Method: playwright
Components: code_block(649)

# Node Config (TOML)
This document describes the TOML format for configuration.

See also: Secrets Config

## Example
[Image: copy to clipboard]
```toml
Log.Level = 'debug'

[[EVM]]
ChainID = '1' # Required

[[EVM.Nodes]]
Name = 'fake' # Required
WSURL = 'wss://foo.bar/ws'
HTTPURL = 'https://foo.bar' # Required
```

## Global
[Image: copy to clipboard]
```toml
InsecureFastScrypt = false # Default
InsecurePPROFHeap = false # Default
RootDir = '~/.chainlink' # Default
ShutdownGracePeriod = '5s' # Default
```

### InsecureFastScrypt
[Image: caution]caution

ADVANCED:Do not change this setting unless you know what you are doing..asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }[Image: copy to clipboard]
```toml
InsecureFastScrypt = false # Default
```

InsecureFastScrypt causes all key stores to encrypt using "fast" scrypt params instead. This is insecure and only useful for local testing. DO NOT ENABLE THIS IN PRODUCTION.

### InsecurePPROFHeap
[Image: caution]caution

ADVANCED:Do not change this setting unless you know what you are doing..asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }[Image: copy to clipboard]
```toml
InsecurePPROFHeap = false # Default
```

InsecurePPROFHeap allows dumping the heap in pprof. This is very useful for debugging memory leaks but in certain rare cases may potentially expose sensitive data e.g. private key components, so is disabled by default.

### RootDir
[Image: copy to clipboard]
```toml
RootDir = '~/.chainlink' # Default
```

RootDir is the Chainlink node's root directory. This is the default directory for logging, database backups, cookies, and other misc Chainlink node files. Chainlink nodes will always ensure this directory has 700 permissions because it might contain sensitive data.

### ShutdownGracePeriod
[Image: copy to clipboard]
```toml
ShutdownGracePeriod = '5s' # Default
```

ShutdownGracePeriod is the maximum time allowed to shut down gracefully. If exceeded, the node will terminate immediately to avoid being SIGKILLed.

## Feature
[Image: copy to clipboard]
```toml
[Feature]
FeedsManager = true # Default
LogPoller = false # Default
UICSAKeys = false # Default
CCIP = true # Default
MultiFeedsManagers = false # Default
```

### FeedsManager
[Image: copy to clipboard]
```toml
FeedsManager = true # Default
```

FeedsManager enables the feeds manager service.

### LogPoller
[Image: copy to clipboard]
```toml
LogPoller = false # Default
```

LogPoller enables the log poller, an experimental approach to processing logs, required if also using Evm.UseForwarders or OCR2.

### UICSAKeys
[Image: copy to clipboard]
```toml
UICSAKeys = false # Default
```

UICSAKeys enables CSA Keys in the UI.

### CCIP
[Image: copy to clipboard]
```toml
CCIP = true # Default
```

CCIP enables the CCIP service.

### MultiFeedsManagers
[Image: copy to clipboard]
```toml
MultiFeedsManagers = false # Default
```

MultiFeedsManagers enables support for multiple feeds manager connections.

## Database
[Image: copy to clipboard]
```toml
[Database]
DefaultIdleInTxSessionTimeout = '1h' # Default
DefaultLockTimeout = '15s' # Default
DefaultQueryTimeout = '10s' # Default
LogQueries = false # Default
MaxIdleConns = 10 # Default
MaxOpenConns = 100 # Default
MigrateOnStartup = true # Default
```

### DefaultIdleInTxSessionTimeout
[Image: copy to clipboard]
```toml
DefaultIdleInTxSessionTimeout = '1h' # Default
```

DefaultIdleInTxSessionTimeout is the maximum time allowed for a transaction to be open and idle before timing out. See Postgres idle_in_transaction_session_timeout for more details.

### DefaultLockTimeout
[Image: copy to clipboard]
```toml
DefaultLockTimeout = '15s' # Default
```

DefaultLockTimeout is the maximum time allowed to wait for database lock of any kind before timing out. See Postgres lock_timeout for more details.

### DefaultQueryTimeout
[Image: copy to clipboard]
```toml
DefaultQueryTimeout = '10s' # Default
```

DefaultQueryTimeout is the maximum time allowed for standard queries before timing out.

### LogQueries
[Image: copy to clipboard]
```toml
LogQueries = false # Default
```

LogQueries tells the Chainlink node to log database queries made using the default logger. SQL statements will be logged at debug level. Not all statements can be logged. The best way to get a true log of all SQL statements is to enable SQL statement logging on Postgres.

### MaxIdleConns
[Image: copy to clipboard]
```toml
MaxIdleConns = 10 # Default
```

MaxIdleConns configures the maximum number of idle database connections that the Chainlink node will keep open. Think of this as the baseline number of database connections per Chainlink node instance. Increasing this number can help to improve performance under database-heavy workloads.

Postgres has connection limits, so you must use caution when increasing this value. If you are running several instances of a Chainlink node or another application on a single database server, you might run out of Postgres connection slots if you raise this value too high.

### MaxOpenConns
[Image: copy to clipboard]
```toml
MaxOpenConns = 100 # Default
```

MaxOpenConns configures the maximum number of database connections that a Chainlink node will have open at any one time. Think of this as the maximum burst upper bound limit of database connections per Chainlink node instance. Increasing this number can help to improve performance under database-heavy workloads.

Postgres has connection limits, so you must use caution when increasing this value. If you are running several instances of a Chainlink node or another application on a single database server, you might run out of Postgres connection slots if you raise this value too high.

### MigrateOnStartup
[Image: copy to clipboard]
```toml
MigrateOnStartup = true # Default
```

MigrateOnStartup controls whether a Chainlink node will attempt to automatically migrate the database on boot. If you want more control over your database migration process, set this variable to false and manually migrate the database using the CLI migrate command instead.

## Database.Backup
[Image: copy to clipboard]
```toml
[Database.Backup]
Mode = 'none' # Default
Dir = 'test/backup/dir' # Example
OnVersionUpgrade = true # Default
Frequency = '1h' # Default
```

As a best practice, take regular database backups in case of accidental data loss. This best practice is especially important when you upgrade your Chainlink node to a new version. Chainlink nodes support automated database backups to make this process easier.

NOTE: Dumps can cause high load and massive database latencies, which will negatively impact the normal functioning of the Chainlink node. For this reason, it is recommended to set a URL and point it to a read replica if you enable automatic backups.

### Mode
[Image: copy to clipboard]
```toml
Mode = 'none' # Default
```

Mode sets the type of automatic database backup, which can be one of none, lite, or full. If enabled, the Chainlink node will always dump a backup on every boot before running migrations. Additionally, it will automatically take database backups that overwrite the backup file for the given version at regular intervals if Frequency is set to a non-zero interval.

none - Disables backups.
lite - Dumps small tables including configuration and keys that are essential for the node to function, which excludes historical data like job runs, transaction history, etc.
full - Dumps the entire database.

It will write to a file like 'Dir'/backup/cl_backup_<VERSION>.dump. There is one backup dump file per version of the Chainlink node. If you upgrade the node, it will keep the backup taken right before the upgrade migration so you can restore to an older version if necessary.

### Dir
[Image: copy to clipboard]
```toml
Dir = 'test/backup/dir' # Example
```

Dir sets the directory to use for saving the backup file. Use this if you want to save the backup file in a directory other than the default ROOT directory.

### OnVersionUpgrade
[Image: copy to clipboard]
```toml
OnVersionUpgrade = true # Default
```

OnVersionUpgrade enables automatic backups of the database before running migrations, when you are upgrading to a new version.

### Frequency
[Image: copy to clipboard]
```toml
Frequency = '1h' # Default
```

Frequency sets the interval for database dumps, if set to a positive duration and Mode is not none.

Set to 0 to disable periodic backups.

## Database.Listener
[Image: caution]caution

ADVANCED:Do not change these settings unless you know what you are doing..asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }[Image: copy to clipboard]
```toml
[Database.Listener]
MaxReconnectDuration = '10m' # Default
MinReconnectInterval = '1m' # Default
FallbackPollInterval = '30s' # Default
```

These settings control the postgres event listener.

### MaxReconnectDuration
[Image: copy to clipboard]
```toml
MaxReconnectDuration = '10m' # Default
```

MaxReconnectDuration is the maximum duration to wait between reconnect attempts.

### MinReconnectInterval
[Image: copy to clipboard]
```toml
MinReconnectInterval = '1m' # Default
```

MinReconnectInterval controls the duration to wait before trying to re-establish the database connection after connection loss. After each consecutive failure this interval is doubled, until MaxReconnectInterval is reached. Successfully completing the connection establishment procedure resets the interval back to MinReconnectInterval.

### FallbackPollInterval
[Image: copy to clipboard]
```toml
FallbackPollInterval = '30s' # Default
```

FallbackPollInterval controls how often clients should manually poll as a fallback in case the postgres event was missed/dropped.

## Database.Lock
[Image: caution]caution

ADVANCED:Do not change these settings unless you know what you are doing..asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }[Image: copy to clipboard]
```toml
[Database.Lock]
Enabled = true # Default
LeaseDuration = '10s' # Default
LeaseRefreshInterval = '1s' # Default
```

Ideally, you should use a container orchestration system like Kubernetes to ensure that only one Chainlink node instance can ever use a specific Postgres database. However, some node operators do not have the technical capacity to do this. Common use cases run multiple Chainlink node instances in failover mode as recommended by our official documentation. The first instance takes a lock on the database and subsequent instances will wait trying to take this lock in case the first instance fails.

• If your nodes or applications hold locks open for several hours or days, Postgres is unable to complete internal cleanup tasks. The Postgres maintainers explicitly discourage holding locks open for long periods of time.

Because of the complications with advisory locks, Chainlink nodes with v2.0 and later only support lease locking mode. The lease locking mode works using the following process:

• Node A creates one row in the database with the client ID and updates it once per second.
• Node B spinlocks and checks periodically to see if the client ID is too old. If the client ID is not updated after a period of time, node B assumes that node A failed and takes over. Node B becomes the owner of the row and updates the client ID once per second.
• If node A comes back, it attempts to take out a lease, realizes that the database has been leased to another process, and exits the entire application immediately.

### Enabled
[Image: copy to clipboard]
```toml
Enabled = true # Default
```

Enabled enables the database lock.

### LeaseDuration
[Image: copy to clipboard]
```toml
LeaseDuration = '10s' # Default
```

LeaseDuration is how long the lease lock will last before expiring.

### LeaseRefreshInterval
[Image: copy to clipboard]
```toml
LeaseRefreshInterval = '1s' # Default
```

LeaseRefreshInterval determines how often to refresh the lease lock. Also controls how often a standby node will check to see if it can grab the lease.

## TelemetryIngress
[Image: copy to clipboard]
```toml
[TelemetryIngress]
UniConn = false # Default
Logging = false # Default
BufferSize = 100 # Default
MaxBatchSize = 50 # Default
SendInterval = '500ms' # Default
SendTimeout = '10s' # Default
UseBatchSend = true # Default
```

### UniConn
[Image: copy to clipboard]
```toml
UniConn = false # Default
```

UniConn toggles which ws connection style is used.

### Logging
[Image: copy to clipboard]
```toml
Logging = false # Default
```

Logging toggles verbose logging of the raw telemetry messages being sent.

### BufferSize
[Image: copy to clipboard]
```toml
BufferSize = 100 # Default
```

BufferSize is the number of telemetry messages to buffer before dropping new ones.

### MaxBatchSize
[Image: copy to clipboard]
```toml
MaxBatchSize = 50 # Default
```

MaxBatchSize is the maximum number of messages to batch into one telemetry request.

### SendInterval
[Image: copy to clipboard]
```toml
SendInterval = '500ms' # Default
```

SendInterval determines how often batched telemetry is sent to the ingress server.

### SendTimeout
[Image: copy to clipboard]
```toml
SendTimeout = '10s' # Default
```

SendTimeout is the max duration to wait for the request to complete when sending batch telemetry.

### UseBatchSend
[Image: copy to clipboard]
```toml
UseBatchSend = true # Default
```

UseBatchSend toggles sending telemetry to the ingress server using the batch client.

## TelemetryIngress.Endpoints
[Image: copy to clipboard]
```toml
[[TelemetryIngress.Endpoints]] # Example
Network = 'EVM' # Example
ChainID = '111551111' # Example
ServerPubKey = 'test-pub-key-111551111-evm' # Example
URL = 'localhost-111551111-evm:9000' # Example
```

### Network
[Image: copy to clipboard]
```toml
Network = 'EVM' # Example
```

Network aka EVM, Solana, Starknet

### ChainID
[Image: copy to clipboard]
```toml
ChainID = '111551111' # Example
```

ChainID of the network

### ServerPubKey
[Image: copy to clipboard]
```toml
ServerPubKey = 'test-pub-key-111551111-evm' # Example
```

ServerPubKey is the public key of the telemetry server.

### URL
[Image: copy to clipboard]
```toml
URL = 'localhost-111551111-evm:9000' # Example
```

URL is where to send telemetry.

## AuditLogger
[Image: copy to clipboard]
```toml
[AuditLogger]
Enabled = false # Default
ForwardToUrl = 'http://localhost:9898' # Example
JsonWrapperKey = 'event' # Example
Headers = ['Authorization: token', 'X-SomeOther-Header: value with spaces | and a bar+*'] # Example
```

### Enabled
[Image: copy to clipboard]
```toml
Enabled = false # Default
```

Enabled determines if this logger should be configured at all

### ForwardToUrl
[Image: copy to clipboard]
```toml
ForwardToUrl = 'http://localhost:9898' # Example
```

ForwardToUrl is where you want to forward logs to

### JsonWrapperKey
[Image: copy to clipboard]
```toml
JsonWrapperKey = 'event' # Example
```

JsonWrapperKey if set wraps the map of data under another single key to make parsing easier

### Headers
[Image: copy to clipboard]
```toml
Headers = ['Authorization: token', 'X-SomeOther-Header: value with spaces | and a bar+*'] # Example
```

Headers is the set of headers you wish to pass along with each request

## Log
[Image: copy to clipboard]
```toml
[Log]
Level = 'info' # Default
JSONConsole = false # Default
UnixTS = false # Default
```

### Level
[Image: copy to clipboard]
```toml
Level = 'info' # Default
```

Level determines only what is printed on the screen/console. This configuration does not apply to the logs that are recorded in a file (see Log.File for more details).

The available levels are:

• "debug": Useful for forensic debugging of issues.
• "info": High-level informational messages. (default)
• "warn": A mild error occurred that might require non-urgent action. Check these warnings semi-regularly to see if any of them require attention. These warnings usually happen due to factors outside of the control of the node operator. Examples: Unexpected responses from a remote API or misleading networking errors.
• "error": An unexpected error occurred during the regular operation of a well-maintained node. Node operators might need to take action to remedy this error. Check these regularly to see if any of them require attention. Examples: Use of deprecated configuration options or incorrectly configured settings that cause a job to fail.
• "crit": A critical error occurred. The node might be unable to function. Node operators should take immediate action to fix these errors. Examples: The node could not boot because a network socket could not be opened or the database became inaccessible.
• "panic": An exceptional error occurred that could not be handled. If the node is unresponsive, node operators should try to restart their nodes and notify the Chainlink team of a potential bug.
• "fatal": The node encountered an unrecoverable problem and had to exit.

### JSONConsole
[Image: copy to clipboard]
```toml
JSONConsole = false # Default
```

JSONConsole enables JSON logging. Otherwise, the log is saved in a human-friendly console format.

### UnixTS
[Image: copy to clipboard]
```toml
UnixTS = false # Default
```

UnixTS enables legacy unix timestamps.

Previous versions of Chainlink nodes wrote JSON logs with a unix timestamp. As of v1.1.0 and up, the default has changed to use ISO8601 timestamps for better readability.

## Log.File
[Image: copy to clipboard]
```toml
[Log.File]
Dir = '/my/log/directory' # Example
MaxSize = '5120mb' # Default
MaxAgeDays = 0 # Default
MaxBackups = 1 # Default
```

### Dir
[Image: copy to clipboard]
```toml
Dir = '/my/log/directory' # Example
```

Dir sets the log directory. By default, Chainlink nodes write log data to $ROOT/log.jsonl.

### MaxSize
[Image: copy to clipboard]
```toml
MaxSize = '5120mb' # Default
```

MaxSize determines the log file's max size before file rotation. Having this not set or set to a value smaller than 1Mb will disable logging to disk. If your disk doesn't have enough disk space, the logging will pause and the application will log errors until space is available again.

Values must have suffixes with a unit like: 5120mb (5,120 megabytes). If no unit suffix is provided, the value defaults to b (bytes). The list of valid unit suffixes are:

• b (bytes)
• kb (kilobytes)
• mb (megabytes)
• gb (gigabytes)
• tb (terabytes)

### MaxAgeDays
[Image: copy to clipboard]
```toml
MaxAgeDays = 0 # Default
```

MaxAgeDays determines the log file's max age in days before file rotation. Keeping this config with the default value will not remove log files based on age.

### MaxBackups
[Image: copy to clipboard]
```toml
MaxBackups = 1 # Default
```

MaxBackups determines the maximum number of old log files to retain. Keeping this config with the default value retains all old log files. The MaxAgeDays variable can still cause them to get deleted.

## WebServer
[Image: copy to clipboard]
```toml
[WebServer]
AuthenticationMethod = 'local' # Default
AllowOrigins = 'http://localhost:3000,http://localhost:6688' # Default
BridgeCacheTTL = '0s' # Default
BridgeResponseURL = 'https://my-chainlink-node.example.com:6688' # Example
HTTPWriteTimeout = '10s' # Default
HTTPPort = 6688 # Default
SecureCookies = true # Default
SessionTimeout = '15m' # Default
SessionReaperExpiration = '240h' # Default
HTTPMaxSize = '32768b' # Default
StartTimeout = '15s' # Default
ListenIP = '0.0.0.0' # Default
```

### AuthenticationMethod
[Image: copy to clipboard]
```toml
AuthenticationMethod = 'local' # Default
```

AuthenticationMethod defines which pluggable auth interface to use for user login and role assumption. Options include 'local' and 'ldap'. See docs for more details

### AllowOrigins
[Image: copy to clipboard]
```toml
AllowOrigins = 'http://localhost:3000,http://localhost:6688' # Default
```

AllowOrigins controls the URLs Chainlink nodes emit in the Allow-Origins header of its API responses. The setting can be a comma-separated list with no spaces. You might experience CORS issues if this is not set correctly.

You should set this to the external URL that you use to access the Chainlink UI.

You can set AllowOrigins = '*' to allow the UI to work from any URL, but it is recommended for security reasons to make it explicit instead.

### BridgeCacheTTL
[Image: copy to clipboard]
```toml
BridgeCacheTTL = '0s' # Default
```

BridgeCacheTTL controls the cache TTL for all bridge tasks to use old values in newer observations in case of intermittent failure. It's disabled by default.

### BridgeResponseURL
[Image: copy to clipboard]
```toml
BridgeResponseURL = 'https://my-chainlink-node.example.com:6688' # Example
```

BridgeResponseURL defines the URL for bridges to send a response to. This must be set when using async external adapters.

Usually this will be the same as the URL/IP and port you use to connect to the Chainlink UI.

### HTTPWriteTimeout
[Image: caution]caution

ADVANCED:Do not change this setting unless you know what you are doing..asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }[Image: copy to clipboard]
```toml
HTTPWriteTimeout = '10s' # Default
```

HTTPWriteTimeout controls how long the Chainlink node's API server can hold a socket open for writing a response to an HTTP request. Sometimes, this must be increased for pprof.

### HTTPPort
[Image: copy to clipboard]
```toml
HTTPPort = 6688 # Default
```

HTTPPort is the port used for the Chainlink Node API, CLI, and GUI.

### SecureCookies
[Image: copy to clipboard]
```toml
SecureCookies = true # Default
```

SecureCookies requires the use of secure cookies for authentication. Set to false to enable standard HTTP requests along with TLSPort = 0.

### SessionTimeout
[Image: copy to clipboard]
```toml
SessionTimeout = '15m' # Default
```

SessionTimeout determines the amount of idle time to elapse before session cookies expire. This signs out GUI users from their sessions.

### SessionReaperExpiration
[Image: copy to clipboard]
```toml
SessionReaperExpiration = '240h' # Default
```

SessionReaperExpiration represents how long an API session lasts before expiring and requiring a new login.

### HTTPMaxSize
[Image: copy to clipboard]
```toml
HTTPMaxSize = '32768b' # Default
```

HTTPMaxSize defines the maximum size for HTTP requests and responses made by the node server.

### StartTimeout
[Image: copy to clipboard]
```toml
StartTimeout = '15s' # Default
```

StartTimeout defines the maximum amount of time the node will wait for a server to start.

### ListenIP
[Image: copy to clipboard]
```toml
ListenIP = '0.0.0.0' # Default
```

ListenIP specifies the IP to bind the HTTP server to

## WebServer.OIDC
[Image: copy to clipboard]
```toml
[WebServer.OIDC]
ClientID = 'abcd1234' # Example
ProviderURL = 'https://id[.]example[.]com/oauth2/default' # Example
RedirectURL = 'http://localhost:8080/signin' # Example
ClaimName = 'groups' # Default
AdminClaim = 'NodeAdmins' # Default
EditClaim = 'NodeEditors' # Default
RunClaim = 'NodeRunners' # Default
ReadClaim = 'NodeReadOnly' # Default
SessionTimeout = '15m0s' # Default
UserAPITokenEnabled = false # Default
UserAPITokenDuration = '240h0m0s' # Default
```

Optional OIDC config if WebServer.AuthenticationMethod is set to 'oidc'

### ClientID
[Image: copy to clipboard]
```toml
ClientID = 'abcd1234' # Example
```

ClientID is the ID of the OIDC application registered with the identity provider

### ProviderURL
[Image: copy to clipboard]
```toml
ProviderURL = 'https://id[.]example[.]com/oauth2/default' # Example
```

ProviderURL is the base URL for your OIDC Identity provider.

### RedirectURL
[Image: copy to clipboard]
```toml
RedirectURL = 'http://localhost:8080/signin' # Example
```

RedirectURL will always be <NODE_BASE_URL>/signin. This needs to match the configuration on the provider side.

### ClaimName
[Image: copy to clipboard]
```toml
ClaimName = 'groups' # Default
```

ClaimName is the name of the field in the id_token where to find the user's ID claims.

### AdminClaim
[Image: copy to clipboard]
```toml
AdminClaim = 'NodeAdmins' # Default
```

AdminClaim is string label of the id claim that maps the core node's 'Admin' role

### EditClaim
[Image: copy to clipboard]
```toml
EditClaim = 'NodeEditors' # Default
```

EditClaim is string label of the id claim that maps the core node's 'Edit' role

### RunClaim
[Image: copy to clipboard]
```toml
RunClaim = 'NodeRunners' # Default
```

RunClaim is string label of the id claim that maps the core node's 'Run' role

### ReadClaim
[Image: copy to clipboard]
```toml
ReadClaim = 'NodeReadOnly' # Default
```

ReadClaim is string label of the id claim that maps the core node's 'Read' role

### SessionTimeout
[Image: copy to clipboard]
```toml
SessionTimeout = '15m0s' # Default
```

SessionTimeout determines the amount of idle time to elapse before session cookies expire. This signs out GUI users from their sessions.

### UserAPITokenEnabled
[Image: copy to clipboard]
```toml
UserAPITokenEnabled = false # Default
```

UserAPITokenEnabled enables the users to issue API tokens with the same access of their role

### UserAPITokenDuration
[Image: copy to clipboard]
```toml
UserAPITokenDuration = '240h0m0s' # Default
```

UserAPITokenDuration is the duration of time an API token is active for before expiring

## WebServer.LDAP
[Image: copy to clipboard]
```toml
[WebServer.LDAP]
ServerTLS = true # Default
SessionTimeout = '15m0s' # Default
QueryTimeout = '2m0s' # Default
BaseUserAttr = 'uid' # Default
BaseDN = 'dc=custom,dc=example,dc=com' # Example
UsersDN = 'ou=users' # Default
GroupsDN = 'ou=groups' # Default
ActiveAttribute = '' # Default
ActiveAttributeAllowedValue = '' # Default
AdminUserGroupCN = 'NodeAdmins' # Default
EditUserGroupCN = 'NodeEditors' # Default
RunUserGroupCN = 'NodeRunners' # Default
ReadUserGroupCN = 'NodeReadOnly' # Default
UserApiTokenEnabled = false # Default
UserAPITokenDuration = '240h0m0s' # Default
UpstreamSyncInterval = '0s' # Default
UpstreamSyncRateLimit = '2m0s' # Default
```

Optional LDAP config if WebServer.AuthenticationMethod is set to 'ldap'
LDAP queries are all parameterized to support custom LDAP 'dn', 'cn', and attributes

### ServerTLS
[Image: copy to clipboard]
```toml
ServerTLS = true # Default
```

ServerTLS defines the option to require the secure ldaps

### SessionTimeout
[Image: copy to clipboard]
```toml
SessionTimeout = '15m0s' # Default
```

SessionTimeout determines the amount of idle time to elapse before session cookies expire. This signs out GUI users from their sessions.

### QueryTimeout
[Image: copy to clipboard]
```toml
QueryTimeout = '2m0s' # Default
```

QueryTimeout defines how long queries should wait before timing out, defined in seconds

### BaseUserAttr
[Image: copy to clipboard]
```toml
BaseUserAttr = 'uid' # Default
```

BaseUserAttr defines the base attribute used to populate LDAP queries such as "uid=$", default is example

### BaseDN
[Image: copy to clipboard]
```toml
BaseDN = 'dc=custom,dc=example,dc=com' # Example
```

BaseDN defines the base LDAP 'dn' search filter to apply to every LDAP query, replace example,com with the appropriate LDAP server's structure

### UsersDN
[Image: copy to clipboard]
```toml
UsersDN = 'ou=users' # Default
```

UsersDN defines the 'dn' query to use when querying for the 'users' 'ou' group

### GroupsDN
[Image: copy to clipboard]
```toml
GroupsDN = 'ou=groups' # Default
```

GroupsDN defines the 'dn' query to use when querying for the 'groups' 'ou' group

### ActiveAttribute
[Image: copy to clipboard]
```toml
ActiveAttribute = '' # Default
```

ActiveAttribute is an optional user field to check truthiness for if a user is valid/active. This is only required if the LDAP provider lists inactive users as members of groups

### ActiveAttributeAllowedValue
[Image: copy to clipboard]
```toml
ActiveAttributeAllowedValue = '' # Default
```

ActiveAttributeAllowedValue is the value to check against for the above optional user attribute

### AdminUserGroupCN
[Image: copy to clipboard]
```toml
AdminUserGroupCN = 'NodeAdmins' # Default
```

AdminUserGroupCN is the LDAP 'cn' of the LDAP group that maps the core node's 'Admin' role

### EditUserGroupCN
[Image: copy to clipboard]
```toml
EditUserGroupCN = 'NodeEditors' # Default
```

EditUserGroupCN is the LDAP 'cn' of the LDAP group that maps the core node's 'Edit' role

### RunUserGroupCN
[Image: copy to clipboard]
```toml
RunUserGroupCN = 'NodeRunners' # Default
```

RunUserGroupCN is the LDAP 'cn' of the LDAP group that maps the core node's 'Run' role

### ReadUserGroupCN
[Image: copy to clipboard]
```toml
ReadUserGroupCN = 'NodeReadOnly' # Default
```

ReadUserGroupCN is the LDAP 'cn' of the LDAP group that maps the core node's 'Read' role

### UserApiTokenEnabled
[Image: copy to clipboard]
```toml
UserApiTokenEnabled = false # Default
```

UserApiTokenEnabled enables the users to issue API tokens with the same access of their role

### UserAPITokenDuration
[Image: copy to clipboard]
```toml
UserAPITokenDuration = '240h0m0s' # Default
```

UserAPITokenDuration is the duration of time an API token is active for before expiring

### UpstreamSyncInterval
[Image: copy to clipboard]
```toml
UpstreamSyncInterval = '0s' # Default
```

UpstreamSyncInterval is the interval at which the background LDAP sync task will be called. A '0s' value disables the background sync being run on an interval. This check is already performed during login/logout actions, all sessions and API tokens stored in the local ldap tables are updated to match the remote server

### UpstreamSyncRateLimit
[Image: copy to clipboard]
```toml
UpstreamSyncRateLimit = '2m0s' # Default
```

UpstreamSyncRateLimit defines a duration to limit the number of query/API calls to the upstream LDAP provider. It prevents the sync functionality from being called multiple times within the defined duration

## WebServer.RateLimit
[Image: copy to clipboard]
```toml
[WebServer.RateLimit]
Authenticated = 1000 # Default
AuthenticatedPeriod = '1m' # Default
Unauthenticated = 5 # Default
UnauthenticatedPeriod = '20s' # Default
```

### Authenticated
[Image: copy to clipboard]
```toml
Authenticated = 1000 # Default
```

Authenticated defines the threshold to which authenticated requests get limited. More than this many authenticated requests per AuthenticatedRateLimitPeriod will be rejected.

### AuthenticatedPeriod
[Image: copy to clipboard]
```toml
AuthenticatedPeriod = '1m' # Default
```

AuthenticatedPeriod defines the period to which authenticated requests get limited.

### Unauthenticated
[Image: copy to clipboard]
```toml
Unauthenticated = 5 # Default
```

Unauthenticated defines the threshold to which authenticated requests get limited. More than this many unauthenticated requests per UnAuthenticatedRateLimitPeriod will be rejected.

### UnauthenticatedPeriod
[Image: copy to clipboard]
```toml
UnauthenticatedPeriod = '20s' # Default
```

UnauthenticatedPeriod defines the period to which unauthenticated requests get limited.

## WebServer.MFA
[Image: copy to clipboard]
```toml
[WebServer.MFA]
RPID = 'localhost' # Example
RPOrigin = 'http://localhost:6688/' # Example
```

The Operator UI frontend supports enabling Multi Factor Authentication via Webauthn per account. When enabled, logging in will require the account password and a hardware or OS security key such as Yubikey. To enroll, log in to the operator UI and click the circle purple profile button at the top right and then click Register MFA Token. Tap your hardware security key or use the OS public key management feature to enroll a key. Next time you log in, this key will be required to authenticate.

### RPID
[Image: copy to clipboard]
```toml
RPID = 'localhost' # Example
```

RPID is the FQDN of where the Operator UI is served. When serving locally, the value should be localhost.

### RPOrigin
[Image: copy to clipboard]
```toml
RPOrigin = 'http://localhost:6688/' # Example
```

RPOrigin is the origin URL where WebAuthn requests initiate, including scheme and port. When serving locally, the value should be http://localhost:6688/.

## WebServer.TLS
[Image: copy to clipboard]
```toml
[WebServer.TLS]
CertPath = '~/.cl/certs' # Example
Host = 'tls-host' # Example
KeyPath = '/home/$USER/.chainlink/tls/server.key' # Example
HTTPSPort = 6689 # Default
ForceRedirect = false # Default
ListenIP = '0.0.0.0' # Default
```

The TLS settings apply only if you want to enable TLS security on your Chainlink node.

### CertPath
[Image: copy to clipboard]
```toml
CertPath = '~/.cl/certs' # Example
```

CertPath is the location of the TLS certificate file.

### Host
[Image: copy to clipboard]
```toml
Host = 'tls-host' # Example
```

Host is the hostname configured for TLS to be used by the Chainlink node. This is useful if you configured a domain name specific for your Chainlink node.

### KeyPath
[Image: copy to clipboard]
```toml
KeyPath = '/home/$USER/.chainlink/tls/server.key' # Example
```

KeyPath is the location of the TLS private key file.

### HTTPSPort
[Image: copy to clipboard]
```toml
HTTPSPort = 6689 # Default
```

HTTPSPort is the port used for HTTPS connections. Set this to 0 to disable HTTPS. Disabling HTTPS also relieves Chainlink nodes of the requirement for a TLS certificate.

### ForceRedirect
[Image: copy to clipboard]
```toml
ForceRedirect = false # Default
```

ForceRedirect forces TLS redirect for unencrypted connections.

### ListenIP
[Image: copy to clipboard]
```toml
ListenIP = '0.0.0.0' # Default
```

ListenIP specifies the IP to bind the HTTPS server to

## JobPipeline
[Image: copy to clipboard]
```toml
[JobPipeline]
ExternalInitiatorsEnabled = false # Default
MaxRunDuration = '10m' # Default
MaxSuccessfulRuns = 10000 # Default
ReaperInterval = '1h' # Default
ReaperThreshold = '24h' # Default
ResultWriteQueueDepth = 100 # Default
VerboseLogging = true # Default
```

### ExternalInitiatorsEnabled
[Image: copy to clipboard]
```toml
ExternalInitiatorsEnabled = false # Default
```

ExternalInitiatorsEnabled enables the External Initiator feature. If disabled, webhook jobs can ONLY be initiated by a logged-in user. If enabled, webhook jobs can be initiated by a whitelisted external initiator.

### MaxRunDuration
[Image: copy to clipboard]
```toml
MaxRunDuration = '10m' # Default
```

MaxRunDuration is the maximum time allowed for a single job run. If it takes longer, it will exit early and be marked errored. If set to zero, disables the time limit completely.

### MaxSuccessfulRuns
[Image: copy to clipboard]
```toml
MaxSuccessfulRuns = 10000 # Default
```

MaxSuccessfulRuns caps the number of completed successful runs per pipeline
spec in the database. You can set it to zero as a performance optimisation;
this will avoid saving any successful run.

Note this is not a hard cap, it can drift slightly larger than this but not
by more than 5% or so.

### ReaperInterval
[Image: copy to clipboard]
```toml
ReaperInterval = '1h' # Default
```

ReaperInterval controls how often the job pipeline reaper will run to delete completed jobs older than ReaperThreshold, in order to keep database size manageable.

Set to 0 to disable the periodic reaper.

### ReaperThreshold
[Image: copy to clipboard]
```toml
ReaperThreshold = '24h' # Default
```

ReaperThreshold determines the age limit for job runs. Completed job runs older than this will be automatically purged from the database.

### ResultWriteQueueDepth
[Image: caution]caution

ADVANCED:Do not change this setting unless you know what you are doing..asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }[Image: copy to clipboard]
```toml
ResultWriteQueueDepth = 100 # Default
```

ResultWriteQueueDepth controls how many writes will be buffered before subsequent writes are dropped, for jobs that write results asynchronously for performance reasons, such as OCR.

### VerboseLogging
[Image: copy to clipboard]
```toml
VerboseLogging = true # Default
```

VerboseLogging enables detailed logging of pipeline execution steps.
This can be useful for debugging failed runs without relying on the UI
or database.

You may disable if this results in excessive log volume.

## JobPipeline.HTTPRequest
[Image: copy to clipboard]
```toml
[JobPipeline.HTTPRequest]
DefaultTimeout = '15s' # Default
MaxSize = '32768' # Default
```

### DefaultTimeout
[Image: copy to clipboard]
```toml
DefaultTimeout = '15s' # Default
```

DefaultTimeout defines the default timeout for HTTP requests made by http and bridge adapters.

### MaxSize
[Image: copy to clipboard]
```toml
MaxSize = '32768' # Default
```

MaxSize defines the maximum size for HTTP requests and responses made by http and bridge adapters.

## FluxMonitor
[Image: copy to clipboard]
```toml
[FluxMonitor]
DefaultTransactionQueueDepth = 1 # Default
SimulateTransactions = false # Default
```

### DefaultTransactionQueueDepth
[Image: caution]caution

ADVANCED:Do not change this setting unless you know what you are doing..asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }[Image: copy to clipboard]
```toml
DefaultTransactionQueueDepth = 1 # Default
```

DefaultTransactionQueueDepth controls the queue size for DropOldestStrategy in Flux Monitor. Set to 0 to use SendEvery strategy instead.

### SimulateTransactions
[Image: copy to clipboard]
```toml
SimulateTransactions = false # Default
```

SimulateTransactions enables transaction simulation for Flux Monitor.

## OCR2
[Image: copy to clipboard]
```toml
[OCR2]
Enabled = false # Default
ContractConfirmations = 3 # Default
BlockchainTimeout = '20s' # Default
ContractPollInterval = '1m' # Default
ContractSubscribeInterval = '2m' # Default
ContractTransmitterTransmitTimeout = '10s' # Default
DatabaseTimeout = '10s' # Default
KeyBundleID = '7a5f66bbe6594259325bf2b4f5b1a9c900000000000000000000000000000000' # Example
CaptureEATelemetry = false # Default
CaptureAutomationCustomTelemetry = true # Default
AllowNoBootstrappers = false # Default
DefaultTransactionQueueDepth = 1 # Default
SimulateTransactions = false # Default
TraceLogging = false # Default
```

### Enabled
[Image: copy to clipboard]
```toml
Enabled = false # Default
```

Enabled enables OCR2 jobs.

### ContractConfirmations
[Image: copy to clipboard]
```toml
ContractConfirmations = 3 # Default
```

ContractConfirmations is the number of block confirmations to wait for before enacting an on-chain
configuration change. This value doesn't need to be very high (in
particular, it does not need to protect against malicious re-orgs).
Since configuration changes create some overhead, and mini-reorgs
are fairly common, recommended values are between two and ten.

Malicious re-orgs are not any more of concern here than they are in
blockchain applications in general: Since nodes check the contract for the
latest config every ContractConfigTrackerPollInterval.Seconds(), they will
come to a common view of the current config within any interval longer than
that, as long as the latest setConfig transaction in the longest chain is
stable. They will thus be able to continue reporting after the poll
interval, unless an adversary is able to repeatedly re-org the transaction
out during every poll interval, which would amount to the capability to
censor any transaction.

Note that 1 confirmation implies that the transaction/event has been mined in one block.
0 confirmations would imply that the event would be recognised before it has even been mined, which is not currently supported.
e.g.
Current block height: 42
Changed in block height: 43
Contract config confirmations: 1
STILL PENDING

Current block height: 43
Changed in block height: 43
Contract config confirmations: 1
CONFIRMED

### BlockchainTimeout
[Image: copy to clipboard]
```toml
BlockchainTimeout = '20s' # Default
```

BlockchainTimeout is the timeout for blockchain queries (mediated through
ContractConfigTracker and ContractTransmitter).
(This is necessary because an oracle's operations are serialized, so
blocking forever on a chain interaction would break the oracle.)

### ContractPollInterval
[Image: copy to clipboard]
```toml
ContractPollInterval = '1m' # Default
```

ContractPollInterval is the polling interval at which ContractConfigTracker is queried for# updated on-chain configurations. Recommended values are between
fifteen seconds and two minutes.

### ContractSubscribeInterval
[Image: copy to clipboard]
```toml
ContractSubscribeInterval = '2m' # Default
```

ContractSubscribeInterval is the interval at which we try to establish a subscription on ContractConfigTracker
if one doesn't exist. Recommended values are between two and five minutes.

### ContractTransmitterTransmitTimeout
[Image: copy to clipboard]
```toml
ContractTransmitterTransmitTimeout = '10s' # Default
```

ContractTransmitterTransmitTimeout is the timeout for ContractTransmitter.Transmit calls.

### DatabaseTimeout
[Image: copy to clipboard]
```toml
DatabaseTimeout = '10s' # Default
```

DatabaseTimeout is the timeout for database interactions.
(This is necessary because an oracle's operations are serialized, so
blocking forever on an observation would break the oracle.)

### KeyBundleID
[Image: copy to clipboard]
```toml
KeyBundleID = '7a5f66bbe6594259325bf2b4f5b1a9c900000000000000000000000000000000' # Example
```

KeyBundleID is a sha256 hexadecimal hash identifier.

### CaptureEATelemetry
[Image: copy to clipboard]
```toml
CaptureEATelemetry = false # Default
```

CaptureEATelemetry toggles collecting extra information from External Adaptares

### CaptureAutomationCustomTelemetry
[Image: copy to clipboard]
```toml
CaptureAutomationCustomTelemetry = true # Default
```

CaptureAutomationCustomTelemetry toggles collecting automation specific telemetry

### AllowNoBootstrappers
[Image: copy to clipboard]
```toml
AllowNoBootstrappers = false # Default
```

AllowNoBootstrappers enables single-node consensus without bootstrapper nodes (i.e. f=0, n=1)

### DefaultTransactionQueueDepth
[Image: copy to clipboard]
```toml
DefaultTransactionQueueDepth = 1 # Default
```

DefaultTransactionQueueDepth controls the queue size for DropOldestStrategy in OCR2. Set to 0 to use SendEvery strategy instead.

### SimulateTransactions
[Image: copy to clipboard]
```toml
SimulateTransactions = false # Default
```

SimulateTransactions enables transaction simulation for OCR2.

### TraceLogging
[Image: copy to clipboard]
```toml
TraceLogging = false # Default
```

TraceLogging enables trace level logging.

## OCR
[Image: copy to clipboard]
```toml
[OCR]
Enabled = false # Default
ObservationTimeout = '5s' # Default
BlockchainTimeout = '20s' # Default
ContractPollInterval = '1m' # Default
ContractSubscribeInterval = '2m' # Default
DefaultTransactionQueueDepth = 1 # Default
KeyBundleID = 'acdd42797a8b921b2910497badc5000600000000000000000000000000000000' # Example
SimulateTransactions = false # Default
TransmitterAddress = '0xa0788FC17B1dEe36f057c42B6F373A34B014687e' # Example
CaptureEATelemetry = false # Default
TraceLogging = false # Default
ConfigLogValidation = false # Default
```

This section applies only if you are running off-chain reporting jobs.

### Enabled
[Image: copy to clipboard]
```toml
Enabled = false # Default
```

Enabled enables OCR jobs.

### ObservationTimeout
[Image: copy to clipboard]
```toml
ObservationTimeout = '5s' # Default
```

ObservationTimeout is the timeout for making observations using the DataSource.Observe method.
(This is necessary because an oracle's operations are serialized, so
blocking forever on an observation would break the oracle.)

### BlockchainTimeout
[Image: copy to clipboard]
```toml
BlockchainTimeout = '20s' # Default
```

BlockchainTimeout is the timeout for blockchain queries (mediated through
ContractConfigTracker and ContractTransmitter).
(This is necessary because an oracle's operations are serialized, so
blocking forever on a chain interaction would break the oracle.)

### ContractPollInterval
[Image: copy to clipboard]
```toml
ContractPollInterval = '1m' # Default
```

ContractPollInterval is the polling interval at which ContractConfigTracker is queried for
updated on-chain configurations. Recommended values are between
fifteen seconds and two minutes.

### ContractSubscribeInterval
[Image: copy to clipboard]
```toml
ContractSubscribeInterval = '2m' # Default
```

ContractSubscribeInterval is the interval at which we try to establish a subscription on ContractConfigTracker
if one doesn't exist. Recommended values are between two and five minutes.

### DefaultTransactionQueueDepth
[Image: caution]caution

ADVANCED:Do not change this setting unless you know what you are doing..asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }[Image: copy to clipboard]
```toml
DefaultTransactionQueueDepth = 1 # Default
```

DefaultTransactionQueueDepth controls the queue size for DropOldestStrategy in OCR. Set to 0 to use SendEvery strategy instead.

### KeyBundleID
[Image: copy to clipboard]
```toml
KeyBundleID = 'acdd42797a8b921b2910497badc5000600000000000000000000000000000000' # Example
```

KeyBundleID is the default key bundle ID to use for OCR jobs. If you have an OCR job that does not explicitly specify a key bundle ID, it will fall back to this value.

### SimulateTransactions
[Image: copy to clipboard]
```toml
SimulateTransactions = false # Default
```

SimulateTransactions enables transaction simulation for OCR.

### TransmitterAddress
[Image: copy to clipboard]
```toml
TransmitterAddress = '0xa0788FC17B1dEe36f057c42B6F373A34B014687e' # Example
```

TransmitterAddress is the default sending address to use for OCR. If you have an OCR job that does not explicitly specify a transmitter address, it will fall back to this value.

### CaptureEATelemetry
[Image: copy to clipboard]
```toml
CaptureEATelemetry = false # Default
```

CaptureEATelemetry toggles collecting extra information from External Adaptares

### TraceLogging
[Image: copy to clipboard]
```toml
TraceLogging = false # Default
```

TraceLogging enables trace level logging.

### ConfigLogValidation
[Image: copy to clipboard]
```toml
ConfigLogValidation = false # Default
```

ConfigLogValidation ensures contract configuration logs are accessible when validating OCR jobs. Enable this when using RPC providers that don't maintain complete historical logs.

## P2P
[Image: copy to clipboard]
```toml
[P2P]
IncomingMessageBufferSize = 10 # Default
OutgoingMessageBufferSize = 10 # Default
PeerID = '12D3KooWMoejJznyDuEk5aX6GvbjaG12UzeornPCBNzMRqdwrFJw' # Example
TraceLogging = false # Default
```

P2P has a versioned networking stack. Currently only [P2P.V2] is supported.
All nodes in the OCR network should share the same networking stack.

### IncomingMessageBufferSize
[Image: copy to clipboard]
```toml
IncomingMessageBufferSize = 10 # Default
```

IncomingMessageBufferSize is the per-remote number of incoming
messages to buffer. Any additional messages received on top of those
already in the queue will be dropped.

### OutgoingMessageBufferSize
[Image: copy to clipboard]
```toml
OutgoingMessageBufferSize = 10 # Default
```

OutgoingMessageBufferSize is the per-remote number of outgoing
messages to buffer. Any additional messages send on top of those
already in the queue will displace the oldest.
NOTE: OutgoingMessageBufferSize should be comfortably smaller than remote's
IncomingMessageBufferSize to give the remote enough space to process
them all in case we regained connection and now send a bunch at once

### PeerID
[Image: copy to clipboard]
```toml
PeerID = '12D3KooWMoejJznyDuEk5aX6GvbjaG12UzeornPCBNzMRqdwrFJw' # Example
```

PeerID is the default peer ID to use for OCR jobs. If unspecified, uses the first available peer ID.

### TraceLogging
[Image: copy to clipboard]
```toml
TraceLogging = false # Default
```

TraceLogging enables trace level logging.

## P2P.V2
[Image: copy to clipboard]
```toml
[P2P.V2]
Enabled = true # Default
AnnounceAddresses = ['1.2.3.4:9999', '[a52d:0:a88:1274::abcd]:1337'] # Example
DefaultBootstrappers = ['12D3KooWMHMRLQkgPbFSYHwD3NBuwtS1AmxhvKVUrcfyaGDASR4U@1.2.3.4:9999', '12D3KooWM55u5Swtpw9r8aFLQHEtw7HR4t44GdNs654ej5gRs2Dh@example.com:1234'] # Example
DeltaDial = '15s' # Default
DeltaReconcile = '1m' # Default
ListenAddresses = ['1.2.3.4:9999', '[a52d:0:a88:1274::abcd]:1337'] # Example
```

### Enabled
[Image: copy to clipboard]
```toml
Enabled = true # Default
```

Enabled enables P2P V2.
Note: V1.Enabled is true by default, so it must be set false in order to run V2 only.

### AnnounceAddresses
[Image: copy to clipboard]
```toml
AnnounceAddresses = ['1.2.3.4:9999', '[a52d:0:a88:1274::abcd]:1337'] # Example
```

AnnounceAddresses is the addresses the peer will advertise on the network in host:port form as accepted by the TCP version of Go’s net.Dial.
The addresses should be reachable by other nodes on the network. When attempting to connect to another node,
a node will attempt to dial all of the other node’s AnnounceAddresses in round-robin fashion.

### DefaultBootstrappers
[Image: copy to clipboard]
```toml
DefaultBootstrappers = ['12D3KooWMHMRLQkgPbFSYHwD3NBuwtS1AmxhvKVUrcfyaGDASR4U@1.2.3.4:9999', '12D3KooWM55u5Swtpw9r8aFLQHEtw7HR4t44GdNs654ej5gRs2Dh@example.com:1234'] # Example
```

DefaultBootstrappers is the default bootstrapper peers for libocr's v2 networking stack.

Oracle nodes typically only know each other’s PeerIDs, but not their hostnames, IP addresses, or ports.
DefaultBootstrappers are special nodes that help other nodes discover each other’s AnnounceAddresses so they can communicate.
Nodes continuously attempt to connect to bootstrappers configured in here. When a node wants to connect to another node
(which it knows only by PeerID, but not by address), it discovers the other node’s AnnounceAddresses from communications
received from its DefaultBootstrappers or other discovered nodes. To facilitate discovery,
nodes will regularly broadcast signed announcements containing their PeerID and AnnounceAddresses.

### DeltaDial
[Image: copy to clipboard]
```toml
DeltaDial = '15s' # Default
```

DeltaDial controls how far apart Dial attempts are

### DeltaReconcile
[Image: copy to clipboard]
```toml
DeltaReconcile = '1m' # Default
```

DeltaReconcile controls how often a Reconcile message is sent to every peer.

### ListenAddresses
[Image: copy to clipboard]
```toml
ListenAddresses = ['1.2.3.4:9999', '[a52d:0:a88:1274::abcd]:1337'] # Example
```

ListenAddresses is the addresses the peer will listen to on the network in host:port form as accepted by net.Listen(),
but the host and port must be fully specified and cannot be empty. You can specify 0.0.0.0 (IPv4) or :: (IPv6) to listen on all interfaces, but that is not recommended.

## Capabilities.RateLimit
[Image: copy to clipboard]
```toml
[Capabilities.RateLimit]
GlobalRPS = 200 # Default
GlobalBurst = 200 # Default
PerSenderRPS = 200 # Default
PerSenderBurst = 200 # Default
```

### GlobalRPS
[Image: copy to clipboard]
```toml
GlobalRPS = 200 # Default
```

GlobalRPS is the global rate limit for the dispatcher.

### GlobalBurst
[Image: copy to clipboard]
```toml
GlobalBurst = 200 # Default
```

GlobalBurst is the global burst limit for the dispatcher.

### PerSenderRPS
[Image: copy to clipboard]
```toml
PerSenderRPS = 200 # Default
```

PerSenderRPS is the per-sender rate limit for the dispatcher.

### PerSenderBurst
[Image: copy to clipboard]
```toml
PerSenderBurst = 200 # Default
```

PerSenderBurst is the per-sender burst limit for the dispatcher.

## Capabilities.WorkflowRegistry
[Image: copy to clipboard]
```toml
[Capabilities.WorkflowRegistry]
Address = '0x0' # Example
NetworkID = 'evm' # Default
ChainID = '1' # Default
MaxBinarySize = '20.00mb' # Default
MaxEncryptedSecretsSize = '26.40kb' # Default
MaxConfigSize = '50.00kb' # Default
SyncStrategy = 'event' # Default
```

### Address
[Image: copy to clipboard]
```toml
Address = '0x0' # Example
```

Address is the address for the workflow registry contract.

### NetworkID
[Image: copy to clipboard]
```toml
NetworkID = 'evm' # Default
```

NetworkID identifies the target network where the remote registry is located.

### ChainID
[Image: copy to clipboard]
```toml
ChainID = '1' # Default
```

ChainID identifies the target chain id where the remote registry is located.

### MaxBinarySize
[Image: copy to clipboard]
```toml
MaxBinarySize = '20.00mb' # Default
```

MaxBinarySize is the maximum size of a binary that can be fetched from the registry.

### MaxEncryptedSecretsSize
[Image: copy to clipboard]
```toml
MaxEncryptedSecretsSize = '26.40kb' # Default
```

MaxEncryptedSecretsSize is the maximum size of encrypted secrets that can be fetched from the given secrets url.

### MaxConfigSize
[Image: copy to clipboard]
```toml
MaxConfigSize = '50.00kb' # Default
```

MaxConfigSize is the maximum size of a config that can be fetched from the given config url.

### SyncStrategy
[Image: copy to clipboard]
```toml
SyncStrategy = 'event' # Default
```

SyncStrategy is the strategy that will be used to bring the node up to date with the latest Workflow Registry contract state.
Options are: event which watches for contract events or reconciliation which diffs workflow metadata state.

## Workflows
[Image: copy to clipboard]
```toml
[Workflows]
```

## Workflows.Limits
[Image: copy to clipboard]
```toml
[Workflows.Limits]
Global = 200 # Default
PerOwner = 200 # Default
```

### Global
[Image: copy to clipboard]
```toml
Global = 200 # Default
```

Global is the maximum number of workflows that can be registered globally.

### PerOwner
[Image: copy to clipboard]
```toml
PerOwner = 200 # Default
```

PerOwner is the maximum number of workflows that can be registered per owner.

## Capabilities.ExternalRegistry
[Image: copy to clipboard]
```toml
[Capabilities.ExternalRegistry]
Address = '0x0' # Example
NetworkID = 'evm' # Default
ChainID = '1' # Default
```

### Address
[Image: copy to clipboard]
```toml
Address = '0x0' # Example
```

Address is the address for the capabilities registry contract.

### NetworkID
[Image: copy to clipboard]
```toml
NetworkID = 'evm' # Default
```

NetworkID identifies the target network where the remote registry is located.

### ChainID
[Image: copy to clipboard]
```toml
ChainID = '1' # Default
```

ChainID identifies the target chain id where the remote registry is located.

## Capabilities.Dispatcher
[Image: copy to clipboard]
```toml
[Capabilities.Dispatcher]
SupportedVersion = 1 # Default
ReceiverBufferSize = 10000 # Default
```

### SupportedVersion
[Image: copy to clipboard]
```toml
SupportedVersion = 1 # Default
```

SupportedVersion is the version of the version of message schema.

### ReceiverBufferSize
[Image: copy to clipboard]
```toml
ReceiverBufferSize = 10000 # Default
```

ReceiverBufferSize is the size of the buffer for incoming messages.

## Capabilities.Dispatcher.RateLimit
[Image: copy to clipboard]
```toml
[Capabilities.Dispatcher.RateLimit]
GlobalRPS = 800 # Default
GlobalBurst = 1000 # Default
PerSenderRPS = 10 # Default
PerSenderBurst = 50 # Default
```

### GlobalRPS
[Image: copy to clipboard]
```toml
GlobalRPS = 800 # Default
```

GlobalRPS is the global rate limit for the dispatcher.

### GlobalBurst
[Image: copy to clipboard]
```toml
GlobalBurst = 1000 # Default
```

GlobalBurst is the global burst limit for the dispatcher.

### PerSenderRPS
[Image: copy to clipboard]
```toml
PerSenderRPS = 10 # Default
```

PerSenderRPS is the per-sender rate limit for the dispatcher.

### PerSenderBurst
[Image: copy to clipboard]
```toml
PerSenderBurst = 50 # Default
```

PerSenderBurst is the per-sender burst limit for the dispatcher.

## Capabilities.Peering
[Image: copy to clipboard]
```toml
[Capabilities.Peering]
IncomingMessageBufferSize = 10 # Default
OutgoingMessageBufferSize = 10 # Default
PeerID = '12D3KooWMoejJznyDuEk5aX6GvbjaG12UzeornPCBNzMRqdwrFJw' # Example
TraceLogging = false # Default
```

### IncomingMessageBufferSize
[Image: copy to clipboard]
```toml
IncomingMessageBufferSize = 10 # Default
```

IncomingMessageBufferSize is the per-remote number of incoming
messages to buffer. Any additional messages received on top of those
already in the queue will be dropped.

### OutgoingMessageBufferSize
[Image: copy to clipboard]
```toml
OutgoingMessageBufferSize = 10 # Default
```

OutgoingMessageBufferSize is the per-remote number of outgoing
messages to buffer. Any additional messages send on top of those
already in the queue will displace the oldest.
NOTE: OutgoingMessageBufferSize should be comfortably smaller than remote's
IncomingMessageBufferSize to give the remote enough space to process
them all in case we regained connection and now send a bunch at once

### PeerID
[Image: copy to clipboard]
```toml
PeerID = '12D3KooWMoejJznyDuEk5aX6GvbjaG12UzeornPCBNzMRqdwrFJw' # Example
```

PeerID is the default peer ID to use for OCR jobs. If unspecified, uses the first available peer ID.

### TraceLogging
[Image: copy to clipboard]
```toml
TraceLogging = false # Default
```

TraceLogging enables trace level logging.

## Capabilities.Peering.V2
[Image: copy to clipboard]
```toml
[Capabilities.Peering.V2]
Enabled = false # Default
AnnounceAddresses = ['1.2.3.4:9999', '[a52d:0:a88:1274::abcd]:1337'] # Example
DefaultBootstrappers = ['12D3KooWMHMRLQkgPbFSYHwD3NBuwtS1AmxhvKVUrcfyaGDASR4U@1.2.3.4:9999', '12D3KooWM55u5Swtpw9r8aFLQHEtw7HR4t44GdNs654ej5gRs2Dh@example.com:1234'] # Example
DeltaDial = '15s' # Default
DeltaReconcile = '1m' # Default
ListenAddresses = ['1.2.3.4:9999', '[a52d:0:a88:1274::abcd]:1337'] # Example
```

### Enabled
[Image: copy to clipboard]
```toml
Enabled = false # Default
```

Enabled enables P2P V2.

### AnnounceAddresses
[Image: copy to clipboard]
```toml
AnnounceAddresses = ['1.2.3.4:9999', '[a52d:0:a88:1274::abcd]:1337'] # Example
```

AnnounceAddresses is the addresses the peer will advertise on the network in host:port form as accepted by the TCP version of Go’s net.Dial.
The addresses should be reachable by other nodes on the network. When attempting to connect to another node,
a node will attempt to dial all of the other node’s AnnounceAddresses in round-robin fashion.

### DefaultBootstrappers
[Image: copy to clipboard]
```toml
DefaultBootstrappers = ['12D3KooWMHMRLQkgPbFSYHwD3NBuwtS1AmxhvKVUrcfyaGDASR4U@1.2.3.4:9999', '12D3KooWM55u5Swtpw9r8aFLQHEtw7HR4t44GdNs654ej5gRs2Dh@example.com:1234'] # Example
```

DefaultBootstrappers is the default bootstrapper peers for libocr's v2 networking stack.

Oracle nodes typically only know each other’s PeerIDs, but not their hostnames, IP addresses, or ports.
DefaultBootstrappers are special nodes that help other nodes discover each other’s AnnounceAddresses so they can communicate.
Nodes continuously attempt to connect to bootstrappers configured in here. When a node wants to connect to another node
(which it knows only by PeerID, but not by address), it discovers the other node’s AnnounceAddresses from communications
received from its DefaultBootstrappers or other discovered nodes. To facilitate discovery,
nodes will regularly broadcast signed announcements containing their PeerID and AnnounceAddresses.

### DeltaDial
[Image: copy to clipboard]
```toml
DeltaDial = '15s' # Default
```

DeltaDial controls how far apart Dial attempts are

### DeltaReconcile
[Image: copy to clipboard]
```toml
DeltaReconcile = '1m' # Default
```

DeltaReconcile controls how often a Reconcile message is sent to every peer.

### ListenAddresses
[Image: copy to clipboard]
```toml
ListenAddresses = ['1.2.3.4:9999', '[a52d:0:a88:1274::abcd]:1337'] # Example
```

ListenAddresses is the addresses the peer will listen to on the network in host:port form as accepted by net.Listen(),
but the host and port must be fully specified and cannot be empty. You can specify 0.0.0.0 (IPv4) or :: (IPv6) to listen on all interfaces, but that is not recommended.

## Capabilities.GatewayConnector
[Image: copy to clipboard]
```toml
[Capabilities.GatewayConnector]
ChainIDForNodeKey = '11155111' # Example
NodeAddress = '0x68902d681c28119f9b2531473a417088bf008e59' # Example
DonID = 'example_don' # Example
WSHandshakeTimeoutMillis = 1000 # Example
AuthMinChallengeLen = 10 # Example
AuthTimestampToleranceSec = 10 # Example
```

### ChainIDForNodeKey
[Image: copy to clipboard]
```toml
ChainIDForNodeKey = '11155111' # Example
```

ChainIDForNodeKey is the ChainID of the network associated with a private key to be used for authentication with Gateway nodes

### NodeAddress
[Image: copy to clipboard]
```toml
NodeAddress = '0x68902d681c28119f9b2531473a417088bf008e59' # Example
```

NodeAddress is the address of the desired private key to be used for authentication with Gateway nodes

### DonID
[Image: copy to clipboard]
```toml
DonID = 'example_don' # Example
```

DonID is the Id of the Don

### WSHandshakeTimeoutMillis
[Image: copy to clipboard]
```toml
WSHandshakeTimeoutMillis = 1000 # Example
```

WSHandshakeTimeoutMillis is Websocket handshake timeout

### AuthMinChallengeLen
[Image: copy to clipboard]
```toml
AuthMinChallengeLen = 10 # Example
```

AuthMinChallengeLen is the minimum number of bytes in authentication challenge payload

### AuthTimestampToleranceSec
[Image: copy to clipboard]
```toml
AuthTimestampToleranceSec = 10 # Example
```

AuthTimestampToleranceSec is Authentication timestamp tolerance

## Capabilities.GatewayConnector.Gateways
[Image: copy to clipboard]
```toml
[[Capabilities.GatewayConnector.Gateways]]
ID = 'example_gateway' # Example
URL = 'wss://localhost:8081/node' # Example
```

### ID
[Image: copy to clipboard]
```toml
ID = 'example_gateway' # Example
```

ID of the Gateway

### URL
[Image: copy to clipboard]
```toml
URL = 'wss://localhost:8081/node' # Example
```

URL of the Gateway

## Keeper
[Image: copy to clipboard]
```toml
[Keeper]
DefaultTransactionQueueDepth = 1 # Default
GasPriceBufferPercent = 20 # Default
GasTipCapBufferPercent = 20 # Default
BaseFeeBufferPercent = 20 # Default
MaxGracePeriod = 100 # Default
TurnLookBack = 1_000 # Default
```

### DefaultTransactionQueueDepth
[Image: caution]caution

ADVANCED:Do not change this setting unless you know what you are doing..asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }[Image: copy to clipboard]
```toml
DefaultTransactionQueueDepth = 1 # Default
```

DefaultTransactionQueueDepth controls the queue size for DropOldestStrategy in Keeper. Set to 0 to use SendEvery strategy instead.

### GasPriceBufferPercent
[Image: caution]caution

ADVANCED:Do not change this setting unless you know what you are doing..asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }[Image: copy to clipboard]
```toml
GasPriceBufferPercent = 20 # Default
```

GasPriceBufferPercent specifies the percentage to add to the gas price used for checking whether to perform an upkeep. Only applies in legacy mode (EIP-1559 off).

### GasTipCapBufferPercent
[Image: caution]caution

ADVANCED:Do not change this setting unless you know what you are doing..asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }[Image: copy to clipboard]
```toml
GasTipCapBufferPercent = 20 # Default
```

GasTipCapBufferPercent specifies the percentage to add to the gas price used for checking whether to perform an upkeep. Only applies in EIP-1559 mode.

### BaseFeeBufferPercent
[Image: caution]caution

ADVANCED:Do not change this setting unless you know what you are doing..asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }[Image: copy to clipboard]
```toml
BaseFeeBufferPercent = 20 # Default
```

BaseFeeBufferPercent specifies the percentage to add to the base fee used for checking whether to perform an upkeep. Applies only in EIP-1559 mode.

### MaxGracePeriod
[Image: caution]caution

ADVANCED:Do not change this setting unless you know what you are doing..asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }[Image: copy to clipboard]
```toml
MaxGracePeriod = 100 # Default
```

MaxGracePeriod is the maximum number of blocks that a keeper will wait after performing an upkeep before it resumes checking that upkeep

### TurnLookBack
[Image: copy to clipboard]
```toml
TurnLookBack = 1_000 # Default
```

TurnLookBack is the number of blocks in the past to look back when getting a block for a turn.

## Keeper.Registry
[Image: copy to clipboard]
```toml
[Keeper.Registry]
CheckGasOverhead = 200_000 # Default
PerformGasOverhead = 300_000 # Default
SyncInterval = '30m' # Default
MaxPerformDataSize = 5_000 # Default
SyncUpkeepQueueSize = 10 # Default
```

### CheckGasOverhead
[Image: caution]caution

ADVANCED:Do not change this setting unless you know what you are doing..asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }[Image: copy to clipboard]
```toml
CheckGasOverhead = 200_000 # Default
```

CheckGasOverhead is the amount of extra gas to provide checkUpkeep() calls to account for the gas consumed by the keeper registry.

### PerformGasOverhead
[Image: caution]caution

ADVANCED:Do not change this setting unless you know what you are doing..asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }[Image: copy to clipboard]
```toml
PerformGasOverhead = 300_000 # Default
```

PerformGasOverhead is the amount of extra gas to provide performUpkeep() calls to account for the gas consumed by the keeper registry

### SyncInterval
[Image: caution]caution

ADVANCED:Do not change this setting unless you know what you are doing..asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }[Image: copy to clipboard]
```toml
SyncInterval = '30m' # Default
```

SyncInterval is the interval in which the RegistrySynchronizer performs a full sync of the keeper registry contract it is tracking.

### MaxPerformDataSize
[Image: caution]caution

ADVANCED:Do not change this setting unless you know what you are doing..asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }[Image: copy to clipboard]
```toml
MaxPerformDataSize = 5_000 # Default
```

MaxPerformDataSize is the max size of perform data.

### SyncUpkeepQueueSize
[Image: caution]caution

ADVANCED:Do not change this setting unless you know what you are doing..asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }[Image: copy to clipboard]
```toml
SyncUpkeepQueueSize = 10 # Default
```

SyncUpkeepQueueSize represents the maximum number of upkeeps that can be synced in parallel.

## AutoPprof
[Image: copy to clipboard]
```toml
[AutoPprof]
Enabled = false # Default
ProfileRoot = 'prof/root' # Example
PollInterval = '10s' # Default
GatherDuration = '10s' # Default
GatherTraceDuration = '5s' # Default
MaxProfileSize = '100mb' # Default
CPUProfileRate = 1 # Default
MemProfileRate = 1 # Default
BlockProfileRate = 1 # Default
MutexProfileFraction = 1 # Default
MemThreshold = '4gb' # Default
GoroutineThreshold = 5000 # Default
```

The Chainlink node is equipped with an internal "nurse" service that can perform automatic pprof profiling when the certain resource thresholds are exceeded, such as memory and goroutine count. These profiles are saved to disk to facilitate fine-grained debugging of performance-related issues. In general, if you notice that your node has begun to accumulate profiles, forward them to the Chainlink team.

To learn more about these profiles, read the Profiling Go programs with pprof guide.

### Enabled
[Image: copy to clipboard]
```toml
Enabled = false # Default
```

Enabled enables the automatic profiling service.

### ProfileRoot
[Image: copy to clipboard]
```toml
ProfileRoot = 'prof/root' # Example
```

ProfileRoot sets the location on disk where pprof profiles will be stored. Defaults to RootDir.

### PollInterval
[Image: copy to clipboard]
```toml
PollInterval = '10s' # Default
```

PollInterval is the interval at which the node's resources are checked.

### GatherDuration
[Image: copy to clipboard]
```toml
GatherDuration = '10s' # Default
```

GatherDuration is the duration for which profiles are gathered when profiling starts.

### GatherTraceDuration
[Image: copy to clipboard]
```toml
GatherTraceDuration = '5s' # Default
```

GatherTraceDuration is the duration for which traces are gathered when profiling is kicked off. This is separately configurable because traces are significantly larger than other types of profiles.

### MaxProfileSize
[Image: copy to clipboard]
```toml
MaxProfileSize = '100mb' # Default
```

MaxProfileSize is the maximum amount of disk space that profiles may consume before profiling is disabled.

### CPUProfileRate
[Image: copy to clipboard]
```toml
CPUProfileRate = 1 # Default
```

CPUProfileRate sets the rate for CPU profiling. See https://pkg.go.dev/runtime#SetCPUProfileRate.

### MemProfileRate
[Image: copy to clipboard]
```toml
MemProfileRate = 1 # Default
```

MemProfileRate sets the rate for memory profiling. See https://pkg.go.dev/runtime#pkg-variables.

### BlockProfileRate
[Image: copy to clipboard]
```toml
BlockProfileRate = 1 # Default
```

BlockProfileRate sets the fraction of blocking events for goroutine profiling. See https://pkg.go.dev/runtime#SetBlockProfileRate.

### MutexProfileFraction
[Image: copy to clipboard]
```toml
MutexProfileFraction = 1 # Default
```

MutexProfileFraction sets the fraction of contention events for mutex profiling. See https://pkg.go.dev/runtime#SetMutexProfileFraction.

### MemThreshold
[Image: copy to clipboard]
```toml
MemThreshold = '4gb' # Default
```

MemThreshold sets the maximum amount of memory the node can actively consume before profiling begins.

### GoroutineThreshold
[Image: copy to clipboard]
```toml
GoroutineThreshold = 5000 # Default
```

GoroutineThreshold is the maximum number of actively-running goroutines the node can spawn before profiling begins.

## Pyroscope
[Image: copy to clipboard]
```toml
[Pyroscope]
ServerAddress = 'http://localhost:4040' # Example
Environment = 'mainnet' # Default
```

### ServerAddress
[Image: copy to clipboard]
```toml
ServerAddress = 'http://localhost:4040' # Example
```

ServerAddress sets the address that will receive the profile logs. It enables the profiling service.

### Environment
[Image: copy to clipboard]
```toml
Environment = 'mainnet' # Default
```

Environment sets the target environment tag in which profiles will be added to.

## Sentry
[Image: copy to clipboard]
```toml
[Sentry]
Debug = false # Default
DSN = 'sentry-dsn' # Example
Environment = 'my-custom-env' # Example
Release = 'v1.2.3' # Example
```

### Debug
[Image: caution]caution

ADVANCED:Do not change this setting unless you know what you are doing..asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }[Image: copy to clipboard]
```toml
Debug = false # Default
```

Debug enables printing of Sentry SDK debug messages.

### DSN
[Image: copy to clipboard]
```toml
DSN = 'sentry-dsn' # Example
```

DSN is the data source name where events will be sent. Sentry is completely disabled if this is left blank.

### Environment
[Image: copy to clipboard]
```toml
Environment = 'my-custom-env' # Example
```

Environment overrides the Sentry environment to the given value. Otherwise autodetects between dev/prod.

### Release
[Image: copy to clipboard]
```toml
Release = 'v1.2.3' # Example
```

Release overrides the Sentry release to the given value. Otherwise uses the compiled-in version number.

## Insecure
[Image: copy to clipboard]
```toml
[Insecure]
DevWebServer = false # Default
OCRDevelopmentMode = false # Default
InfiniteDepthQueries = false # Default
DisableRateLimiting = false # Default
```

Insecure config family is only allowed in development builds.

### DevWebServer
[Image: caution]caution

ADVANCED:Do not change this setting unless you know what you are doing..asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }[Image: copy to clipboard]
```toml
DevWebServer = false # Default
```

DevWebServer skips secure configuration for webserver AllowedHosts, SSL, etc.

### OCRDevelopmentMode
[Image: copy to clipboard]
```toml
OCRDevelopmentMode = false # Default
```

OCRDevelopmentMode run OCR in development mode.

### InfiniteDepthQueries
[Image: copy to clipboard]
```toml
InfiniteDepthQueries = false # Default
```

InfiniteDepthQueries skips graphql query depth limit checks.

### DisableRateLimiting
[Image: copy to clipboard]
```toml
DisableRateLimiting = false # Default
```

DisableRateLimiting skips ratelimiting on asset requests.

## Tracing
[Image: copy to clipboard]
```toml
[Tracing]
Enabled = false # Default
CollectorTarget = 'localhost:4317' # Example
NodeID = 'NodeID' # Example
SamplingRatio = 1.0 # Example
Mode = 'tls' # Default
TLSCertPath = '/path/to/cert.pem' # Example
```

### Enabled
[Image: copy to clipboard]
```toml
Enabled = false # Default
```

Enabled turns trace collection on or off. On requires an OTEL Tracing Collector.

### CollectorTarget
[Image: copy to clipboard]
```toml
CollectorTarget = 'localhost:4317' # Example
```

CollectorTarget is the logical address of the OTEL Tracing Collector.

### NodeID
[Image: copy to clipboard]
```toml
NodeID = 'NodeID' # Example
```

NodeID is an unique name for this node relative to any other node traces are collected for.

### SamplingRatio
[Image: copy to clipboard]
```toml
SamplingRatio = 1.0 # Example
```

SamplingRatio is the ratio of traces to sample for this node.

### Mode
[Image: copy to clipboard]
```toml
Mode = 'tls' # Default
```

Mode is a string value. tls or unencrypted are the only values allowed. If set to unencrypted, TLSCertPath can be unset, meaning traces will be sent over plaintext to the collector.

### TLSCertPath
[Image: copy to clipboard]
```toml
TLSCertPath = '/path/to/cert.pem' # Example
```

TLSCertPath is the file path to the TLS certificate used for secure communication with an OTEL Tracing Collector.

## Tracing.Attributes
[Image: copy to clipboard]
```toml
[Tracing.Attributes]
env = 'test' # Example
```

Tracing.Attributes are user specified key-value pairs to associate in the context of the traces

### env
[Image: copy to clipboard]
```toml
env = 'test' # Example
```

env is an example user specified key-value pair

## Mercury
[Image: copy to clipboard]
```toml
[Mercury]
VerboseLogging = false # Default
```

### VerboseLogging
[Image: copy to clipboard]
```toml
VerboseLogging = false # Default
```

VerboseLogging enables detailed logging of mercury/LLO operations. These logs
can be expensive since they may serialize large structs, so they are disabled
by default.

## Mercury.Cache
[Image: copy to clipboard]
```toml
[Mercury.Cache]
LatestReportTTL = "1s" # Default
MaxStaleAge = "1h" # Default
LatestReportDeadline = "5s" # Default
```

Mercury.Cache controls settings for the price retrieval cache querying a mercury server

### LatestReportTTL
[Image: copy to clipboard]
```toml
LatestReportTTL = "1s" # Default
```

LatestReportTTL controls how "stale" we will allow a price to be e.g. if
set to 1s, a new price will always be fetched if the last result was
from 1 second ago or older.

Another way of looking at it is such: the cache will never return a
price that was queried from now-LatestReportTTL or before.

Setting to zero disables caching entirely.

### MaxStaleAge
[Image: copy to clipboard]
```toml
MaxStaleAge = "1h" # Default
```

MaxStaleAge is that maximum amount of time that a value can be stale
before it is deleted from the cache (a form of garbage collection).

This should generally be set to something much larger than
LatestReportTTL. Setting to zero disables garbage collection.

### LatestReportDeadline
[Image: copy to clipboard]
```toml
LatestReportDeadline = "5s" # Default
```

LatestReportDeadline controls how long to wait for a response from the
mercury server before retrying. Setting this to zero will wait indefinitely.

## Mercury.TLS
[Image: copy to clipboard]
```toml
[Mercury.TLS]
CertFile = "/path/to/client/certs.pem" # Example
```

Mercury.TLS controls client settings for when the node talks to traditional web servers or load balancers.

### CertFile
[Image: copy to clipboard]
```toml
CertFile = "/path/to/client/certs.pem" # Example
```

CertFile is the path to a PEM file of trusted root certificate authority certificates

## Mercury.Transmitter
[Image: copy to clipboard]
```toml
[Mercury.Transmitter]
Protocol = "grpc" # Default
TransmitQueueMaxSize = 250_000 # Default
TransmitTimeout = "5s" # Default
TransmitConcurrency = 100 # Default
ReaperFrequency = "1h" # Default
ReaperMaxAge = "48h" # Default
```

Mercury.Transmitter controls settings for the mercury transmitter

### Protocol
[Image: copy to clipboard]
```toml
Protocol = "grpc" # Default
```

Protocol is the protocol to use for the transmitter.

Options are either:

• "wsrpc" for the legacy websocket protocol
• "grpc" for the gRPC protocol

### TransmitQueueMaxSize
[Image: copy to clipboard]
```toml
TransmitQueueMaxSize = 250_000 # Default
```

TransmitQueueMaxSize controls the size of the transmit queue. This is scoped
per OCR instance. If the queue is full, the transmitter will start dropping
the oldest messages in order to make space.

This is useful if mercury server goes offline and the nop needs to buffer
transmissions.

### TransmitTimeout
[Image: copy to clipboard]
```toml
TransmitTimeout = "5s" # Default
```

TransmitTimeout controls how long the transmitter will wait for a response
when sending a message to the mercury server, before aborting and considering
the transmission to be failed.

### TransmitConcurrency
[Image: copy to clipboard]
```toml
TransmitConcurrency = 100 # Default
```

TransmitConcurrency is the max number of concurrent transmits to each server.

Only has effect with LLO jobs.

### ReaperFrequency
[Image: copy to clipboard]
```toml
ReaperFrequency = "1h" # Default
```

ReaperFrequency controls how often the stale transmission reaper will run.
Setting to 0 disables the reaper.

### ReaperMaxAge
[Image: copy to clipboard]
```toml
ReaperMaxAge = "48h" # Default
```

ReaperMaxAge controls how old a transmission can be before it is considered
stale. Setting to 0 disables the reaper.

## Telemetry
[Image: copy to clipboard]
```toml
[Telemetry]
Enabled = false # Default
Endpoint = 'example.com/collector' # Example
CACertFile = 'cert-file' # Example
InsecureConnection = false # Default
TraceSampleRatio = 0.01 # Default
EmitterBatchProcessor = true # Default
EmitterExportTimeout = '1s' # Default
ChipIngressEndpoint = '' # Default
```

Telemetry holds OTEL settings.
This data includes open telemetry metrics, traces, & logs.
It does not currently include prometheus metrics or standard out logs, but may in the future.

### Enabled
[Image: copy to clipboard]
```toml
Enabled = false # Default
```

Enabled turns telemetry collection on or off.

### Endpoint
[Image: copy to clipboard]
```toml
Endpoint = 'example.com/collector' # Example
```

Endpoint of the OTEL Collector.

### CACertFile
[Image: copy to clipboard]
```toml
CACertFile = 'cert-file' # Example
```

CACertFile is the file path of the TLS certificate used for secure communication with the OTEL Collector.
Required unless InescureConnection is true.

### InsecureConnection
[Image: copy to clipboard]
```toml
InsecureConnection = false # Default
```

InsecureConnection bypasses the TLS CACertFile requirement and uses an insecure connection instead.
Only available in dev mode.

### TraceSampleRatio
[Image: copy to clipboard]
```toml
TraceSampleRatio = 0.01 # Default
```

TraceSampleRatio is the rate at which to sample traces. Must be between 0 and 1.

### EmitterBatchProcessor
[Image: copy to clipboard]
```toml
EmitterBatchProcessor = true # Default
```

EmitterBatchProcessor enables batching for telemetry events

### EmitterExportTimeout
[Image: copy to clipboard]
```toml
EmitterExportTimeout = '1s' # Default
```

EmitterExportTimeout sets timeout for exporting telemetry events

### ChipIngressEndpoint
[Image: copy to clipboard]
```toml
ChipIngressEndpoint = '' # Default
```

ChipIngressEndpoint enables sending custom messages to CHIP Ingress.

## Telemetry.ResourceAttributes
[Image: copy to clipboard]
```toml
[Telemetry.ResourceAttributes]
foo = "bar" # Example
```

ResourceAttributes are global metadata to include with all telemetry.

### foo
[Image: copy to clipboard]
```toml
foo = "bar" # Example
```

foo is an example resource attribute

## CRE.Streams
[Image: copy to clipboard]
```toml
[CRE.Streams]
WsURL = "streams.url" # Example
RestURL = "streams.url" # Example
```

### WsURL
[Image: copy to clipboard]
```toml
WsURL = "streams.url" # Example
```

WsURL is the websockets url for the streams sdk config

### RestURL
[Image: copy to clipboard]
```toml
RestURL = "streams.url" # Example
```

RestURL is the REST url for the streams sdk config

## Billing
[Image: copy to clipboard]
```toml
[Billing]
URL = "localhost:4319" # Default
```

Billing holds settings for connecting to the billing service.

### URL
[Image: copy to clipboard]
```toml
URL = "localhost:4319" # Default
```

URL is the locator for the Chainlink billing service.

## EVM
EVM defaults depend on ChainID:

### Ethereum Mainnet (1)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
FinalityDepth = 50
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0x514910771AF9Ca656af840dff83E8264EcF986CA'
LogBackfillBatchSize = 1000
LogPollInterval = '15s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.1 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
OperatorFactoryAddress = '0x3E64Cd889482443324F91bFA9c84fE72A511f48A'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '9m0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '5m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = true
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 4
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 50

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 10500000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Ethereum Ropsten (3)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
FinalityDepth = 50
SafeDepth = 0
FinalityTagEnabled = false
LinkContractAddress = '0x20fE562d797A42Dcb3399062AE9546cd06f63280'
LogBackfillBatchSize = 1000
LogPollInterval = '15s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.1 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = true
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 4
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 50

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Ethereum Rinkeby (4)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
FinalityDepth = 50
SafeDepth = 0
FinalityTagEnabled = false
LinkContractAddress = '0x01BE23585060835E02B77ef475b0Cc51aA1e0709'
LogBackfillBatchSize = 1000
LogPollInterval = '15s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.1 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 4
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 50

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Ethereum Goerli (5)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
FinalityDepth = 50
SafeDepth = 0
FinalityTagEnabled = false
LinkContractAddress = '0x326C977E6efc84E512bB9C30f76E30c160eD06FB'
LogBackfillBatchSize = 1000
LogPollInterval = '15s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.1 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = true
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 4
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 50

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Optimism Mainnet (10)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'optimismBedrock'
FinalityDepth = 200
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0x350a791Bfc2C21F9Ed5d10980Dad2e2638ffa7f6'
LogBackfillBatchSize = 1000
LogPollInterval = '2s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 1
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '40s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '13m0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '30s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 wei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '100 wei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = true
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 24
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[GasEstimator.DAOracle]
OracleType = 'opstack'
OracleAddress = '0x420000000000000000000000000000000000000F'

[HeadTracker]
HistoryDepth = 300
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 10
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 1
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 6500000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Ethereum Kovan (42)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
FinalityDepth = 50
SafeDepth = 0
FinalityTagEnabled = false
LinkContractAddress = '0xa36085F69e2889c224210F603D836748e7dC0088'
LogBackfillBatchSize = 1000
LogPollInterval = '15s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.1 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
OperatorFactoryAddress = '0x8007e24251b1D2Fc518Eb843A701d9cD21fe0aA3'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 4
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 50

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### BSC Mainnet (56)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
FinalityDepth = 50
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0x404460C6A5EdE2D891e8297795264fDe62ADBB75'
LogBackfillBatchSize = 1000
LogPollInterval = '3s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '30s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 2
FinalizedBlockOffset = 2
NoNewFinalizedHeadsThreshold = '45s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '100 mwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '100 mwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 5
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 24
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 10
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '2s'
DatabaseTimeout = '2s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '500ms'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### OKX Testnet (65)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
FinalityDepth = 50
SafeDepth = 0
FinalityTagEnabled = false
LogBackfillBatchSize = 1000
LogPollInterval = '15s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### OKX Mainnet (66)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
FinalityDepth = 50
SafeDepth = 0
FinalityTagEnabled = false
LogBackfillBatchSize = 1000
LogPollInterval = '15s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Astar Shibuya (81)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
FinalityDepth = 100
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0xe74037112db8807B3B4B3895F5790e5bc1866a29'
LogBackfillBatchSize = 1000
LogPollInterval = '6s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '20 gwei'
PriceMax = '100 micro'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### BSC Testnet (97)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
FinalityDepth = 50
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0x84b9B910527Ad5C03A9Ca831909E21e236EA7b06'
LogBackfillBatchSize = 1000
LogPollInterval = '3s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '30s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 2
FinalizedBlockOffset = 2
NoNewFinalizedHeadsThreshold = '40s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '1 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 5
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 24
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 10
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '2s'
DatabaseTimeout = '2s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '500ms'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Gnosis Mainnet (100)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'gnosis'
FinalityDepth = 50
SafeDepth = 0
FinalityTagEnabled = false
LinkContractAddress = '0xE2e73A1c69ecF83F464EFCE6A5be353a37cA09b2'
LogBackfillBatchSize = 1000
LogPollInterval = '5s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 2
NoNewFinalizedHeadsThreshold = '2m0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '1 gwei'
PriceMax = '500 gwei'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Shibarium Mainnet (109)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
FinalityDepth = 50
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0x71052BAe71C25C78E37fD12E5ff1101A71d9018F'
LogBackfillBatchSize = 1000
LogPollInterval = '1s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 5
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '30s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 100
RPCBlockQueryDelay = 10
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '10 gwei'
PriceMax = '10 micro'
PriceMin = '2 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 5
EIP1559DynamicFees = true
FeeCapDefault = '10 micro'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 300
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 2
PollInterval = '3s'
SelectionMode = 'HighestHead'
SyncThreshold = 10
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Heco Mainnet (128)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
FinalityDepth = 50
SafeDepth = 0
FinalityTagEnabled = false
LinkContractAddress = '0x404460C6A5EdE2D891e8297795264fDe62ADBB75'
LogBackfillBatchSize = 1000
LogPollInterval = '3s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '30s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 2
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '5 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 5
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 24
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 10
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '2s'
DatabaseTimeout = '2s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '500ms'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Hashkey Testnet (133)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'optimismBedrock'
FinalityDepth = 50
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0x8418c4d7e8e17ab90232DC72150730E6c4b84F57'
LogBackfillBatchSize = 1000
LogPollInterval = '15s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '20 gwei'
PriceMax = '1 micro'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = false
FeeCapDefault = '1 micro'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[GasEstimator.DAOracle]
OracleType = 'opstack'
OracleAddress = '0x420000000000000000000000000000000000000F'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 2
PollInterval = '8s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Polygon Mainnet (137)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
FinalityDepth = 500
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0xb0897686c545045aFc77CF20eC7A532E3120E0F1'
LogBackfillBatchSize = 1000
LogPollInterval = '1s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 5
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '30s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 100
RPCBlockQueryDelay = 10
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '6m0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 5000
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '30 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '30 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '20 gwei'
BumpPercent = 20
BumpThreshold = 5
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 24
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 2000
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 10
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Sonic Mainnet (146)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
FinalityDepth = 10
SafeDepth = 0
FinalityTagEnabled = false
LinkContractAddress = '0x71052BAe71C25C78E37fD12E5ff1101A71d9018F'
LogBackfillBatchSize = 1000
LogPollInterval = '1s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 5
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 100
RPCBlockQueryDelay = 10
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 500
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'FeeHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 10
BumpThreshold = 3
EIP1559DynamicFees = true
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 100
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '2s'

[HeadTracker]
HistoryDepth = 50
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 10
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Shibarium Testnet (157)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
FinalityDepth = 50
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0x44637eEfD71A090990f89faEC7022fc74B2969aD'
LogBackfillBatchSize = 1000
LogPollInterval = '1s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 5
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '30s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 100
RPCBlockQueryDelay = 10
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '10 gwei'
PriceMax = '10 micro'
PriceMin = '2 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 5
EIP1559DynamicFees = true
FeeCapDefault = '10 micro'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 300
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 2
PollInterval = '3s'
SelectionMode = 'HighestHead'
SyncThreshold = 10
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Hashkey Mainnet (177)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'optimismBedrock'
FinalityDepth = 50
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0x71052BAe71C25C78E37fD12E5ff1101A71d9018F'
LogBackfillBatchSize = 1000
LogPollInterval = '15s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '20 gwei'
PriceMax = '1 micro'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = false
FeeCapDefault = '1 micro'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[GasEstimator.DAOracle]
OracleType = 'opstack'
OracleAddress = '0x420000000000000000000000000000000000000F'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 2
PollInterval = '8s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### XLayer Sepolia (195)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'xlayer'
FinalityDepth = 500
SafeDepth = 0
FinalityTagEnabled = false
LinkContractAddress = '0x724593f6FCb0De4E6902d4C55D7C74DaA2AF0E55'
LogBackfillBatchSize = 1000
LogPollInterval = '30s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 1
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '12m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 100
RPCBlockQueryDelay = 15
FinalizedBlockOffset = 2
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '3m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = true
MinAttempts = 3

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 mwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '20 mwei'
BumpPercent = 40
BumpThreshold = 3
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 12
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 2000
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 1
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### XLayer Mainnet (196)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'xlayer'
FinalityDepth = 500
SafeDepth = 0
FinalityTagEnabled = false
LinkContractAddress = '0x8aF9711B44695a5A081F25AB9903DDB73aCf8FA9'
LogBackfillBatchSize = 1000
LogPollInterval = '30s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 1
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '6m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 100
RPCBlockQueryDelay = 15
FinalizedBlockOffset = 2
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '3m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = true
MinAttempts = 3

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '100 mwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '100 mwei'
BumpPercent = 40
BumpThreshold = 3
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 12
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 2000
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 1
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Bsquared Mainnet (223)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'optimismBedrock'
FinalityDepth = 2000
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0x709229D9587886a1eDFeE6b5cE636E1D70d1cE39'
LogBackfillBatchSize = 1000
LogPollInterval = '3s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '1h10m0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'FeeHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = true
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 100
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '4s'

[GasEstimator.DAOracle]
OracleType = 'opstack'
OracleAddress = '0x420000000000000000000000000000000000000F'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Mind Mainnet (228)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'arbitrum'
FinalityDepth = 50
SafeDepth = 0
FinalityTagEnabled = true
LogBackfillBatchSize = 1000
LogPollInterval = '2s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'Arbitrum'
PriceDefault = '5 mwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '0'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[GasEstimator.DAOracle]
OracleType = 'arbitrum'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 10
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Lens Mainnet (232)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'zksync'
FinalityDepth = 50
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0x2Ea38D6cDb6774992d4A62fe622f4405663729Dd'
LogBackfillBatchSize = 1000
LogPollInterval = '5s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '7m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'FeeHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 40
BumpThreshold = 1
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '5s'

[GasEstimator.DAOracle]
OracleType = 'zksync'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Fantom Mainnet (250)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
FinalityDepth = 50
SafeDepth = 0
FinalityTagEnabled = false
LinkContractAddress = '0x6F43FF82CCA38001B6699a8AC47A2d0E66939407'
LogBackfillBatchSize = 1000
LogPollInterval = '1s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '30s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 2
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'SuggestedPrice'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 3800000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Fraxtal Mainnet (252)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
FinalityDepth = 50
SafeDepth = 0
FinalityTagEnabled = true
LogBackfillBatchSize = 1000
LogPollInterval = '2s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Kroma Mainnet (255)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'kroma'
FinalityDepth = 400
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0xC1F6f7622ad37C3f46cDF6F8AA0344ADE80BF450'
LogBackfillBatchSize = 1000
LogPollInterval = '2s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 1
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '40s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 2
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '30s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 wei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '100 wei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = true
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 24
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[GasEstimator.DAOracle]
OracleType = 'opstack'
OracleAddress = '0x4200000000000000000000000000000000000005'

[HeadTracker]
HistoryDepth = 400
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 10
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 1
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### ZKsync Goerli (280)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'zksync'
FinalityDepth = 10
SafeDepth = 0
FinalityTagEnabled = false
LinkContractAddress = '0xD29F4Cc763A064b6C563B8816f09351b3Fbb61A0'
LogBackfillBatchSize = 1000
LogPollInterval = '5s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 1
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '1m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '20 gwei'
PriceMax = '18.446744073709551615 ether'
PriceMin = '0'
LimitDefault = 100000000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[GasEstimator.DAOracle]
OracleType = 'zksync'

[HeadTracker]
HistoryDepth = 50
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Hedera Mainnet (295)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'hedera'
FinalityDepth = 10
SafeDepth = 0
FinalityTagEnabled = false
LinkContractAddress = '0x7Ce6bb2Cc2D3Fd45a974Da6a0F29236cb9513a98'
LogBackfillBatchSize = 1000
LogPollInterval = '10s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 1
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 2
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '2m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'SuggestedPrice'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = true
BumpMin = '10 gwei'
BumpPercent = 20
BumpThreshold = 0
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 10
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Hedera Testnet (296)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'hedera'
FinalityDepth = 10
SafeDepth = 0
FinalityTagEnabled = false
LinkContractAddress = '0x90a386d59b9A6a4795a011e8f032Fc21ED6FEFb6'
LogBackfillBatchSize = 1000
LogPollInterval = '10s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 1
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 2
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '2m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'SuggestedPrice'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = true
BumpMin = '10 gwei'
BumpPercent = 20
BumpThreshold = 0
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 10
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### ZKsync Sepolia (300)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'zksync'
FinalityDepth = 10
SafeDepth = 0
FinalityTagEnabled = false
LinkContractAddress = '0x23A1aFD896c8c8876AF46aDc38521f4432658d1e'
LogBackfillBatchSize = 1000
LogPollInterval = '5s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 1
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '1m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 2
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '20 gwei'
PriceMax = '18.446744073709551615 ether'
PriceMin = '0'
LimitDefault = 100000000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[GasEstimator.DAOracle]
OracleType = 'zksync'

[HeadTracker]
HistoryDepth = 50
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 11000000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### ZKsync Mainnet (324)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'zksync'
FinalityDepth = 10
SafeDepth = 0
FinalityTagEnabled = false
LinkContractAddress = '0x52869bae3E091e36b0915941577F2D47d8d8B534'
LogBackfillBatchSize = 1000
LogPollInterval = '5s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 1
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '1m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 2
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '20 gwei'
PriceMax = '18.446744073709551615 ether'
PriceMin = '0'
LimitDefault = 100000000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[GasEstimator.DAOracle]
OracleType = 'zksync'

[HeadTracker]
HistoryDepth = 50
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 11000000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Optimism Goerli (420)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'optimismBedrock'
FinalityDepth = 200
SafeDepth = 0
FinalityTagEnabled = false
LinkContractAddress = '0xdc2CC710e42857672E7907CF474a69B63B93089f'
LogBackfillBatchSize = 1000
LogPollInterval = '2s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 1
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '40s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '30s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 wei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '100 wei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = true
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 60
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[GasEstimator.DAOracle]
OracleType = 'opstack'
OracleAddress = '0x420000000000000000000000000000000000000F'

[HeadTracker]
HistoryDepth = 300
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 10
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 1
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 6500000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Worldchain Mainnet (480)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'optimismBedrock'
FinalityDepth = 2500
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0x915b648e994d5f31059B38223b9fbe98ae185473'
LogBackfillBatchSize = 1000
LogPollInterval = '3s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '1h30m0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'FeeHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = true
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 100
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '4s'

[GasEstimator.DAOracle]
OracleType = 'opstack'
OracleAddress = '0x420000000000000000000000000000000000000F'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Metis Rinkeby (588)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'metis'
FinalityDepth = 10
SafeDepth = 0
FinalityTagEnabled = false
LogBackfillBatchSize = 1000
LogPollInterval = '15s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 1
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'SuggestedPrice'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '0'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 0
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 10
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 1
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Astar Mainnet (592)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'astar'
FinalityDepth = 100
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0x31EFB841d5e0b4082F7E1267dab8De1b853f2A9d'
LogBackfillBatchSize = 1000
LogPollInterval = '6s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '20 gwei'
PriceMax = '100 micro'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Mode Sepolia (919)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'optimismBedrock'
FinalityDepth = 200
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0x925a4bfE64AE2bFAC8a02b35F78e60C29743755d'
LogBackfillBatchSize = 1000
LogPollInterval = '15s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '20 gwei'
PriceMax = '120 gwei'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '100 wei'
BumpPercent = 20
BumpThreshold = 60
EIP1559DynamicFees = true
FeeCapDefault = '120 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[GasEstimator.DAOracle]
OracleType = 'opstack'
OracleAddress = '0x420000000000000000000000000000000000000F'

[HeadTracker]
HistoryDepth = 300
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 2
PollInterval = '3s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Klaytn Testnet (1001)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
FinalityDepth = 10
SafeDepth = 0
FinalityTagEnabled = false
LogBackfillBatchSize = 1000
LogPollInterval = '15s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 1
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '30s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'SuggestedPrice'
PriceDefault = '750 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 5
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 1
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Metis Mainnet (1088)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'optimismBedrock'
FinalityDepth = 10
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0xd2FE54D1E5F568eB710ba9d898Bf4bD02C7c0353'
LogBackfillBatchSize = 1000
LogPollInterval = '15s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 1
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'SuggestedPrice'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '0'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 0
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[GasEstimator.DAOracle]
OracleType = 'opstack'
OracleAddress = '0x420000000000000000000000000000000000000F'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 10
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 1
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Polygon Zkevm Mainnet (1101)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'zkevm'
FinalityDepth = 500
SafeDepth = 0
FinalityTagEnabled = false
LinkContractAddress = '0xdB7A504CF869484dd6aC5FaF925c8386CBF7573D'
LogBackfillBatchSize = 1000
LogPollInterval = '30s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 1
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '6m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 100
RPCBlockQueryDelay = 15
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '3m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = true
MinAttempts = 3

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'FeeHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '0'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 40
BumpThreshold = 3
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '4s'

[HeadTracker]
HistoryDepth = 2000
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 1
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### WeMix Mainnet (1111)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'wemix'
FinalityDepth = 10
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0x80f1FcdC96B55e459BF52b998aBBE2c364935d69'
LogBackfillBatchSize = 1000
LogPollInterval = '3s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 1
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '30s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 2
NoNewFinalizedHeadsThreshold = '40s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = true
FeeCapDefault = '100 gwei'
TipCapDefault = '100 gwei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 1
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### WeMix Testnet (1112)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'wemix'
FinalityDepth = 10
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0x3580c7A817cCD41f7e02143BFa411D4EeAE78093'
LogBackfillBatchSize = 1000
LogPollInterval = '3s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 1
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '30s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 2
NoNewFinalizedHeadsThreshold = '40s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = true
FeeCapDefault = '100 gwei'
TipCapDefault = '100 gwei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 1
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Core Testnet (1114)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
FinalityDepth = 7
SafeDepth = 0
FinalityTagEnabled = false
LinkContractAddress = '0x6C475841d1D7871940E93579E5DBaE01634e17aA'
LogBackfillBatchSize = 1000
LogPollInterval = '3s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'FeeHistory'
PriceDefault = '35 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Core Mainnet (1116)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
FinalityDepth = 27
SafeDepth = 0
FinalityTagEnabled = false
LogBackfillBatchSize = 1000
LogPollInterval = '3s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'FeeHistory'
PriceDefault = '30 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Bsquared Testnet (1123)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'optimismBedrock'
FinalityDepth = 2000
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0x436a1907D9e6a65E6db73015F08f9C66F6B63E45'
LogBackfillBatchSize = 1000
LogPollInterval = '3s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '1h10m0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'FeeHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = true
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 100
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '4s'

[GasEstimator.DAOracle]
OracleType = 'opstack'
OracleAddress = '0x420000000000000000000000000000000000000F'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Unichain Testnet (1301)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'optimismBedrock'
FinalityDepth = 2000
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0xda40816f278Cd049c137F6612822D181065EBfB4'
LogBackfillBatchSize = 1000
LogPollInterval = '2s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '45m0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'FeeHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = true
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 100
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '2s'

[GasEstimator.DAOracle]
OracleType = 'opstack'
OracleAddress = '0x420000000000000000000000000000000000000F'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Simulated (1337)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
FinalityDepth = 10
SafeDepth = 0
FinalityTagEnabled = false
LogBackfillBatchSize = 1000
LogPollInterval = '15s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 1
MinContractPayment = '100'
NonceAutoSync = true
NoNewHeadsThreshold = '0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '0s'
ResendAfterThreshold = '0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'FixedPrice'
PriceDefault = '1 gwei'
PriceMax = '1 gwei'
PriceMin = '0'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 0
EIP1559DynamicFees = false
FeeCapDefault = '1 gwei'
TipCapDefault = '1 mwei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 10
MaxBufferSize = 100
SamplingInterval = '0s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = false
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 1
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Soneium Mainnet (1868)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'optimismBedrock'
FinalityDepth = 200
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0x32D8F819C8080ae44375F8d383Ffd39FC642f3Ec'
LogBackfillBatchSize = 1000
LogPollInterval = '2s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 1
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '40s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '2h0m0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '30s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 wei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '1 mwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = true
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 60
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[GasEstimator.DAOracle]
OracleType = 'opstack'
OracleAddress = '0x420000000000000000000000000000000000000F'

[HeadTracker]
HistoryDepth = 300
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 10
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 1
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 6500000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Soneium Sepolia (1946)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'optimismBedrock'
FinalityDepth = 200
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0x7ea13478Ea3961A0e8b538cb05a9DF0477c79Cd2'
LogBackfillBatchSize = 1000
LogPollInterval = '2s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 1
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '40s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '2h0m0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '30s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 wei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '1 mwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = true
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 60
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[GasEstimator.DAOracle]
OracleType = 'opstack'
OracleAddress = '0x420000000000000000000000000000000000000F'

[HeadTracker]
HistoryDepth = 300
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 10
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 1
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 6500000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Ronin Mainnet (2020)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
FinalityDepth = 50
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0x3902228D6A3d2Dc44731fD9d45FeE6a61c722D0b'
LogBackfillBatchSize = 1000
LogPollInterval = '3s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'FeeHistory'
PriceDefault = '20 gwei'
PriceMax = '1 micro'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Ronin Saigon (2021)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
FinalityDepth = 50
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0x5bB50A6888ee6a67E22afFDFD9513be7740F1c15'
LogBackfillBatchSize = 1000
LogPollInterval = '3s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'FeeHistory'
PriceDefault = '20 gwei'
PriceMax = '1 micro'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Kroma Sepolia (2358)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'kroma'
FinalityDepth = 400
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0xa75cCA5b404ec6F4BB6EC4853D177FE7057085c8'
LogBackfillBatchSize = 1000
LogPollInterval = '2s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 1
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '40s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 2
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '30s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 wei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '100 wei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = true
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 24
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[GasEstimator.DAOracle]
OracleType = 'opstack'
OracleAddress = '0x4200000000000000000000000000000000000005'

[HeadTracker]
HistoryDepth = 400
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 10
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 1
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Polygon Zkevm Cardona (2442)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'zkevm'
FinalityDepth = 500
SafeDepth = 0
FinalityTagEnabled = false
LinkContractAddress = '0x5576815a38A3706f37bf815b261cCc7cCA77e975'
LogBackfillBatchSize = 1000
LogPollInterval = '30s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 1
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '12m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 100
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '3m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = true
MinAttempts = 3

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'FeeHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '0'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 40
BumpThreshold = 3
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '4s'

[HeadTracker]
HistoryDepth = 2000
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 1
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Fraxtal Testnet (2522)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
FinalityDepth = 50
SafeDepth = 0
FinalityTagEnabled = true
LogBackfillBatchSize = 1000
LogPollInterval = '2s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Botanix Testnet (3636)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
FinalityDepth = 50
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0x7311DED199CC28D80E58e81e8589aa160199FCD2'
LogBackfillBatchSize = 1000
LogPollInterval = '15s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '100 wei'
PriceMax = '800 kwei'
PriceMin = '1 wei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = true
FeeCapDefault = '800 kwei'
TipCapDefault = '0'
TipCapMin = '0'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 4
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 50

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Botanix Mainnet (3637)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
FinalityDepth = 50
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0x30e85A5c9525AD9a7A0FA5C74df4Baf0b01aD241'
LogBackfillBatchSize = 1000
LogPollInterval = '15s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '100 wei'
PriceMax = '800 kwei'
PriceMin = '1 wei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = true
FeeCapDefault = '800 kwei'
TipCapDefault = '0'
TipCapMin = '0'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 4
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 50

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Fantom Testnet (4002)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
FinalityDepth = 50
SafeDepth = 0
FinalityTagEnabled = false
LinkContractAddress = '0xfaFedb041c0DD4fA2Dc0d87a6B0979Ee6FA7af5F'
LogBackfillBatchSize = 1000
LogPollInterval = '1s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 2
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'SuggestedPrice'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 3800000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Merlin Mainnet (4200)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'zkevm'
FinalityDepth = 1000
SafeDepth = 0
FinalityTagEnabled = false
LogBackfillBatchSize = 1000
LogPollInterval = '4s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 1
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 100
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '3m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = true
MinAttempts = 3

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 2000
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 1
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Worldchain Testnet (4801)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'optimismBedrock'
FinalityDepth = 2500
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0xC82Ea35634BcE95C394B6BC00626f827bB0F4801'
LogBackfillBatchSize = 1000
LogPollInterval = '3s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '1h30m0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'FeeHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = true
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 100
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '4s'

[GasEstimator.DAOracle]
OracleType = 'opstack'
OracleAddress = '0x420000000000000000000000000000000000000F'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Mantle Mainnet (5000)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'optimismBedrock'
FinalityDepth = 1200
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0xfe36cF0B43aAe49fBc5cFC5c0AF22a623114E043'
LogBackfillBatchSize = 1000
LogPollInterval = '2s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 1
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '40m0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '20 gwei'
PriceMax = '120 gwei'
PriceMin = '1 gwei'
LimitDefault = 80000000000
LimitMax = 100000000000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '100 wei'
BumpPercent = 20
BumpThreshold = 60
EIP1559DynamicFees = true
FeeCapDefault = '120 gwei'
TipCapDefault = '0'
TipCapMin = '0'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 200
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
EIP1559FeeCapBufferBlocks = 0
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[GasEstimator.DAOracle]
OracleType = 'opstack'
OracleAddress = '0x420000000000000000000000000000000000000F'

[HeadTracker]
HistoryDepth = 1250
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Mantle Sepolia (5003)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'optimismBedrock'
FinalityDepth = 1200
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0x22bdEdEa0beBdD7CfFC95bA53826E55afFE9DE04'
LogBackfillBatchSize = 1000
LogPollInterval = '2s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 1
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '1h0m0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '20 gwei'
PriceMax = '120 gwei'
PriceMin = '1 gwei'
LimitDefault = 80000000000
LimitMax = 100000000000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '100 wei'
BumpPercent = 20
BumpThreshold = 60
EIP1559DynamicFees = true
FeeCapDefault = '120 gwei'
TipCapDefault = '0'
TipCapMin = '0'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 200
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
EIP1559FeeCapBufferBlocks = 0
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[GasEstimator.DAOracle]
OracleType = 'opstack'
OracleAddress = '0x420000000000000000000000000000000000000F'

[HeadTracker]
HistoryDepth = 1250
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Klaytn Mainnet (8217)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
FinalityDepth = 10
SafeDepth = 0
FinalityTagEnabled = false
LogBackfillBatchSize = 1000
LogPollInterval = '15s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 1
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '30s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'SuggestedPrice'
PriceDefault = '750 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 5
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 1
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Base Mainnet (8453)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'optimismBedrock'
FinalityDepth = 200
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0x88Fb150BDc53A65fe94Dea0c9BA0a6dAf8C6e196'
LogBackfillBatchSize = 1000
LogPollInterval = '2s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 1
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '40s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '15m0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '30s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 wei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '100 wei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = true
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 24
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[GasEstimator.DAOracle]
OracleType = 'opstack'
OracleAddress = '0x420000000000000000000000000000000000000F'

[HeadTracker]
HistoryDepth = 300
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 10
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 1
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 6500000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Monad Testnet (10143)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
FinalityDepth = 120
SafeDepth = 0
FinalityTagEnabled = false
LogBackfillBatchSize = 100
LogPollInterval = '2s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '1m0s'
LogBroadcasterEnabled = false
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '1m0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'FeeHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 100
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '2s'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '4s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Gnosis Chiado (10200)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'gnosis'
FinalityDepth = 100
SafeDepth = 0
FinalityTagEnabled = false
LinkContractAddress = '0xDCA67FD8324990792C0bfaE95903B8A64097754F'
LogBackfillBatchSize = 1000
LogPollInterval = '5s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 2
NoNewFinalizedHeadsThreshold = '2m0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '20 gwei'
PriceMax = '500 gwei'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = true
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### L3X Mainnet (12324)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'arbitrum'
FinalityDepth = 10
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0x79f531a3D07214304F259DC28c7191513223bcf3'
LogBackfillBatchSize = 1000
LogPollInterval = '10s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'Arbitrum'
PriceDefault = '100 mwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '0'
LimitDefault = 500000
LimitMax = 1000000000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 5
EIP1559DynamicFees = false
FeeCapDefault = '1 micro'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[GasEstimator.DAOracle]
OracleType = 'arbitrum'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 1
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### L3X Sepolia (12325)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'arbitrum'
FinalityDepth = 10
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0xa71848C99155DA0b245981E5ebD1C94C4be51c43'
LogBackfillBatchSize = 1000
LogPollInterval = '10s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'Arbitrum'
PriceDefault = '100 mwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '0'
LimitDefault = 500000
LimitMax = 1000000000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 5
EIP1559DynamicFees = false
FeeCapDefault = '1 micro'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[GasEstimator.DAOracle]
OracleType = 'arbitrum'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 1
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Ethereum Holesky (17000)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
FinalityDepth = 50
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0x685cE6742351ae9b618F383883D6d1e0c5A31B4B'
LogBackfillBatchSize = 1000
LogPollInterval = '15s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '20 gwei'
PriceMax = '1 micro'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = true
FeeCapDefault = '1 micro'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 2
PollInterval = '3s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Mode Mainnet (34443)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'optimismBedrock'
FinalityDepth = 200
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0x183E3691EfF3524B2315D3703D94F922CbE51F54'
LogBackfillBatchSize = 1000
LogPollInterval = '15s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '20 gwei'
PriceMax = '120 gwei'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '100 wei'
BumpPercent = 20
BumpThreshold = 60
EIP1559DynamicFees = true
FeeCapDefault = '120 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[GasEstimator.DAOracle]
OracleType = 'opstack'
OracleAddress = '0x420000000000000000000000000000000000000F'

[HeadTracker]
HistoryDepth = 300
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 2
PollInterval = '3s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Lens Sepolia (37111)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'zksync'
FinalityDepth = 40
SafeDepth = 0
FinalityTagEnabled = false
LinkContractAddress = '0x7f1b9eE544f9ff9bB521Ab79c205d79C55250a36'
LogBackfillBatchSize = 1000
LogPollInterval = '5s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '10m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '7m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'FeeHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 40
BumpThreshold = 1
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '5s'

[GasEstimator.DAOracle]
OracleType = 'zksync'

[HeadTracker]
HistoryDepth = 250
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[NodePool.Errors]
TerminallyUnderpriced = '(?:: |^)(max fee per gas less than block base fee|virtual machine entered unexpected state. (?:P|p)lease contact developers and provide transaction details that caused this error. Error description: (?:The operator included transaction with an unacceptable gas price|Assertion error: Fair pubdata price too high))

### Arbitrum Mainnet (42161)

```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'arbitrum'
FinalityDepth = 50
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0xf97f4df75117a78c1A5a0DBb814Af92458539FB4'
LogBackfillBatchSize = 1000
LogPollInterval = '1s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'Arbitrum'
PriceDefault = '100 mwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '0'
LimitDefault = 500000
LimitMax = 1000000000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 5
EIP1559DynamicFees = false
FeeCapDefault = '1 micro'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 0
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[GasEstimator.DAOracle]
OracleType = 'arbitrum'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 10
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 1
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 14500000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Celo Mainnet (42220)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'celo'
FinalityDepth = 2750
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0xd07294e6E917e07dfDcee882dd1e2565085C2ae0'
LogBackfillBatchSize = 1000
LogPollInterval = '1s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 1
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '1m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '45m0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '30s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '5 gwei'
PriceMax = '500 gwei'
PriceMin = '5 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '2 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = true
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 50
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 300
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 10
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 1
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Hemi Mainnet (43111)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'optimismBedrock'
FinalityDepth = 50
SafeDepth = 0
FinalityTagEnabled = true
LogBackfillBatchSize = 1000
LogPollInterval = '4s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 1
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
LogBroadcasterEnabled = false
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '30m0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '2m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'FeeHistory'
PriceDefault = '20 gwei'
PriceMax = '120 gwei'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = true
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 50
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[GasEstimator.DAOracle]
OracleType = 'opstack'
OracleAddress = '0x420000000000000000000000000000000000000F'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 10
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '4s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Avalanche Fuji (43113)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
FinalityDepth = 10
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0x0b9d5D9136855f6FEc3c0993feE6E9CE8a297846'
LogBackfillBatchSize = 1000
LogPollInterval = '3s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 1
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '30s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 2
FinalizedBlockOffset = 2
NoNewFinalizedHeadsThreshold = '1m0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '1 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 24
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 1
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Avalanche Mainnet (43114)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
FinalityDepth = 10
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0x5947BB275c521040051D82396192181b413227A3'
LogBackfillBatchSize = 1000
LogPollInterval = '3s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 1
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '30s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 2
FinalizedBlockOffset = 2
NoNewFinalizedHeadsThreshold = '1m0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '1 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 24
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 1
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Celo Testnet (44787)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'celo'
FinalityDepth = 2750
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0x32E08557B14FaD8908025619797221281D439071'
LogBackfillBatchSize = 1000
LogPollInterval = '1s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 1
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '1m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '45m0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '30s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '20 gwei'
PriceMax = '1 micro'
PriceMin = '5 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = true
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 200
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 300
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 10
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 1
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Zircuit Sepolia (48899)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'zircuit'
FinalityDepth = 1000
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0xDEE94506570cA186BC1e3516fCf4fd719C312cCD'
LogBackfillBatchSize = 1000
LogPollInterval = '2s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '40s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '40m0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '30s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = true
Threshold = 90
MinAttempts = 3

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 wei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '100 wei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = true
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 60
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[GasEstimator.DAOracle]
OracleType = 'opstack'
OracleAddress = '0x420000000000000000000000000000000000000F'

[HeadTracker]
HistoryDepth = 2000
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 10
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 1
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 6500000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Zircuit Mainnet (48900)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'zircuit'
FinalityDepth = 1000
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0x5D6d033B4FbD2190D99D930719fAbAcB64d2439a'
LogBackfillBatchSize = 1000
LogPollInterval = '2s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '40s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '40m0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '30s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = true
Threshold = 90
MinAttempts = 3

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 wei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '100 wei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = true
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 24
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[GasEstimator.DAOracle]
OracleType = 'opstack'
OracleAddress = '0x420000000000000000000000000000000000000F'

[HeadTracker]
HistoryDepth = 2000
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 10
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 1
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 6500000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Sonic Testnet (57054)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
FinalityDepth = 10
SafeDepth = 0
FinalityTagEnabled = false
LinkContractAddress = '0x61876F0429726D7777B46f663e1C9ab75d08Fc56'
LogBackfillBatchSize = 1000
LogPollInterval = '1s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 5
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 100
RPCBlockQueryDelay = 10
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 500
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'FeeHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 10
BumpThreshold = 3
EIP1559DynamicFees = true
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 100
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '2s'

[HeadTracker]
HistoryDepth = 50
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 10
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Ink Mainnet (57073)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'optimismBedrock'
FinalityDepth = 3000
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0x71052BAe71C25C78E37fD12E5ff1101A71d9018F'
LogBackfillBatchSize = 1000
LogPollInterval = '2s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '1h0m0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'FeeHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = true
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 100
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '2s'

[GasEstimator.DAOracle]
OracleType = 'opstack'
OracleAddress = '0x420000000000000000000000000000000000000F'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Linea Goerli (59140)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
FinalityDepth = 15
SafeDepth = 0
FinalityTagEnabled = false
LogBackfillBatchSize = 1000
LogPollInterval = '15s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '3m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 40
BumpThreshold = 3
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Linea Sepolia (59141)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
FinalityDepth = 900
SafeDepth = 0
FinalityTagEnabled = false
LinkContractAddress = '0xF64E6E064a71B45514691D397ad4204972cD6508'
LogBackfillBatchSize = 1000
LogPollInterval = '15s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '3m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = true
Threshold = 50
MinAttempts = 3

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 wei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = true
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 1000
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Linea Mainnet (59144)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
FinalityDepth = 300
SafeDepth = 0
FinalityTagEnabled = false
LinkContractAddress = '0xa18152629128738a5c081eb226335FEd4B9C95e9'
LogBackfillBatchSize = 1000
LogPollInterval = '15s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '3m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = true
Threshold = 50
MinAttempts = 3

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '400 mwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '500 mwei'
BumpPercent = 40
BumpThreshold = 3
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 350
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Metis Sepolia (59902)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'optimismBedrock'
FinalityDepth = 10
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0x9870D6a0e05F867EAAe696e106741843F7fD116D'
LogBackfillBatchSize = 1000
LogPollInterval = '15s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 1
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'SuggestedPrice'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '0'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 0
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[GasEstimator.DAOracle]
OracleType = 'opstack'
OracleAddress = '0x420000000000000000000000000000000000000F'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 10
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 1
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### BOB Mainnet (60808)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'optimismBedrock'
FinalityDepth = 3150
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0x5aB885CDa7216b163fb6F813DEC1E1532516c833'
LogBackfillBatchSize = 1000
LogPollInterval = '3s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '1h50m0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'FeeHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = true
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 100
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '4s'

[GasEstimator.DAOracle]
OracleType = 'opstack'
OracleAddress = '0x420000000000000000000000000000000000000F'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Treasure Mainnet (61166)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'zksync'
FinalityDepth = 50
SafeDepth = 0
FinalityTagEnabled = true
LogBackfillBatchSize = 1000
LogPollInterval = '10s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '5m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '25 mwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[GasEstimator.DAOracle]
OracleType = 'zksync'

[HeadTracker]
HistoryDepth = 250
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Polygon Mumbai (80001)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
FinalityDepth = 500
SafeDepth = 0
FinalityTagEnabled = false
LinkContractAddress = '0x326C977E6efc84E512bB9C30f76E30c160eD06FB'
LogBackfillBatchSize = 1000
LogPollInterval = '1s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 5
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '30s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 100
RPCBlockQueryDelay = 10
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 5000
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '25 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '25 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '20 gwei'
BumpPercent = 20
BumpThreshold = 5
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 24
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 2000
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 10
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Polygon Amoy (80002)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
FinalityDepth = 500
SafeDepth = 0
FinalityTagEnabled = false
LinkContractAddress = '0x0Fd9e8d3aF1aaee056EB9e802c3A762a667b1904'
LogBackfillBatchSize = 1000
LogPollInterval = '1s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 5
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '30s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 100
RPCBlockQueryDelay = 10
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '12m0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 5000
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '25 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '25 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '20 gwei'
BumpPercent = 20
BumpThreshold = 5
EIP1559DynamicFees = true
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 24
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 2000
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 10
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Berachain Testnet (80084)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
FinalityDepth = 10
SafeDepth = 0
FinalityTagEnabled = false
LinkContractAddress = '0x52CEEed7d3f8c6618e4aaD6c6e555320d0D83271'
LogBackfillBatchSize = 1000
LogPollInterval = '6s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '5m0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'FeeHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = true
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 100
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Berachain Mainnet (80094)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
FinalityDepth = 10
SafeDepth = 0
FinalityTagEnabled = false
LinkContractAddress = '0x52CEEed7d3f8c6618e4aaD6c6e555320d0D83271'
LogBackfillBatchSize = 1000
LogPollInterval = '6s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '5m0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 100
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Blast Mainnet (81457)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'optimismBedrock'
FinalityDepth = 200
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0x93202eC683288a9EA75BB829c6baCFb2BfeA9013'
LogBackfillBatchSize = 1000
LogPollInterval = '2s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '20 gwei'
PriceMax = '120 gwei'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '100 wei'
BumpPercent = 20
BumpThreshold = 60
EIP1559DynamicFees = true
FeeCapDefault = '120 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[GasEstimator.DAOracle]
OracleType = 'opstack'
OracleAddress = '0x420000000000000000000000000000000000000F'

[HeadTracker]
HistoryDepth = 300
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 4
PollInterval = '4s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Base Goerli (84531)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'optimismBedrock'
FinalityDepth = 200
SafeDepth = 0
FinalityTagEnabled = false
LogBackfillBatchSize = 1000
LogPollInterval = '2s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 1
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '40s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '30s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 wei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '100 wei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = true
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 60
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[GasEstimator.DAOracle]
OracleType = 'opstack'
OracleAddress = '0x420000000000000000000000000000000000000F'

[HeadTracker]
HistoryDepth = 300
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 10
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 1
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 6500000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Base Sepolia (84532)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'optimismBedrock'
FinalityDepth = 200
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0xE4aB69C077896252FAFBD49EFD26B5D171A32410'
LogBackfillBatchSize = 1000
LogPollInterval = '2s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 1
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '40s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '12m0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '30s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 wei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '100 wei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = true
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 60
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[GasEstimator.DAOracle]
OracleType = 'opstack'
OracleAddress = '0x420000000000000000000000000000000000000F'

[HeadTracker]
HistoryDepth = 300
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 10
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 1
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 6500000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Plume Mainnet (98866)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
FinalityDepth = 50
SafeDepth = 0
FinalityTagEnabled = true
LogBackfillBatchSize = 1000
LogPollInterval = '5s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '10m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '13h0m0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'FeeHistory'
PriceDefault = '20 gwei'
PriceMax = '1 micro'
PriceMin = '0'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 mwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '4s'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Plume Sepolia (98867)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
FinalityDepth = 50
SafeDepth = 0
FinalityTagEnabled = true
LogBackfillBatchSize = 1000
LogPollInterval = '5s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '6m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '1h10m0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'FeeHistory'
PriceDefault = '20 gwei'
PriceMax = '1 micro'
PriceMin = '0'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 mwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '4s'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Katana Testnet (129399)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'optimismBedrock'
FinalityDepth = 50
SafeDepth = 0
FinalityTagEnabled = true
LogBackfillBatchSize = 1000
LogPollInterval = '2s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 1
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '1m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '45m0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '30s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'FeeHistory'
PriceDefault = '20 gwei'
PriceMax = '120 gwei'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = true
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 60
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '4s'

[GasEstimator.DAOracle]
OracleType = 'opstack'
OracleAddress = '0x420000000000000000000000000000000000000F'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 10
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Taiko Mainnet (167000)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
FinalityDepth = 50
SafeDepth = 0
FinalityTagEnabled = true
LogBackfillBatchSize = 1000
LogPollInterval = '10s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 1
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '6m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '3m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'FeeHistory'
PriceDefault = '20 gwei'
PriceMax = '1 micro'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 10
BumpThreshold = 2
EIP1559DynamicFees = true
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '5s'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '5s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 1
ContractTransmitterTransmitTimeout = '1m0s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Taiko Testnet (167009)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
FinalityDepth = 50
SafeDepth = 0
FinalityTagEnabled = true
LogBackfillBatchSize = 1000
LogPollInterval = '10s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 1
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '6m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '3m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'FeeHistory'
PriceDefault = '20 gwei'
PriceMax = '1 micro'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 10
BumpThreshold = 2
EIP1559DynamicFees = true
FeeCapDefault = '50 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '5s'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '5s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 1
ContractTransmitterTransmitTimeout = '1m0s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Mind Testnet (192940)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'arbitrum'
FinalityDepth = 50
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0xd8A9246e84903e82CA01e42774b01A7CdD465BFa'
LogBackfillBatchSize = 1000
LogPollInterval = '2s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'Arbitrum'
PriceDefault = '5 mwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '0'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[GasEstimator.DAOracle]
OracleType = 'arbitrum'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 10
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Bitlayer Testnet (200810)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
FinalityDepth = 21
SafeDepth = 0
FinalityTagEnabled = false
LinkContractAddress = '0x2A5bACb2440BC17D53B7b9Be73512dDf92265e48'
LogBackfillBatchSize = 1000
LogPollInterval = '15s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'FeeHistory'
PriceDefault = '1 gwei'
PriceMax = '1 gwei'
PriceMin = '40 mwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = false
FeeCapDefault = '1 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Bitlayer Mainnet (200901)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
FinalityDepth = 21
SafeDepth = 0
FinalityTagEnabled = false
LinkContractAddress = '0x56B275c0Ec034a229a1deD8DB17089544bc276D9'
LogBackfillBatchSize = 1000
LogPollInterval = '15s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'FeeHistory'
PriceDefault = '1 gwei'
PriceMax = '1 gwei'
PriceMin = '40 mwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = false
FeeCapDefault = '1 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Arbitrum Rinkeby (421611)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'arbitrum'
FinalityDepth = 50
SafeDepth = 0
FinalityTagEnabled = false
LinkContractAddress = '0x615fBe6372676474d9e6933d310469c9b68e9726'
LogBackfillBatchSize = 1000
LogPollInterval = '1s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'Arbitrum'
PriceDefault = '100 mwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '0'
LimitDefault = 500000
LimitMax = 1000000000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 5
EIP1559DynamicFees = false
FeeCapDefault = '1 micro'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 0
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[GasEstimator.DAOracle]
OracleType = 'arbitrum'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 10
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 1
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Arbitrum Goerli (421613)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'arbitrum'
FinalityDepth = 50
SafeDepth = 0
FinalityTagEnabled = false
LinkContractAddress = '0xd14838A68E8AFBAdE5efb411d5871ea0011AFd28'
LogBackfillBatchSize = 1000
LogPollInterval = '1s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'Arbitrum'
PriceDefault = '100 mwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '0'
LimitDefault = 500000
LimitMax = 1000000000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 5
EIP1559DynamicFees = false
FeeCapDefault = '1 micro'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 0
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[GasEstimator.DAOracle]
OracleType = 'arbitrum'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 10
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 1
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 14500000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Arbitrum Sepolia (421614)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'arbitrum'
FinalityDepth = 50
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0xb1D4538B4571d411F07960EF2838Ce337FE1E80E'
LogBackfillBatchSize = 1000
LogPollInterval = '1s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'Arbitrum'
PriceDefault = '100 mwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '0'
LimitDefault = 500000
LimitMax = 1000000000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 5
EIP1559DynamicFees = false
FeeCapDefault = '1 micro'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 0
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[GasEstimator.DAOracle]
OracleType = 'arbitrum'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 10
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 1
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 14500000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Scroll Sepolia (534351)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'scroll'
FinalityDepth = 10
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0x231d45b53C905c3d6201318156BDC725c9c3B9B1'
LogBackfillBatchSize = 1000
LogPollInterval = '5s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 1
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = true
DetectionApiUrl = 'https://sepolia-venus.scroll.io'

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 wei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '1 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = true
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 24
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[GasEstimator.DAOracle]
OracleType = 'opstack'
OracleAddress = '0x5300000000000000000000000000000000000002'

[HeadTracker]
HistoryDepth = 50
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 1
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Scroll Mainnet (534352)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'scroll'
FinalityDepth = 10
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0x548C6944cba02B9D1C0570102c89de64D258d3Ac'
LogBackfillBatchSize = 1000
LogPollInterval = '5s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 1
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = true
DetectionApiUrl = 'https://venus.scroll.io'

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 wei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '1 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = true
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 24
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[GasEstimator.DAOracle]
OracleType = 'opstack'
OracleAddress = '0x5300000000000000000000000000000000000002'

[HeadTracker]
HistoryDepth = 50
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 1
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Merlin Testnet (686868)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'zkevm'
FinalityDepth = 1000
SafeDepth = 0
FinalityTagEnabled = false
LogBackfillBatchSize = 1000
LogPollInterval = '4s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 1
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 100
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '3m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = true
MinAttempts = 3

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 2000
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 1
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Hemi Testnet (743111)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'optimismBedrock'
FinalityDepth = 50
SafeDepth = 0
FinalityTagEnabled = true
LogBackfillBatchSize = 1000
LogPollInterval = '4s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 1
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
LogBroadcasterEnabled = false
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '30m0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '2m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'FeeHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = true
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 50
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[GasEstimator.DAOracle]
OracleType = 'opstack'
OracleAddress = '0x420000000000000000000000000000000000000F'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 10
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '4s'
VerifyChainID = true

[OCR]
ContractConfirmations = 1
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Katana Mainnet (747474)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'optimismBedrock'
FinalityDepth = 50
SafeDepth = 0
FinalityTagEnabled = true
LogBackfillBatchSize = 1000
LogPollInterval = '2s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 1
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '1m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '45m0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '30s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'FeeHistory'
PriceDefault = '20 gwei'
PriceMax = '120 gwei'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = true
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 60
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '4s'

[GasEstimator.DAOracle]
OracleType = 'opstack'
OracleAddress = '0x420000000000000000000000000000000000000F'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 10
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Ink Testnet (763373)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'optimismBedrock'
FinalityDepth = 3000
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0x3423C922911956b1Ccbc2b5d4f38216a6f4299b4'
LogBackfillBatchSize = 1000
LogPollInterval = '2s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '1h0m0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'FeeHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = true
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 100
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '2s'

[GasEstimator.DAOracle]
OracleType = 'opstack'
OracleAddress = '0x420000000000000000000000000000000000000F'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### BOB Testnet (808813)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'optimismBedrock'
FinalityDepth = 3150
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0xcd2AfB2933391E35e8682cbaaF75d9CA7339b183'
LogBackfillBatchSize = 1000
LogPollInterval = '3s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '1h50m0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'FeeHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = true
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 100
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '4s'

[GasEstimator.DAOracle]
OracleType = 'opstack'
OracleAddress = '0x420000000000000000000000000000000000000F'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Treasure Testnet (978658)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'zksync'
FinalityDepth = 50
SafeDepth = 0
FinalityTagEnabled = true
LogBackfillBatchSize = 1000
LogPollInterval = '10s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '10m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '100 mwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[GasEstimator.DAOracle]
OracleType = 'zksync'

[HeadTracker]
HistoryDepth = 250
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Ethereum Sepolia (11155111)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
FinalityDepth = 50
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0x779877A7B0D9E8603169DdbD7836e478b4624789'
LogBackfillBatchSize = 1000
LogPollInterval = '15s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.1 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = true
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 4
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 50

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 10500000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Optimism Sepolia (11155420)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'optimismBedrock'
FinalityDepth = 200
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0xE4aB69C077896252FAFBD49EFD26B5D171A32410'
LogBackfillBatchSize = 1000
LogPollInterval = '2s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 1
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '40s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '15m0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '30s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '20 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 wei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '100 wei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = true
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 60
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[GasEstimator.DAOracle]
OracleType = 'opstack'
OracleAddress = '0x420000000000000000000000000000000000000F'

[HeadTracker]
HistoryDepth = 300
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 10
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 1
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 6500000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Corn Mainnet (21000000)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'arbitrum'
FinalityDepth = 50
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0x7311DED199CC28D80E58e81e8589aa160199FCD2'
LogBackfillBatchSize = 1000
LogPollInterval = '15s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'Arbitrum'
PriceDefault = '100 mwei'
PriceMax = '1 micro'
PriceMin = '0'
LimitDefault = 500000
LimitMax = 1000000000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[GasEstimator.DAOracle]
OracleType = 'arbitrum'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Corn Testnet (21000001)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'arbitrum'
FinalityDepth = 50
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0x996EfAb6011896Be832969D91E9bc1b3983cfdA1'
LogBackfillBatchSize = 1000
LogPollInterval = '15s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'Arbitrum'
PriceDefault = '100 mwei'
PriceMax = '1 micro'
PriceMin = '0'
LimitDefault = 500000
LimitMax = 1000000000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[GasEstimator.DAOracle]
OracleType = 'arbitrum'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Blast Sepolia (168587773)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
ChainType = 'optimismBedrock'
FinalityDepth = 200
SafeDepth = 0
FinalityTagEnabled = true
LinkContractAddress = '0x02c359ebf98fc8BF793F970F9B8302bb373BdF32'
LogBackfillBatchSize = 1000
LogPollInterval = '2s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 3
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '3m0s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '20 gwei'
PriceMax = '120 gwei'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '100 wei'
BumpPercent = 20
BumpThreshold = 60
EIP1559DynamicFees = true
FeeCapDefault = '120 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[GasEstimator.DAOracle]
OracleType = 'opstack'
OracleAddress = '0x420000000000000000000000000000000000000F'

[HeadTracker]
HistoryDepth = 300
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 4
PollInterval = '4s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Harmony Mainnet (1666600000)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
FinalityDepth = 50
SafeDepth = 0
FinalityTagEnabled = false
LinkContractAddress = '0x218532a12a389a4a92fC0C5Fb22901D1c19198aA'
LogBackfillBatchSize = 1000
LogPollInterval = '2s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 1
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '30s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '5 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### Harmony Testnet (1666700000)
[Image: copy to clipboard]
```toml
AutoCreateKey = true
BlockBackfillDepth = 10
BlockBackfillSkip = false
FinalityDepth = 50
SafeDepth = 0
FinalityTagEnabled = false
LinkContractAddress = '0x8b12Ac23BFe11cAb03a634C1F117D64a7f2cFD3e'
LogBackfillBatchSize = 1000
LogPollInterval = '2s'
LogKeepBlocksDepth = 100000
LogPrunePageSize = 0
BackupLogPollerBlockDelay = 100
MinIncomingConfirmations = 1
MinContractPayment = '0.00001 link'
NonceAutoSync = true
NoNewHeadsThreshold = '30s'
LogBroadcasterEnabled = true
RPCDefaultBatchSize = 250
RPCBlockQueryDelay = 1
FinalizedBlockOffset = 0
NoNewFinalizedHeadsThreshold = '0s'

[Transactions]
Enabled = true
ForwardersEnabled = false
MaxInFlight = 16
MaxQueued = 250
ReaperInterval = '1h0m0s'
ReaperThreshold = '168h0m0s'
ResendAfterThreshold = '1m0s'
ConfirmationTimeout = '1m0s'

[Transactions.AutoPurge]
Enabled = false

[Transactions.TransactionManagerV2]
Enabled = false

[BalanceMonitor]
Enabled = true

[GasEstimator]
Mode = 'BlockHistory'
PriceDefault = '5 gwei'
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether'
PriceMin = '1 gwei'
LimitDefault = 500000
LimitMax = 500000
LimitMultiplier = '1'
LimitTransfer = 21000
EstimateLimit = false
BumpMin = '5 gwei'
BumpPercent = 20
BumpThreshold = 3
EIP1559DynamicFees = false
FeeCapDefault = '100 gwei'
TipCapDefault = '1 wei'
TipCapMin = '1 wei'

[GasEstimator.BlockHistory]
BatchSize = 25
BlockHistorySize = 8
CheckInclusionBlocks = 12
CheckInclusionPercentile = 90
TransactionPercentile = 60

[GasEstimator.FeeHistory]
CacheTimeout = '10s'

[HeadTracker]
HistoryDepth = 100
MaxBufferSize = 3
SamplingInterval = '1s'
MaxAllowedFinalityDepth = 10000
FinalityTagBypass = false
PersistenceEnabled = true

[NodePool]
PollFailureThreshold = 5
PollInterval = '10s'
SelectionMode = 'HighestHead'
SyncThreshold = 5
LeaseDuration = '0s'
NodeIsSyncingEnabled = false
FinalizedBlockPollInterval = '5s'
EnforceRepeatableRead = true
DeathDeclarationDelay = '1m0s'
NewHeadsPollInterval = '0s'
VerifyChainID = true

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'
```

### ChainID
[Image: copy to clipboard]
```toml
ChainID = '1' # Example
```

ChainID is the EVM chain ID. Mandatory.

### Enabled
[Image: copy to clipboard]
```toml
Enabled = true # Default
```

Enabled enables this chain.

### AutoCreateKey
[Image: copy to clipboard]
```toml
AutoCreateKey = true # Default
```

AutoCreateKey, if set to true, will ensure that there is always at least one transmit key for the given chain.

### BlockBackfillDepth
[Image: caution]caution

ADVANCED:Do not change this setting unless you know what you are doing..asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }[Image: copy to clipboard]
```toml
BlockBackfillDepth = 10 # Default
```

BlockBackfillDepth specifies the number of blocks before the current HEAD that the log broadcaster will try to re-consume logs from.

### BlockBackfillSkip
[Image: copy to clipboard]
```toml
BlockBackfillSkip = false # Default
```

BlockBackfillSkip enables skipping of very long backfills.

### ChainType
[Image: copy to clipboard]
```toml
ChainType = 'arbitrum' # Example
```

ChainType is automatically detected from chain ID. Set this to force a certain chain type regardless of chain ID.
Available types: arbitrum, celo, gnosis, hedera, kroma, metis, optimismBedrock, scroll, wemix, xlayer, zksync

### SafeDepth
[Image: copy to clipboard]
```toml
SafeDepth = 0 # Default
```

SafeDepth is the number of blocks after which an ethereum transaction is considered "safe."
Note that this setting is only used for chains with FinalityTags = false
This number represents a number of blocks we consider large enough that reorgs are generally not likely to happen.
Note that this number is different from FinalityDepth, which is the number of blocks after which a transaction is considered final.
It is used in cases where we don't want to wait for finality.

Special cases:
SafeDepth=0 would imply that its value will fall back to the FinalityDepth value, if FinalityTagEnabled is false.

Examples:

Transaction sending:
A transaction is sent at block height 42

SafeDepth is set to 5, FinalityTagEnabled = false, and FinalityDepth = 10
At block height 47, the transaction is considered safe, but not final.
At block height 52, the transaction is considered final.

### FinalityDepth
[Image: copy to clipboard]
```toml
FinalityDepth = 50 # Default
```

FinalityDepth is the number of blocks after which an ethereum transaction is considered "final". Note that the default is automatically set based on chain ID, so it should not be necessary to change this under normal operation.
BlocksConsideredFinal determines how deeply we look back to ensure that transactions are confirmed onto the longest chain
There is not a large performance penalty to setting this relatively high (on the order of hundreds)
It is practically limited by the number of heads we store in the database and should be less than this with a comfortable margin.
If a transaction is mined in a block more than this many blocks ago, and is reorged out, we will NOT retransmit this transaction and undefined behaviour can occur including gaps in the nonce sequence that require manual intervention to fix.
Therefore, this number represents a number of blocks we consider large enough that no re-org this deep will ever feasibly happen.

Special cases:
FinalityDepth=0 would imply that transactions can be final even before they were mined into a block. This is not supported.
FinalityDepth=1 implies that transactions are final after we see them in one block.

Examples:

Transaction sending:
A transaction is sent at block height 42

FinalityDepth is set to 5
A re-org occurs at height 44 starting at block 41, transaction is marked for rebroadcast
A re-org occurs at height 46 starting at block 41, transaction is marked for rebroadcast
A re-org occurs at height 47 starting at block 41, transaction is NOT marked for rebroadcast

### FinalityTagEnabled
[Image: copy to clipboard]
```toml
FinalityTagEnabled = false # Default
```

FinalityTagEnabled means that the chain supports the finalized block tag when querying for a block. If FinalityTagEnabled is set to true for a chain, then FinalityDepth field is ignored.
Finality for a block is solely defined by the finality related tags provided by the chain's RPC API. This is a placeholder and hasn't been implemented yet.

### FlagsContractAddress
[Image: caution]caution

ADVANCED:Do not change this setting unless you know what you are doing..asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }[Image: copy to clipboard]
```toml
FlagsContractAddress = '0xae4E781a6218A8031764928E88d457937A954fC3' # Example
```

FlagsContractAddress can optionally point to a Flags contract. If set, the node will lookup that contract for each job that supports flags contracts (currently OCR and FM jobs are supported). If the job's contractAddress is set as hibernating in the FlagsContractAddress address, it overrides the standard update parameters (such as heartbeat/threshold).

### LinkContractAddress
[Image: copy to clipboard]
```toml
LinkContractAddress = '0x538aAaB4ea120b2bC2fe5D296852D948F07D849e' # Example
```

LinkContractAddress is the canonical ERC-677 LINK token contract address on the given chain. Note that this is usually autodetected from chain ID.

### LogBackfillBatchSize
[Image: caution]caution

ADVANCED:Do not change this setting unless you know what you are doing..asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }[Image: copy to clipboard]
```toml
LogBackfillBatchSize = 1000 # Default
```

LogBackfillBatchSize sets the batch size for calling FilterLogs when we backfill missing logs.

### LogPollInterval
[Image: caution]caution

ADVANCED:Do not change this setting unless you know what you are doing..asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }[Image: copy to clipboard]
```toml
LogPollInterval = '15s' # Default
```

LogPollInterval works in conjunction with Feature.LogPoller. Controls how frequently the log poller polls for logs. Defaults to the block production rate.

### LogKeepBlocksDepth
[Image: caution]caution

ADVANCED:Do not change this setting unless you know what you are doing..asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }[Image: copy to clipboard]
```toml
LogKeepBlocksDepth = 100000 # Default
```

LogKeepBlocksDepth works in conjunction with Feature.LogPoller. Controls how many blocks the poller will keep, must be greater than FinalityDepth+1.

### LogPrunePageSize
[Image: caution]caution

ADVANCED:Do not change this setting unless you know what you are doing..asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }[Image: copy to clipboard]
```toml
LogPrunePageSize = 0 # Default
```

LogPrunePageSize defines size of the page for pruning logs. Controls how many logs/blocks (at most) are deleted in a single prune tick. Default value 0 means no paging, delete everything at once.

### BackupLogPollerBlockDelay
[Image: caution]caution

ADVANCED:Do not change this setting unless you know what you are doing..asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }[Image: copy to clipboard]
```toml
BackupLogPollerBlockDelay = 100 # Default
```

BackupLogPollerBlockDelay works in conjunction with Feature.LogPoller. Controls the block delay of Backup LogPoller, affecting how far behind the latest finalized block it starts and how often it runs.
BackupLogPollerDelay=0 will disable Backup LogPoller (not recommended for production environment).

### MinContractPayment
[Image: copy to clipboard]
```toml
MinContractPayment = '10000000000000 juels' # Default
```

MinContractPayment is the minimum payment in LINK required to execute a direct request job. This can be overridden on a per-job basis.

### MinIncomingConfirmations
[Image: copy to clipboard]
```toml
MinIncomingConfirmations = 3 # Default
```

MinIncomingConfirmations is the minimum required confirmations before a log event will be consumed.

### NonceAutoSync
[Image: copy to clipboard]
```toml
NonceAutoSync = true # Default
```

NonceAutoSync enables automatic nonce syncing on startup. Chainlink nodes will automatically try to sync its local nonce with the remote chain on startup and fast forward if necessary. This is almost always safe but can be disabled in exceptional cases by setting this value to false.

### NoNewHeadsThreshold
[Image: copy to clipboard]
```toml
NoNewHeadsThreshold = '3m' # Default
```

NoNewHeadsThreshold controls how long to wait after receiving no new heads before NodePool marks rpc endpoints as
out-of-sync, and HeadTracker logs warnings.

Set to zero to disable out-of-sync checking.

### OperatorFactoryAddress
[Image: copy to clipboard]
```toml
OperatorFactoryAddress = '0xa5B85635Be42F21f94F28034B7DA440EeFF0F418' # Example
```

OperatorFactoryAddress is the address of the canonical operator forwarder contract on the given chain. Note that this is usually autodetected from chain ID.

### RPCDefaultBatchSize
[Image: copy to clipboard]
```toml
RPCDefaultBatchSize = 250 # Default
```

RPCDefaultBatchSize is the default batch size for batched RPC calls.

### RPCBlockQueryDelay
[Image: caution]caution

ADVANCED:Do not change this setting unless you know what you are doing..asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }[Image: copy to clipboard]
```toml
RPCBlockQueryDelay = 1 # Default
```

RPCBlockQueryDelay controls the number of blocks to trail behind head in the block history estimator and balance monitor.
For example, if this is set to 3, and we receive block 10, block history estimator will fetch block 7.

CAUTION: You might be tempted to set this to 0 to use the latest possible
block, but it is possible to receive a head BEFORE that block is actually
available from the connected node via RPC, due to race conditions in the code of the remote ETH node. In this case you will get false
"zero" blocks that are missing transactions.

### FinalizedBlockOffset
[Image: copy to clipboard]
```toml
FinalizedBlockOffset = 0 # Default
```

FinalizedBlockOffset defines the number of blocks by which the latest finalized block will be shifted/delayed.
For example, suppose RPC returns block 100 as the latest finalized. In that case, the CL Node will treat block 100 - FinalizedBlockOffset as the latest finalized block and latest - FinalityDepth - FinalizedBlockOffset in case of FinalityTagEnabled = false.
With EnforceRepeatableRead = true, RPC is considered healthy only if its most recent finalized block is larger or equal to the highest finalized block observed by the CL Node minus FinalizedBlockOffset.
Higher values of FinalizedBlockOffset with EnforceRepeatableRead = true reduce the number of false FinalizedBlockOutOfSync declarations on healthy RPCs that are slightly lagging behind due to network delays.
This may increase the number of healthy RPCs and reduce the probability that the CL Node will not have any healthy alternatives to the active RPC.
CAUTION: Setting this to values higher than 0 may delay transaction creation in products (e.g., CCIP, Automation) that base their decision on finalized on-chain events.
PoS chains with FinalityTagEnabled=true and batched (epochs) blocks finalization (e.g., Ethereum Mainnet) must be treated with special care as a minor increase in the FinalizedBlockOffset may lead to significant delays.
For example, let's say that FinalizedBlockOffset = 1 and blocks are finalized in batches of 32.
The latest finalized block on chain is 64, so block 63 is the latest finalized for CL Node.
Block 64 will be treated as finalized by CL Node only when chain's latest finalized block is 65. As chain finalizes blocks in batches of 32,
CL Node has to wait for a whole new batch to be finalized to treat block 64 as finalized.

### LogBroadcasterEnabled
[Image: copy to clipboard]
```toml
LogBroadcasterEnabled = true # Default
```

LogBroadcasterEnabled is a feature flag for LogBroadcaster, by default it's true.

### NoNewFinalizedHeadsThreshold
[Image: copy to clipboard]
```toml
NoNewFinalizedHeadsThreshold = '0' # Default
```

NoNewFinalizedHeadsThreshold controls how long to wait for new finalized block before NodePool marks rpc endpoints as
out-of-sync. Only applicable if FinalityTagEnabled=true

Set to zero to disable.

## EVM.Transactions
[Image: copy to clipboard]
```toml
[EVM.Transactions]
ConfirmationTimeout = '60s' # Default
Enabled = true # Default
ForwardersEnabled = false # Default
MaxInFlight = 16 # Default
MaxQueued = 250 # Default
ReaperInterval = '1h' # Default
ReaperThreshold = '168h' # Default
ResendAfterThreshold = '1m' # Default
```

### ConfirmationTimeout
[Image: copy to clipboard]
```toml
ConfirmationTimeout = '60s' # Default
```

ConfirmationTimeout time to wait for a TX to get into a block in the blockchain. This is used for the EVMService.SubmitTransaction operation.

### Enabled
[Image: copy to clipboard]
```toml
Enabled = true # Default
```

Enabled is a feature flag for the Transaction Manager. This flag also enables or disables the gas estimator since it is dependent on the TXM to start it.

### ForwardersEnabled
[Image: copy to clipboard]
```toml
ForwardersEnabled = false # Default
```

ForwardersEnabled enables or disables sending transactions through forwarder contracts.

### MaxInFlight
[Image: copy to clipboard]
```toml
MaxInFlight = 16 # Default
```

MaxInFlight controls how many transactions are allowed to be "in-flight" i.e. broadcast but unconfirmed at any one time. You can consider this a form of transaction throttling.

The default is set conservatively at 16 because this is a pessimistic minimum that both geth and parity will hold without evicting local transactions. If your node is falling behind and you need higher throughput, you can increase this setting, but you MUST make sure that your ETH node is configured properly otherwise you can get nonce gapped and your node will get stuck.

0 value disables the limit. Use with caution.

### MaxQueued
[Image: copy to clipboard]
```toml
MaxQueued = 250 # Default
```

MaxQueued is the maximum number of unbroadcast transactions per key that are allowed to be enqueued before jobs will start failing and rejecting send of any further transactions. This represents a sanity limit and generally indicates a problem with your ETH node (transactions are not getting mined).

Do NOT blindly increase this value thinking it will fix things if you start hitting this limit because transactions are not getting mined, you will instead only make things worse.

In deployments with very high burst rates, or on chains with large re-orgs, you may consider increasing this.

0 value disables any limit on queue size. Use with caution.

### ReaperInterval
[Image: copy to clipboard]
```toml
ReaperInterval = '1h' # Default
```

ReaperInterval controls how often the EthTx reaper will run.

### ReaperThreshold
[Image: copy to clipboard]
```toml
ReaperThreshold = '168h' # Default
```

ReaperThreshold indicates how old an EthTx ought to be before it can be reaped.

### ResendAfterThreshold
[Image: copy to clipboard]
```toml
ResendAfterThreshold = '1m' # Default
```

ResendAfterThreshold controls how long to wait before re-broadcasting a transaction that has not yet been confirmed.

## EVM.Transactions.AutoPurge
[Image: copy to clipboard]
```toml
[EVM.Transactions.AutoPurge]
Enabled = false # Default
DetectionApiUrl = 'https://example.api.io' # Example
Threshold = 5 # Example
MinAttempts = 3 # Example
```

### Enabled
[Image: copy to clipboard]
```toml
Enabled = false # Default
```

Enabled enables or disables automatically purging transactions that have been idenitified as terminally stuck (will never be included on-chain). This feature is only expected to be used by ZK chains.

### DetectionApiUrl
[Image: copy to clipboard]
```toml
DetectionApiUrl = 'https://example.api.io' # Example
```

DetectionApiUrl configures the base url of a custom endpoint used to identify terminally stuck transactions.

### Threshold
[Image: copy to clipboard]
```toml
Threshold = 5 # Example
```

Threshold configures the number of blocks a transaction has to remain unconfirmed before it is evaluated for being terminally stuck. This threshold is only applied if there is no custom API to identify stuck transactions provided by the chain.

### MinAttempts
[Image: copy to clipboard]
```toml
MinAttempts = 3 # Example
```

MinAttempts configures the minimum number of broadcasted attempts a transaction has to have before it is evaluated further for being terminally stuck. This threshold is only applied if there is no custom API to identify stuck transactions provided by the chain. Ensure the gas estimator configs take more bump attempts before reaching the configured max gas price.

## EVM.Transactions.TransactionManagerV2
[Image: copy to clipboard]
```toml
[EVM.Transactions.TransactionManagerV2]
Enabled = false # Default
BlockTime = '10s' # Example
CustomURL = 'https://example.api.io' # Example
DualBroadcast = false # Example
```

### Enabled
[Image: copy to clipboard]
```toml
Enabled = false # Default
```

Enabled enables TransactionManagerV2.

### BlockTime
[Image: copy to clipboard]
```toml
BlockTime = '10s' # Example
```

BlockTime controls the frequency of the backfill loop of TransactionManagerV2.

### CustomURL
[Image: copy to clipboard]
```toml
CustomURL = 'https://example.api.io' # Example
```

CustomURL configures the base url of a custom endpoint used by the ChainDualBroadcast chain type.

### DualBroadcast
[Image: copy to clipboard]
```toml
DualBroadcast = false # Example
```

DualBroadcast enables DualBroadcast functionality.

## EVM.BalanceMonitor
[Image: copy to clipboard]
```toml
[EVM.BalanceMonitor]
Enabled = true # Default
```

### Enabled
[Image: copy to clipboard]
```toml
Enabled = true # Default
```

Enabled balance monitoring for all keys.

## EVM.GasEstimator
[Image: copy to clipboard]
```toml
[EVM.GasEstimator]
Mode = 'BlockHistory' # Default
PriceDefault = '20 gwei' # Default
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether' # Default
PriceMin = '1 gwei' # Default
LimitDefault = 500_000 # Default
LimitMax = 500_000 # Default
LimitMultiplier = '1.0' # Default
LimitTransfer = 21_000 # Default
EstimateLimit = false # Default
SenderAddress = '0x00c11c11c11C11c11C11c11c11C11C11c11C11c1' # Example
BumpMin = '5 gwei' # Default
BumpPercent = 20 # Default
BumpThreshold = 3 # Default
BumpTxDepth = 16 # Example
EIP1559DynamicFees = false # Default
FeeCapDefault = '100 gwei' # Default
TipCapDefault = '1 wei' # Default
TipCapMin = '1 wei' # Default
```

### Mode
[Image: copy to clipboard]
```toml
Mode = 'BlockHistory' # Default
```

Mode controls what type of gas estimator is used.

• FixedPrice uses static configured values for gas price (can be set via API call).
• BlockHistory dynamically adjusts default gas price based on heuristics from mined blocks.
• L2Suggested mode is deprecated and replaced with SuggestedPrice.
• SuggestedPrice is a mode which uses the gas price suggested by the rpc endpoint via eth_gasPrice.
• Arbitrum is a special mode only for use with Arbitrum blockchains. It uses the suggested gas price (up to ETH_MAX_GAS_PRICE_WEI, with 1000 gwei default) as well as an estimated gas limit (up to ETH_GAS_LIMIT_MAX, with 1,000,000,000 default).

Chainlink nodes decide what gas price to use using an Estimator. It ships with several simple and battle-hardened built-in estimators that should work well for almost all use-cases. Note that estimators will change their behaviour slightly depending on if you are in EIP-1559 mode or not.

You can also use your own estimator for gas price by selecting the FixedPrice estimator and using the exposed API to set the price.

An important point to note is that the Chainlink node does not ship with built-in support for go-ethereum's estimateGas call. This is for several reasons, including security and reliability. We have found empirically that it is not generally safe to rely on the remote ETH node's idea of what gas price should be.

### PriceDefault
[Image: copy to clipboard]
```toml
PriceDefault = '20 gwei' # Default
```

PriceDefault is the default gas price to use when submitting transactions to the blockchain. Will be overridden by the built-in BlockHistoryEstimator if enabled, and might be increased if gas bumping is enabled.

(Only applies to legacy transactions)

Can be used with the chainlink setgasprice to be updated while the node is still running.

### PriceMax
[Image: copy to clipboard]
```toml
PriceMax = '115792089237316195423570985008687907853269984665.640564039457584007913129639935 tether' # Default
```

PriceMax is the maximum gas price. Chainlink nodes will never pay more than this for a transaction.
This applies to both legacy and EIP1559 transactions.
Note that it is impossible to disable the maximum limit. Setting this value to zero will prevent paying anything for any transaction (which can be useful in some rare cases).
Most chains by default have the maximum set to 2**256-1 Wei which is the maximum allowed gas price on EVM-compatible chains, and is so large it may as well be unlimited.

### PriceMin
[Image: copy to clipboard]
```toml
PriceMin = '1 gwei' # Default
```

PriceMin is the minimum gas price. Chainlink nodes will never pay less than this for a transaction.

(Only applies to legacy transactions)

It is possible to force the Chainlink node to use a fixed gas price by setting a combination of these, e.g.

[Image: copy to clipboard]
```toml
EIP1559DynamicFees = false
PriceMax = 100
PriceMin = 100
PriceDefault = 100
BumpThreshold = 0
Mode = 'FixedPrice'
```

### LimitDefault
[Image: copy to clipboard]
```toml
LimitDefault = 500_000 # Default
```

LimitDefault sets default gas limit for outgoing transactions. This should not need to be changed in most cases.
Some job types, such as Keeper jobs, might set their own gas limit unrelated to this value.

### LimitMax
[Image: copy to clipboard]
```toml
LimitMax = 500_000 # Default
```

LimitMax sets a maximum for estimated gas limits. This currently only applies to Arbitrum GasEstimatorMode.

### LimitMultiplier
[Image: copy to clipboard]
```toml
LimitMultiplier = '1.0' # Default
```

LimitMultiplier is the factor by which a transaction's GasLimit is multiplied before transmission. So if the value is 1.1, and the GasLimit for a transaction is 10, 10% will be added before transmission.

This factor is always applied, so includes L2 transactions which uses a default gas limit of 1 and is also applied to LimitDefault.

### LimitTransfer
[Image: copy to clipboard]
```toml
LimitTransfer = 21_000 # Default
```

LimitTransfer is the gas limit used for an ordinary ETH transfer.

### EstimateLimit
[Image: copy to clipboard]
```toml
EstimateLimit = false # Default
```

EstimateLimit enables estimating gas limits for transactions. This feature respects the gas limit provided during transaction creation as an upper bound.

### SenderAddress
[Image: copy to clipboard]
```toml
SenderAddress = '0x00c11c11c11C11c11C11c11c11C11C11c11C11c1' # Example
```

SenderAddress is optional and can be set to a specific sender address for gas limit estimation (i.e. EstimateLimit = true). If gas limit estimation is not enabled, this parameter is ignored.

If you are using gas limit estimation:

• Setting SenderAddress is optional for most products. If it is set, the from address for the transaction for gas estimation will be set to the inputted SenderAddress. If it is not set, the actual address the transaction is sent from is used if available.
• Setting SenderAddress is necessary for gas limit estimation to function correctly for CCIP. Gas limit estimation works only in CCIP 1.6 and above if SenderAddress is set to the given example value (0x00c11c11c11C11c11C11c11c11C11C11c11C11c1). This value is hardcoded in the CCIP 1.6 contracts and is not needed for other products.

### BumpMin
[Image: copy to clipboard]
```toml
BumpMin = '5 gwei' # Default
```

BumpMin is the minimum fixed amount of wei by which gas is bumped on each transaction attempt.

### BumpPercent
[Image: copy to clipboard]
```toml
BumpPercent = 20 # Default
```

BumpPercent is the percentage by which to bump gas on a transaction that has exceeded BumpThreshold. The larger of BumpPercent and BumpMin is taken for gas bumps.

The SuggestedPriceEstimator adds the larger of BumpPercent and BumpMin on top of the price provided by the RPC when bumping a transaction's gas.

### BumpThreshold
[Image: copy to clipboard]
```toml
BumpThreshold = 3 # Default
```

BumpThreshold is the number of blocks to wait for a transaction stuck in the mempool before automatically bumping the gas price. Set to 0 to disable gas bumping completely.

### BumpTxDepth
[Image: copy to clipboard]
```toml
BumpTxDepth = 16 # Example
```

BumpTxDepth is the number of transactions to gas bump starting from oldest. Set to 0 for no limit (i.e. bump all). Can not be greater than EVM.Transactions.MaxInFlight. If not set, defaults to EVM.Transactions.MaxInFlight.

### EIP1559DynamicFees
[Image: copy to clipboard]
```toml
EIP1559DynamicFees = false # Default
```

EIP1559DynamicFees torces EIP-1559 transaction mode. Enabling EIP-1559 mode can help reduce gas costs on chains that support it. This is supported only on official Ethereum mainnet and testnets. It is not recommended to enable this setting on Polygon because the EIP-1559 fee market appears to be broken on all Polygon chains and EIP-1559 transactions are less likely to be included than legacy transactions.

#### Technical details
Chainlink nodes include experimental support for submitting transactions using type 0x2 (EIP-1559) envelope.

EIP-1559 mode is enabled by default on the Ethereum Mainnet, but can be enabled on a per-chain basis or globally.

This might help to save gas on spikes. Chainlink nodes should react faster on the upleg and avoid overpaying on the downleg. It might also be possible to set EVM.GasEstimator.BlockHistory.BatchSize to a smaller value such as 12 or even 6 because tip cap should be a more consistent indicator of inclusion time than total gas price. This would make Chainlink nodes more responsive and should reduce response time variance. Some experimentation is required to find optimum settings.

Set with caution, if you set this on a chain that does not actually support EIP-1559 your node will be broken.

In EIP-1559 mode, the total price for the transaction is the minimum of base fee + tip cap and fee cap. More information can be found on the official EIP.

Chainlink's implementation of EIP-1559 works as follows:

If you are using FixedPriceEstimator:

• With gas bumping disabled, it will submit all transactions with feecap=PriceMax and tipcap=GasTipCapDefault
• With gas bumping enabled, it will submit all transactions initially with feecap=GasFeeCapDefault and tipcap=GasTipCapDefault.

If you are using BlockHistoryEstimator (default for most chains):

• With gas bumping disabled, it will submit all transactions with feecap=PriceMax and tipcap=<calculated using past blocks>
• With gas bumping enabled (default for most chains) it will submit all transactions initially with feecap = ( current block base fee * (1.125 ^ N) + tipcap ) where N is configurable by setting EVM.GasEstimator.BlockHistory.EIP1559FeeCapBufferBlocks but defaults to gas bump threshold+1 and tipcap=<calculated using past blocks>

Bumping works as follows:

• Increase tipcap by max(tipcap * (1 + BumpPercent), tipcap + BumpMin)
• Increase feecap by max(feecap * (1 + BumpPercent), feecap + BumpMin)

A quick note on terminology - Chainlink nodes use the same terms used internally by go-ethereum source code to describe various prices. This is not the same as the externally used terms. For reference:

• Base Fee Per Gas = BaseFeePerGas
• Max Fee Per Gas = FeeCap
• Max Priority Fee Per Gas = TipCap

In EIP-1559 mode, the following changes occur to how configuration works:

• All new transactions will be sent as type 0x2 transactions specifying a TipCap and FeeCap. Be aware that existing pending legacy transactions will continue to be gas bumped in legacy mode.
• BlockHistoryEstimator will apply its calculations (gas percentile etc) to the TipCap and this value will be used for new transactions (GasPrice will be ignored)
• FixedPriceEstimator will use GasTipCapDefault instead of GasPriceDefault for the tip cap
• FixedPriceEstimator will use GasFeeCapDefault instead of GasPriceDefault for the fee cap
• PriceMin is ignored for new transactions and GasTipCapMinimum is used instead (default 0)
• PriceMax still represents that absolute upper limit that Chainlink will ever spend (total) on a single tx
• Keeper.GasTipCapBufferPercent is ignored in EIP-1559 mode and Keeper.GasTipCapBufferPercent is used instead

### FeeCapDefault
[Image: copy to clipboard]
```toml
FeeCapDefault = '100 gwei' # Default
```

FeeCapDefault controls the fixed initial fee cap, if EIP1559 mode is enabled and FixedPrice gas estimator is used.

### TipCapDefault
[Image: copy to clipboard]
```toml
TipCapDefault = '1 wei' # Default
```

TipCapDefault is the default gas tip to use when submitting transactions to the blockchain. Will be overridden by the built-in BlockHistoryEstimator if enabled, and might be increased if gas bumping is enabled.

(Only applies to EIP-1559 transactions)

### TipCapMin
[Image: copy to clipboard]
```toml
TipCapMin = '1 wei' # Default
```

TipCapMinimum is the minimum gas tip to use when submitting transactions to the blockchain.

(Only applies to EIP-1559 transactions)

## EVM.GasEstimator.DAOracle
[Image: copy to clipboard]
```toml
[EVM.GasEstimator.DAOracle]
OracleType = 'opstack' # Example
OracleAddress = '0x420000000000000000000000000000000000000F' # Example
CustomGasPriceCalldata = '' # Default
```

### OracleType
[Image: copy to clipboard]
```toml
OracleType = 'opstack' # Example
```

OracleType refers to the oracle family this config belongs to. Currently the available oracle types are: 'opstack', 'arbitrum', 'zksync', and 'custom_calldata'.

### OracleAddress
[Image: copy to clipboard]
```toml
OracleAddress = '0x420000000000000000000000000000000000000F' # Example
```

OracleAddress is the address of the oracle contract.

### CustomGasPriceCalldata
[Image: copy to clipboard]
```toml
CustomGasPriceCalldata = '' # Default
```

CustomGasPriceCalldata is optional and can be set to call a custom gas price function at the given OracleAddress.

## EVM.GasEstimator.LimitJobType
[Image: copy to clipboard]
```toml
[EVM.GasEstimator.LimitJobType]
OCR = 100_000 # Example
OCR2 = 100_000 # Example
DR = 100_000 # Example
VRF = 100_000 # Example
FM = 100_000 # Example
Keeper = 100_000 # Example
```

### OCR
[Image: copy to clipboard]
```toml
OCR = 100_000 # Example
```

OCR overrides LimitDefault for OCR jobs.

### OCR2
[Image: copy to clipboard]
```toml
OCR2 = 100_000 # Example
```

OCR2 overrides LimitDefault for OCR2 jobs.

### DR
[Image: copy to clipboard]
```toml
DR = 100_000 # Example
```

DR overrides LimitDefault for Direct Request jobs.

### VRF
[Image: copy to clipboard]
```toml
VRF = 100_000 # Example
```

VRF overrides LimitDefault for VRF jobs.

### FM
[Image: copy to clipboard]
```toml
FM = 100_000 # Example
```

FM overrides LimitDefault for Flux Monitor jobs.

### Keeper
[Image: copy to clipboard]
```toml
Keeper = 100_000 # Example
```

Keeper overrides LimitDefault for Keeper jobs.

## EVM.GasEstimator.BlockHistory
[Image: copy to clipboard]
```toml
[EVM.GasEstimator.BlockHistory]
BatchSize = 25 # Default
BlockHistorySize = 8 # Default
CheckInclusionBlocks = 12 # Default
CheckInclusionPercentile = 90 # Default
EIP1559FeeCapBufferBlocks = 13 # Example
TransactionPercentile = 60 # Default
```

These settings allow you to configure how your node calculates gas prices when using the block history estimator.
In most cases, leaving these values at their defaults should give good results.

### BatchSize
[Image: copy to clipboard]
```toml
BatchSize = 25 # Default
```

BatchSize sets the maximum number of blocks to fetch in one batch in the block history estimator.
If the BatchSize variable is set to 0, it defaults to EVM.RPCDefaultBatchSize.

### BlockHistorySize
[Image: copy to clipboard]
```toml
BlockHistorySize = 8 # Default
```

BlockHistorySize controls the number of past blocks to keep in memory to use as a basis for calculating a percentile gas price.

### CheckInclusionBlocks
[Image: copy to clipboard]
```toml
CheckInclusionBlocks = 12 # Default
```

CheckInclusionBlocks is the number of recent blocks to use to detect if there is a transaction propagation/connectivity issue, and to prevent bumping in these cases.
This can help avoid the situation where RPC nodes are not propagating transactions for some non-price-related reason (e.g. go-ethereum bug, networking issue etc) and bumping gas would not help.

Set to zero to disable connectivity checking completely.

### CheckInclusionPercentile
[Image: copy to clipboard]
```toml
CheckInclusionPercentile = 90 # Default
```

CheckInclusionPercentile controls the percentile that a transaction must have been higher than for all the blocks in the inclusion check window in order to register as a connectivity issue.

For example, if CheckInclusionBlocks=12 and CheckInclusionPercentile=90 then further bumping will be prevented for any transaction with any attempt that has a higher price than the 90th percentile for the most recent 12 blocks.

### EIP1559FeeCapBufferBlocks
[Image: caution]caution

ADVANCED:Do not change this setting unless you know what you are doing..asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }[Image: copy to clipboard]
```toml
EIP1559FeeCapBufferBlocks = 13 # Example
```

EIP1559FeeCapBufferBlocks controls the buffer blocks to add to the current base fee when sending a transaction. By default, the gas bumping threshold + 1 block is used.

(Only applies to EIP-1559 transactions)

### TransactionPercentile
[Image: copy to clipboard]
```toml
TransactionPercentile = 60 # Default
```

TransactionPercentile specifies gas price to choose. E.g. if the block history contains four transactions with gas prices [100, 200, 300, 400] then picking 25 for this number will give a value of 200. If the calculated gas price is higher than GasPriceDefault then the higher price will be used as the base price for new transactions.

Must be in range 0-100.

Only has an effect if gas updater is enabled.

Think of this number as an indicator of how aggressive you want your node to price its transactions.

Setting this number higher will cause the Chainlink node to select higher gas prices.

Setting it lower will tend to set lower gas prices.

## EVM.GasEstimator.FeeHistory
[Image: copy to clipboard]
```toml
[EVM.GasEstimator.FeeHistory]
CacheTimeout = '10s' # Default
```

### CacheTimeout
[Image: copy to clipboard]
```toml
CacheTimeout = '10s' # Default
```

CacheTimeout is the time to wait in order to refresh the cached values stored in the FeeHistory estimator. A small jitter is applied so the timeout won't be exactly the same each time.

You want this value to be close to the block time. For slower chains, like Ethereum, you can set it to 12s, the same as the block time. For faster chains you can skip a block or two
and set it to two times the block time i.e. on Optimism you can set it to 4s. Ideally, you don't want to go lower than 1s since the RTT times of the RPC requests will be comparable to
the timeout. The estimator is already adding a buffer to account for a potential increase in prices within one or two blocks. On the other hand, slower frequency will fail to refresh
the prices and end up in stale values.

## EVM.HeadTracker
[Image: copy to clipboard]
```toml
[EVM.HeadTracker]
HistoryDepth = 100 # Default
MaxBufferSize = 3 # Default
SamplingInterval = '1s' # Default
FinalityTagBypass = false # Default
MaxAllowedFinalityDepth = 10000 # Default
PersistenceEnabled = true # Default
```

The head tracker continually listens for new heads from the chain.

In addition to these settings, it log warnings if EVM.NoNewHeadsThreshold is exceeded without any new blocks being emitted.

### HistoryDepth
[Image: copy to clipboard]
```toml
HistoryDepth = 100 # Default
```

HistoryDepth tracks the top N blocks on top of the latest finalized block to keep in the heads database table.
Note that this can easily result in MORE than N + finality depth records since in the case of re-orgs we keep multiple heads for a particular block height.
Higher values help reduce number of RPC requests performed by TXM's Finalizer and improve TXM's Confirmer reorg protection on restarts.
At the same time, setting the value too high could lead to higher CPU consumption. The following formula could be used to calculate the optimal value: expected_downtime_on_restart/block_time.

### MaxBufferSize
[Image: copy to clipboard]
```toml
MaxBufferSize = 3 # Default
```

MaxBufferSize is the maximum number of heads that may be
buffered in front of the head tracker before older heads start to be
dropped. You may think of it as something like the maximum permittable "lag"
for the head tracker before we start dropping heads to keep up.

### SamplingInterval
[Image: caution]caution

ADVANCED:Do not change this setting unless you know what you are doing..asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }[Image: copy to clipboard]
```toml
SamplingInterval = '1s' # Default
```

SamplingInterval means that head tracker callbacks will at maximum be made once in every window of this duration. This is a performance optimisation for fast chains. Set to 0 to disable sampling entirely.

### FinalityTagBypass
[Image: copy to clipboard]
```toml
FinalityTagBypass = false # Default
```

FinalityTagBypass disables FinalityTag support in HeadTracker and makes it track blocks up to FinalityDepth from the most recent head.
It should only be used on chains with an extremely large actual finality depth (the number of blocks between the most recent head and the latest finalized block).
Has no effect if FinalityTagsEnabled = false

### MaxAllowedFinalityDepth
[Image: copy to clipboard]
```toml
MaxAllowedFinalityDepth = 10000 # Default
```

MaxAllowedFinalityDepth - defines maximum number of blocks between the most recent head and the latest finalized block.
If actual finality depth exceeds this number, HeadTracker aborts backfill and returns an error.
Has no effect if FinalityTagsEnabled = false

### PersistenceEnabled
[Image: copy to clipboard]
```toml
PersistenceEnabled = true # Default
```

PersistenceEnabled defines whether HeadTracker needs to store heads in the database.
Persistence is helpful on chains with large finality depth, where fetching blocks from the latest to the latest finalized takes a lot of time.
On chains with fast finality, the persistence layer does not improve the chain's load time and only consumes database resources (mainly IO).
NOTE: persistence should not be disabled for products that use LogBroadcaster, as it might lead to missed on-chain events.

## EVM.KeySpecific
[Image: copy to clipboard]
```toml
[[EVM.KeySpecific]]
Key = '0x2a3e23c6f242F5345320814aC8a1b4E58707D292' # Example
GasEstimator.PriceMax = '79 gwei' # Example
```

### Key
[Image: copy to clipboard]
```toml
Key = '0x2a3e23c6f242F5345320814aC8a1b4E58707D292' # Example
```

Key is the account to apply these settings to

### PriceMax
[Image: copy to clipboard]
```toml
GasEstimator.PriceMax = '79 gwei' # Example
```

GasEstimator.PriceMax overrides the maximum gas price for this key. See EVM.GasEstimator.PriceMax.

## EVM.NodePool
[Image: copy to clipboard]
```toml
[EVM.NodePool]
PollFailureThreshold = 5 # Default
PollInterval = '10s' # Default
SelectionMode = 'HighestHead' # Default
SyncThreshold = 5 # Default
LeaseDuration = '0s' # Default
NodeIsSyncingEnabled = false # Default
FinalizedBlockPollInterval = '5s' # Default
EnforceRepeatableRead = true # Default
DeathDeclarationDelay = '1m' # Default
NewHeadsPollInterval = '0s' # Default
VerifyChainID = true # Default
```

The node pool manages multiple RPC endpoints.

In addition to these settings, EVM.NoNewHeadsThreshold controls how long to wait after receiving no new heads before marking the node as out-of-sync.

### PollFailureThreshold
[Image: copy to clipboard]
```toml
PollFailureThreshold = 5 # Default
```

PollFailureThreshold indicates how many consecutive polls must fail in order to mark a node as unreachable.

Set to zero to disable poll checking.

### PollInterval
[Image: copy to clipboard]
```toml
PollInterval = '10s' # Default
```

PollInterval controls how often to poll the node to check for liveness.

Set to zero to disable poll checking.

### SelectionMode
[Image: copy to clipboard]
```toml
SelectionMode = 'HighestHead' # Default
```

SelectionMode controls node selection strategy:

• HighestHead: use the node with the highest head number
• RoundRobin: rotate through nodes, per-request
• PriorityLevel: use the node with the smallest order number
• TotalDifficulty: use the node with the greatest total difficulty

### SyncThreshold
[Image: copy to clipboard]
```toml
SyncThreshold = 5 # Default
```

SyncThreshold controls how far a node may lag behind the best node before being marked out-of-sync.
Depending on SelectionMode, this represents a difference in the number of blocks (HighestHead, RoundRobin, PriorityLevel), or total difficulty (TotalDifficulty).

Set to 0 to disable this check.

### LeaseDuration
[Image: copy to clipboard]
```toml
LeaseDuration = '0s' # Default
```

LeaseDuration is the minimum duration that the selected "best" node (as defined by SelectionMode) will be used,
before switching to a better one if available. It also controls how often the lease check is done.
Setting this to a low value (under 1m) might cause RPC to switch too aggressively.
Recommended value is over 5m

Set to '0s' to disable

### NodeIsSyncingEnabled
[Image: copy to clipboard]
```toml
NodeIsSyncingEnabled = false # Default
```

NodeIsSyncingEnabled is a flag that enables syncing health check on each reconnection to an RPC.
Node transitions and remains in Syncing state while RPC signals this state (In case of Ethereum eth_syncing returns anything other than false).
All of the requests to node in state Syncing are rejected.

Set true to enable this check

### FinalizedBlockPollInterval
[Image: copy to clipboard]
```toml
FinalizedBlockPollInterval = '5s' # Default
```

FinalizedBlockPollInterval controls how often to poll RPC for new finalized blocks.
The finalized block is only used to report to the pool_rpc_node_highest_finalized_block metric. We plan to use it
in RPCs health assessment in the future.
If FinalityTagEnabled = false, poll is not performed and pool_rpc_node_highest_finalized_block is
reported based on latest block and finality depth.

Set to 0 to disable.

### EnforceRepeatableRead
[Image: copy to clipboard]
```toml
EnforceRepeatableRead = true # Default
```

EnforceRepeatableRead defines if Core should only use RPCs whose most recently finalized block is greater or equal to
highest finalized block - FinalizedBlockOffset. In other words, exclude RPCs lagging on latest finalized
block.

Set false to disable

### DeathDeclarationDelay
[Image: copy to clipboard]
```toml
DeathDeclarationDelay = '1m' # Default
```

DeathDeclarationDelay defines the minimum duration an RPC must be in unhealthy state before producing an error log message.
Larger values might be helpful to reduce the noisiness of health checks like EnforceRepeatableRead = true', which might be falsely trigger declaration of FinalizedBlockOutOfSyncdue to insignificant network delays in broadcasting of the finalized state among RPCs. Should be greater thanFinalizedBlockPollInterval`.
Unhealthy RPC will not be picked to handle a request even if this option is set to a nonzero value.

### NewHeadsPollInterval
[Image: copy to clipboard]
```toml
NewHeadsPollInterval = '0s' # Default
```

NewHeadsPollInterval define an interval for polling new block periodically using http client rather than subscribe to ws feed

Set to 0 to disable.

### VerifyChainID
[Image: copy to clipboard]
```toml
VerifyChainID = true # Default
```

VerifyChainID enforces RPC Client ChainIDs to match configured ChainID

## EVM.NodePool.Errors
[Image: caution]caution

ADVANCED:Do not change these settings unless you know what you are doing..asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }[Image: copy to clipboard]
```toml
[EVM.NodePool.Errors]
NonceTooLow = '(: |^)nonce too low' # Example
NonceTooHigh = '(: |^)nonce too high' # Example
ReplacementTransactionUnderpriced = '(: |^)replacement transaction underpriced' # Example
LimitReached = '(: |^)limit reached' # Example
TransactionAlreadyInMempool = '(: |^)transaction already in mempool' # Example
TerminallyUnderpriced = '(: |^)terminally underpriced' # Example
InsufficientEth = '(: |^)insufficeint eth' # Example
TxFeeExceedsCap = '(: |^)tx fee exceeds cap' # Example
L2FeeTooLow = '(: |^)l2 fee too low' # Example
L2FeeTooHigh = '(: |^)l2 fee too high' # Example
L2Full = '(: |^)l2 full' # Example
TransactionAlreadyMined = '(: |^)transaction already mined' # Example
Fatal = '(: |^)fatal' # Example
ServiceUnavailable = '(: |^)service unavailable' # Example
TooManyResults = '(: |^)too many results' # Example
MissingBlocks = '(: |^)missing blocks' # Example
```

Errors enable the node to provide custom regex patterns to match against error messages from RPCs.

### NonceTooLow
[Image: copy to clipboard]
```toml
NonceTooLow = '(: |^)nonce too low' # Example
```

NonceTooLow is a regex pattern to match against nonce too low errors.

### NonceTooHigh
[Image: copy to clipboard]
```toml
NonceTooHigh = '(: |^)nonce too high' # Example
```

NonceTooHigh is a regex pattern to match against nonce too high errors.

### ReplacementTransactionUnderpriced
[Image: copy to clipboard]
```toml
ReplacementTransactionUnderpriced = '(: |^)replacement transaction underpriced' # Example
```

ReplacementTransactionUnderpriced is a regex pattern to match against replacement transaction underpriced errors.

### LimitReached
[Image: copy to clipboard]
```toml
LimitReached = '(: |^)limit reached' # Example
```

LimitReached is a regex pattern to match against limit reached errors.

### TransactionAlreadyInMempool
[Image: copy to clipboard]
```toml
TransactionAlreadyInMempool = '(: |^)transaction already in mempool' # Example
```

TransactionAlreadyInMempool is a regex pattern to match against transaction already in mempool errors.

### TerminallyUnderpriced
[Image: copy to clipboard]
```toml
TerminallyUnderpriced = '(: |^)terminally underpriced' # Example
```

TerminallyUnderpriced is a regex pattern to match against terminally underpriced errors.

### InsufficientEth
[Image: copy to clipboard]
```toml
InsufficientEth = '(: |^)insufficeint eth' # Example
```

InsufficientEth is a regex pattern to match against insufficient eth errors.

### TxFeeExceedsCap
[Image: copy to clipboard]
```toml
TxFeeExceedsCap = '(: |^)tx fee exceeds cap' # Example
```

TxFeeExceedsCap is a regex pattern to match against tx fee exceeds cap errors.

### L2FeeTooLow
[Image: copy to clipboard]
```toml
L2FeeTooLow = '(: |^)l2 fee too low' # Example
```

L2FeeTooLow is a regex pattern to match against l2 fee too low errors.

### L2FeeTooHigh
[Image: copy to clipboard]
```toml
L2FeeTooHigh = '(: |^)l2 fee too high' # Example
```

L2FeeTooHigh is a regex pattern to match against l2 fee too high errors.

### L2Full
[Image: copy to clipboard]
```toml
L2Full = '(: |^)l2 full' # Example
```

L2Full is a regex pattern to match against l2 full errors.

### TransactionAlreadyMined
[Image: copy to clipboard]
```toml
TransactionAlreadyMined = '(: |^)transaction already mined' # Example
```

TransactionAlreadyMined is a regex pattern to match against transaction already mined errors.

### Fatal
[Image: copy to clipboard]
```toml
Fatal = '(: |^)fatal' # Example
```

Fatal is a regex pattern to match against fatal errors.

### ServiceUnavailable
[Image: copy to clipboard]
```toml
ServiceUnavailable = '(: |^)service unavailable' # Example
```

ServiceUnavailable is a regex pattern to match against service unavailable errors.

### TooManyResults
[Image: copy to clipboard]
```toml
TooManyResults = '(: |^)too many results' # Example
```

TooManyResults is a regex pattern to match an eth_getLogs error indicating the result set is too large to return

### MissingBlocks
[Image: copy to clipboard]
```toml
MissingBlocks = '(: |^)missing blocks' # Example
```

MissingBlocks is a regex pattern to match an eth_getLogs error indicating the rpc server is permanently missing some blocks in the requested block range

## EVM.OCR
[Image: copy to clipboard]
```toml
[EVM.OCR]
ContractConfirmations = 4 # Default
ContractTransmitterTransmitTimeout = '10s' # Default
DatabaseTimeout = '10s' # Default
DeltaCOverride = "168h" # Default
DeltaCJitterOverride = "1h" # Default
ObservationGracePeriod = '1s' # Default
```

### ContractConfirmations
[Image: copy to clipboard]
```toml
ContractConfirmations = 4 # Default
```

ContractConfirmations sets OCR.ContractConfirmations for this EVM chain.

### ContractTransmitterTransmitTimeout
[Image: copy to clipboard]
```toml
ContractTransmitterTransmitTimeout = '10s' # Default
```

ContractTransmitterTransmitTimeout sets OCR.ContractTransmitterTransmitTimeout for this EVM chain.

### DatabaseTimeout
[Image: copy to clipboard]
```toml
DatabaseTimeout = '10s' # Default
```

DatabaseTimeout sets OCR.DatabaseTimeout for this EVM chain.

### DeltaCOverride
[Image: caution]caution

ADVANCED:Do not change this setting unless you know what you are doing..asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }[Image: copy to clipboard]
```toml
DeltaCOverride = "168h" # Default
```

DeltaCOverride (and DeltaCJitterOverride) determine the config override DeltaC.
DeltaC is the maximum age of the latest report in the contract. If the maximum age is exceeded, a new report will be
created by the report generation protocol.

### DeltaCJitterOverride
[Image: caution]caution

ADVANCED:Do not change this setting unless you know what you are doing..asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }[Image: copy to clipboard]
```toml
DeltaCJitterOverride = "1h" # Default
```

DeltaCJitterOverride is the range for jitter to add to DeltaCOverride.

### ObservationGracePeriod
[Image: copy to clipboard]
```toml
ObservationGracePeriod = '1s' # Default
```

ObservationGracePeriod sets OCR.ObservationGracePeriod for this EVM chain.

## EVM.Nodes
[Image: copy to clipboard]
```toml
[[EVM.Nodes]]
Name = 'foo' # Example
WSURL = 'wss://web.socket/test' # Example
HTTPURL = 'https://foo.web' # Example
HTTPURLExtraWrite = 'https://foo.web/extra' # Example
SendOnly = false # Default
Order = 100 # Default
```

### Name
[Image: copy to clipboard]
```toml
Name = 'foo' # Example
```

Name is a unique (per-chain) identifier for this node.

### WSURL
[Image: copy to clipboard]
```toml
WSURL = 'wss://web.socket/test' # Example
```

WSURL is the WS(S) endpoint for this node. Required for primary nodes when LogBroadcasterEnabled is true

### HTTPURL
[Image: copy to clipboard]
```toml
HTTPURL = 'https://foo.web' # Example
```

HTTPURL is the HTTP(S) endpoint for this node. Required for all nodes.

### HTTPURLExtraWrite
[Image: copy to clipboard]
```toml
HTTPURLExtraWrite = 'https://foo.web/extra' # Example
```

HTTPURLExtraWrite is the HTTP(S) endpoint used for chains that require a separate endpoint for writing on-chain.

### SendOnly
[Image: copy to clipboard]
```toml
SendOnly = false # Default
```

SendOnly limits usage to sending transaction broadcasts only. With this enabled, only HTTPURL is required, and WSURL is not used.

### Order
[Image: copy to clipboard]
```toml
Order = 100 # Default
```

Order of the node in the pool, will takes effect if SelectionMode is PriorityLevel or will be used as a tie-breaker for HighestHead and TotalDifficulty

## EVM.OCR2.Automation
[Image: copy to clipboard]
```toml
[EVM.OCR2.Automation]
GasLimit = 5400000 # Default
```

### GasLimit
[Image: copy to clipboard]
```toml
GasLimit = 5400000 # Default
```

GasLimit controls the gas limit for transmit transactions from ocr2automation job.

## EVM.Workflow
[Image: copy to clipboard]
```toml
[EVM.Workflow]
FromAddress = '0x2a3e23c6f242F5345320814aC8a1b4E58707D292' # Example
ForwarderAddress = '0x2a3e23c6f242F5345320814aC8a1b4E58707D292' # Example
GasLimitDefault = 400_000 # Default
TxAcceptanceState = 2 # Default
PollPeriod = '2s' # Default
AcceptanceTimeout = '30s' # Default
```

### FromAddress
[Image: copy to clipboard]
```toml
FromAddress = '0x2a3e23c6f242F5345320814aC8a1b4E58707D292' # Example
```

FromAddress is Address of the transmitter key to use for workflow writes.

### ForwarderAddress
[Image: copy to clipboard]
```toml
ForwarderAddress = '0x2a3e23c6f242F5345320814aC8a1b4E58707D292' # Example
```

ForwarderAddress is the keystone forwarder contract address on chain.

### GasLimitDefault
[Image: copy to clipboard]
```toml
GasLimitDefault = 400_000 # Default
```

GasLimitDefault is the default gas limit for workflow transactions.

### TxAcceptanceState
[Image: copy to clipboard]
```toml
TxAcceptanceState = 2 # Default
```

TxAcceptanceState is the default acceptance state for writer DON tranmissions.

### PollPeriod
[Image: copy to clipboard]
```toml
PollPeriod = '2s' # Default
```

PollPeriod is the default poll period for checking transmission state

### AcceptanceTimeout
[Image: copy to clipboard]
```toml
AcceptanceTimeout = '30s' # Default
```

AcceptanceTimeout is the default timeout for a tranmission to be accepted on chain

## Cosmos
[Image: copy to clipboard]
```toml
[[Cosmos]]
ChainID = 'Malaga-420' # Example
Enabled = true # Default
Bech32Prefix = 'wasm' # Default
BlockRate = '6s' # Default
BlocksUntilTxTimeout = 30 # Default
ConfirmPollPeriod = '1s' # Default
FallbackGasPrice = '0.015' # Default
GasToken = 'ucosm' # Default
GasLimitMultiplier = '1.5' # Default
MaxMsgsPerBatch = 100 # Default
OCR2CachePollPeriod = '4s' # Default
OCR2CacheTTL = '1m' # Default
TxMsgTimeout = '10m' # Default
```

### ChainID
[Image: copy to clipboard]
```toml
ChainID = 'Malaga-420' # Example
```

ChainID is the Cosmos chain ID. Mandatory.

### Enabled
[Image: copy to clipboard]
```toml
Enabled = true # Default
```

Enabled enables this chain.

### Bech32Prefix
[Image: copy to clipboard]
```toml
Bech32Prefix = 'wasm' # Default
```

Bech32Prefix is the human-readable prefix for addresses on this Cosmos chain. See https://docs.cosmos.network/v0.47/spec/addresses/bech32.

### BlockRate
[Image: copy to clipboard]
```toml
BlockRate = '6s' # Default
```

BlockRate is the average time between blocks.

### BlocksUntilTxTimeout
[Image: copy to clipboard]
```toml
BlocksUntilTxTimeout = 30 # Default
```

BlocksUntilTxTimeout is the number of blocks to wait before giving up on the tx getting confirmed.

### ConfirmPollPeriod
[Image: copy to clipboard]
```toml
ConfirmPollPeriod = '1s' # Default
```

ConfirmPollPeriod sets how often check for tx confirmation.

### FallbackGasPrice
[Image: copy to clipboard]
```toml
FallbackGasPrice = '0.015' # Default
```

FallbackGasPrice sets a fallback gas price to use when the estimator is not available.

### GasToken
[Image: copy to clipboard]
```toml
GasToken = 'ucosm' # Default
```

GasToken is the token denomination which is being used to pay gas fees on this chain.

### GasLimitMultiplier
[Image: copy to clipboard]
```toml
GasLimitMultiplier = '1.5' # Default
```

GasLimitMultiplier scales the estimated gas limit.

### MaxMsgsPerBatch
[Image: copy to clipboard]
```toml
MaxMsgsPerBatch = 100 # Default
```

MaxMsgsPerBatch limits the numbers of messages per transaction batch.

### OCR2CachePollPeriod
[Image: copy to clipboard]
```toml
OCR2CachePollPeriod = '4s' # Default
```

OCR2CachePollPeriod is the rate to poll for the OCR2 state cache.

### OCR2CacheTTL
[Image: copy to clipboard]
```toml
OCR2CacheTTL = '1m' # Default
```

OCR2CacheTTL is the stale OCR2 cache deadline.

### TxMsgTimeout
[Image: copy to clipboard]
```toml
TxMsgTimeout = '10m' # Default
```

TxMsgTimeout is the maximum age for resending transaction before they expire.

## Cosmos.Nodes
[Image: copy to clipboard]
```toml
[[Cosmos.Nodes]]
Name = 'primary' # Example
TendermintURL = 'http://tender.mint' # Example
```

### Name
[Image: copy to clipboard]
```toml
Name = 'primary' # Example
```

Name is a unique (per-chain) identifier for this node.

### TendermintURL
[Image: copy to clipboard]
```toml
TendermintURL = 'http://tender.mint' # Example
```

TendermintURL is the HTTP(S) tendermint endpoint for this node.

## Solana
[Image: copy to clipboard]
```toml
[[Solana]]
ChainID = 'mainnet' # Example
Enabled = false # Default
BlockTime = '500ms' # Default
BalancePollPeriod = '5s' # Default
ConfirmPollPeriod = '500ms' # Default
OCR2CachePollPeriod = '1s' # Default
OCR2CacheTTL = '1m' # Default
TxTimeout = '1m' # Default
TxRetryTimeout = '10s' # Default
TxConfirmTimeout = '30s' # Default
TxExpirationRebroadcast = false # Default
TxRetentionTimeout = '0s' # Default
SkipPreflight = true # Default
Commitment = 'confirmed' # Default
MaxRetries = 0 # Default
FeeEstimatorMode = 'fixed' # Default
ComputeUnitPriceMax = 1000 # Default
ComputeUnitPriceMin = 0 # Default
ComputeUnitPriceDefault = 0 # Default
FeeBumpPeriod = '3s' # Default
BlockHistoryPollPeriod = '5s' # Default
BlockHistorySize = 1 # Default
BlockHistoryBatchLoadSize = 20 # Default
ComputeUnitLimitDefault = 200_000 # Default
EstimateComputeUnitLimit = false # Default
LogPollerStartingLookback = '24h0m0s' # Default
```

### ChainID
[Image: copy to clipboard]
```toml
ChainID = 'mainnet' # Example
```

ChainID is the Solana chain ID. Must be one of: mainnet, testnet, devnet, localnet. Mandatory.

### Enabled
[Image: copy to clipboard]
```toml
Enabled = false # Default
```

Enabled enables this chain.

### BlockTime
[Image: copy to clipboard]
```toml
BlockTime = '500ms' # Default
```

BlockTime specifies the average time between blocks on this chain

### BalancePollPeriod
[Image: copy to clipboard]
```toml
BalancePollPeriod = '5s' # Default
```

BalancePollPeriod is the rate to poll for SOL balance and update Prometheus metrics.

### ConfirmPollPeriod
[Image: copy to clipboard]
```toml
ConfirmPollPeriod = '500ms' # Default
```

ConfirmPollPeriod is the rate to poll for signature confirmation.

### OCR2CachePollPeriod
[Image: copy to clipboard]
```toml
OCR2CachePollPeriod = '1s' # Default
```

OCR2CachePollPeriod is the rate to poll for the OCR2 state cache.

### OCR2CacheTTL
[Image: copy to clipboard]
```toml
OCR2CacheTTL = '1m' # Default
```

OCR2CacheTTL is the stale OCR2 cache deadline.

### TxTimeout
[Image: copy to clipboard]
```toml
TxTimeout = '1m' # Default
```

TxTimeout is the timeout for sending txes to an RPC endpoint.

### TxRetryTimeout
[Image: copy to clipboard]
```toml
TxRetryTimeout = '10s' # Default
```

TxRetryTimeout is the duration for tx manager to attempt rebroadcasting to RPC, before giving up.

### TxConfirmTimeout
[Image: copy to clipboard]
```toml
TxConfirmTimeout = '30s' # Default
```

TxConfirmTimeout is the duration to wait when confirming a tx signature, before discarding as unconfirmed.

### TxExpirationRebroadcast
[Image: copy to clipboard]
```toml
TxExpirationRebroadcast = false # Default
```

TxExpirationRebroadcast enables or disables transaction rebroadcast if expired. Expiration check is performed every ConfirmPollPeriod
A transaction is considered expired if the blockhash it was sent with is 150 blocks older than the latest blockhash.

### TxRetentionTimeout
[Image: copy to clipboard]
```toml
TxRetentionTimeout = '0s' # Default
```

TxRetentionTimeout is the duration to retain transactions in storage after being marked as finalized or errored. Set to 0 to immediately drop transactions.

### SkipPreflight
[Image: copy to clipboard]
```toml
SkipPreflight = true # Default
```

SkipPreflight enables or disables preflight checks when sending txs.

### Commitment
[Image: copy to clipboard]
```toml
Commitment = 'confirmed' # Default
```

Commitment is the confirmation level for solana state and transactions. (documentation)

### MaxRetries
[Image: copy to clipboard]
```toml
MaxRetries = 0 # Default
```

MaxRetries is the maximum number of times the RPC node will automatically rebroadcast a tx.
The default is 0 for custom txm rebroadcasting method, set to -1 to use the RPC node's default retry strategy.

### FeeEstimatorMode
[Image: copy to clipboard]
```toml
FeeEstimatorMode = 'fixed' # Default
```

FeeEstimatorMode is the method used to determine the base fee

### ComputeUnitPriceMax
[Image: copy to clipboard]
```toml
ComputeUnitPriceMax = 1000 # Default
```

ComputeUnitPriceMax is the maximum price per compute unit that a transaction can be bumped to

### ComputeUnitPriceMin
[Image: copy to clipboard]
```toml
ComputeUnitPriceMin = 0 # Default
```

ComputeUnitPriceMin is the minimum price per compute unit that transaction can have

### ComputeUnitPriceDefault
[Image: copy to clipboard]
```toml
ComputeUnitPriceDefault = 0 # Default
```

ComputeUnitPriceDefault is the default price per compute unit price, and the starting base fee when FeeEstimatorMode = 'fixed'

### FeeBumpPeriod
[Image: copy to clipboard]
```toml
FeeBumpPeriod = '3s' # Default
```

FeeBumpPeriod is the amount of time before a tx is retried with a fee bump. WARNING: If FeeBumpPeriod is shorter than blockhash expiration, multiple valid transactions can exist in parallel. This can result in higher costs and can cause unexpected behaviors if contracts do not de-dupe txs

### BlockHistoryPollPeriod
[Image: copy to clipboard]
```toml
BlockHistoryPollPeriod = '5s' # Default
```

BlockHistoryPollPeriod is the rate to poll for blocks in the block history fee estimator

### BlockHistorySize
[Image: copy to clipboard]
```toml
BlockHistorySize = 1 # Default
```

BlockHistorySize is the number of blocks to take into consideration when using FeeEstimatorMode = 'blockhistory' to determine compute unit price.
If set to 1, the compute unit price will be determined by the median of the last block's compute unit prices.
If set N > 1, the compute unit price will be determined by the average of the medians of the last N blocks' compute unit prices.
DISCLAIMER: If set to a value greater than BlockHistoryBatchLoadSize, initial estimations during startup would be over smaller block ranges until the cache is filled.

### BlockHistoryBatchLoadSize
[Image: copy to clipboard]
```toml
BlockHistoryBatchLoadSize = 20 # Default
```

BlockHistoryBatchLoadSize is the number of latest blocks to fetch from the chain to store in the cache every BlockHistoryPollPeriod.
This config is only relevant if BlockHistorySize > 1 and if BlockHistorySize is greater than BlockHistoryBatchLoadSize.
Ensure the value is greater than the number of blocks that would be produced between each BlockHistoryPollPeriod to avoid gaps in block history.

### ComputeUnitLimitDefault
[Image: copy to clipboard]
```toml
ComputeUnitLimitDefault = 200_000 # Default
```

ComputeUnitLimitDefault is the compute units limit applied to transactions unless overriden during the txm enqueue

### EstimateComputeUnitLimit
[Image: copy to clipboard]
```toml
EstimateComputeUnitLimit = false # Default
```

EstimateComputeUnitLimit enables or disables compute unit limit estimations per transaction. If estimations return 0 used compute, the ComputeUnitLimitDefault value is used, if set.

### LogPollerStartingLookback
[Image: copy to clipboard]
```toml
LogPollerStartingLookback = '24h0m0s' # Default
```

LogPollerStartingLookback

## Solana.MultiNode
[Image: copy to clipboard]
```toml
[Solana.MultiNode]
Enabled = false # Default
PollFailureThreshold = 5 # Default
PollInterval = '10s' # Default
SelectionMode = 'PriorityLevel' # Default
SyncThreshold = 5 # Default
NodeIsSyncingEnabled = false # Default
LeaseDuration = '1m0s' # Default
NewHeadsPollInterval = '10s' # Default
FinalizedBlockPollInterval = '10s' # Default
EnforceRepeatableRead = true # Default
DeathDeclarationDelay = '10s' # Default
VerifyChainID = true # Default
NodeNoNewHeadsThreshold = '10s' # Default
NoNewFinalizedHeadsThreshold = '10s' # Default
FinalityDepth = 0 # Default
FinalityTagEnabled = true # Default
FinalizedBlockOffset = 0 # Default
```

### Enabled
[Image: copy to clipboard]
```toml
Enabled = false # Default
```

Enabled enables the multinode feature.

### PollFailureThreshold
[Image: copy to clipboard]
```toml
PollFailureThreshold = 5 # Default
```

PollFailureThreshold is the number of consecutive poll failures before a node is considered unhealthy.

### PollInterval
[Image: copy to clipboard]
```toml
PollInterval = '10s' # Default
```

PollInterval is the rate to poll for node health.

### SelectionMode
[Image: copy to clipboard]
```toml
SelectionMode = 'PriorityLevel' # Default
```

SelectionMode is the method used to select the next best node to use.

### SyncThreshold
[Image: copy to clipboard]
```toml
SyncThreshold = 5 # Default
```

SyncThreshold is the number of blocks behind the best node that a node can be before it is considered out of sync.

### NodeIsSyncingEnabled
[Image: copy to clipboard]
```toml
NodeIsSyncingEnabled = false # Default
```

NodeIsSyncingEnabled enables the feature to avoid sending transactions to nodes that are syncing. Not relevant for Solana.

### LeaseDuration
[Image: copy to clipboard]
```toml
LeaseDuration = '1m0s' # Default
```

LeaseDuration is the max duration a node can be leased for.

### NewHeadsPollInterval
[Image: copy to clipboard]
```toml
NewHeadsPollInterval = '10s' # Default
```

NewHeadsPollInterval is the rate to poll for new heads.

### FinalizedBlockPollInterval
[Image: copy to clipboard]
```toml
FinalizedBlockPollInterval = '10s' # Default
```

FinalizedBlockPollInterval is the rate to poll for the finalized block.

### EnforceRepeatableRead
[Image: copy to clipboard]
```toml
EnforceRepeatableRead = true # Default
```

EnforceRepeatableRead enforces the repeatable read guarantee for multinode.

### DeathDeclarationDelay
[Image: copy to clipboard]
```toml
DeathDeclarationDelay = '10s' # Default
```

DeathDeclarationDelay is the duration to wait before declaring a node dead.

### VerifyChainID
[Image: copy to clipboard]
```toml
VerifyChainID = true # Default
```

VerifyChainID enforces RPC Client ChainIDs to match configured ChainID

### NodeNoNewHeadsThreshold
[Image: copy to clipboard]
```toml
NodeNoNewHeadsThreshold = '10s' # Default
```

NodeNoNewHeadsThreshold is the duration to wait before declaring a node unhealthy due to no new heads.

### NoNewFinalizedHeadsThreshold
[Image: copy to clipboard]
```toml
NoNewFinalizedHeadsThreshold = '10s' # Default
```

NoNewFinalizedHeadsThreshold is the duration to wait before declaring a node unhealthy due to no new finalized heads.

### FinalityDepth
[Image: copy to clipboard]
```toml
FinalityDepth = 0 # Default
```

FinalityDepth is not used when finality tags are enabled.

### FinalityTagEnabled
[Image: copy to clipboard]
```toml
FinalityTagEnabled = true # Default
```

FinalityTagEnabled enables the use of finality tags.

### FinalizedBlockOffset
[Image: copy to clipboard]
```toml
FinalizedBlockOffset = 0 # Default
```

FinalizedBlockOffset is the offset from the finalized block to use for finality tags.

## Solana.Nodes
[Image: copy to clipboard]
```toml
[[Solana.Nodes]]
Name = 'primary' # Example
URL = 'http://solana.web' # Example
SendOnly = false # Default
Order = 100 # Default
```

### Name
[Image: copy to clipboard]
```toml
Name = 'primary' # Example
```

Name is a unique (per-chain) identifier for this node.

### URL
[Image: copy to clipboard]
```toml
URL = 'http://solana.web' # Example
```

URL is the HTTP(S) endpoint for this node.

### SendOnly
[Image: copy to clipboard]
```toml
SendOnly = false # Default
```

SendOnly is a multinode config that only sends transactions to a node and does not read state

### Order
[Image: copy to clipboard]
```toml
Order = 100 # Default
```

Order specifies the priority for each node. 1 is highest priority down to 100 being the lowest.

## Starknet
[Image: copy to clipboard]
```toml
[[Starknet]]
ChainID = 'foobar' # Example
FeederURL = 'http://feeder.url' # Example
Enabled = true # Default
OCR2CachePollPeriod = '5s' # Default
OCR2CacheTTL = '1m' # Default
RequestTimeout = '10s' # Default
TxTimeout = '10s' # Default
ConfirmationPoll = '5s' # Default
```

### ChainID
[Image: copy to clipboard]
```toml
ChainID = 'foobar' # Example
```

ChainID is the Starknet chain ID.

### FeederURL
[Image: copy to clipboard]
```toml
FeederURL = 'http://feeder.url' # Example
```

FeederURL is required to get tx metadata (that the RPC can't)

### Enabled
[Image: copy to clipboard]
```toml
Enabled = true # Default
```

Enabled enables this chain.

### OCR2CachePollPeriod
[Image: copy to clipboard]
```toml
OCR2CachePollPeriod = '5s' # Default
```

OCR2CachePollPeriod is the rate to poll for the OCR2 state cache.

### OCR2CacheTTL
[Image: copy to clipboard]
```toml
OCR2CacheTTL = '1m' # Default
```

OCR2CacheTTL is the stale OCR2 cache deadline.

### RequestTimeout
[Image: copy to clipboard]
```toml
RequestTimeout = '10s' # Default
```

RequestTimeout is the RPC client timeout.

### TxTimeout
[Image: copy to clipboard]
```toml
TxTimeout = '10s' # Default
```

TxTimeout is the timeout for sending txes to an RPC endpoint.

### ConfirmationPoll
[Image: copy to clipboard]
```toml
ConfirmationPoll = '5s' # Default
```

ConfirmationPoll is how often to confirmer checks for tx inclusion on chain.

## Starknet.Nodes
[Image: copy to clipboard]
```toml
[[Starknet.Nodes]]
Name = 'primary' # Example
URL = 'http://stark.node' # Example
APIKey = 'key' # Example
```

### Name
[Image: copy to clipboard]
```toml
Name = 'primary' # Example
```

Name is a unique (per-chain) identifier for this node.

### URL
[Image: copy to clipboard]
```toml
URL = 'http://stark.node' # Example
```

URL is the base HTTP(S) endpoint for this node.

### APIKey
[Image: copy to clipboard]
```toml
APIKey = 'key' # Example
```

APIKey Header is optional and only required for Nethermind RPCs

[OCR]
ContractConfirmations = 4
ContractTransmitterTransmitTimeout = '10s'
DatabaseTimeout = '10s'
DeltaCOverride = '168h0m0s'
DeltaCJitterOverride = '1h0m0s'
ObservationGracePeriod = '1s'

[OCR2]
[OCR2.Automation]
GasLimit = 5400000

[Workflow]
GasLimitDefault = 400000
TxAcceptanceState = 2
PollPeriod = '2s'
AcceptanceTimeout = '30s'

================================================================================

# Running a Chainlink Node

Source: https://docs.chain.link/chainlink-nodes/v1/running-a-chainlink-node
Extraction Method: playwright
Components: code_block(16)

# Running a Chainlink Node
This guide will teach you how to run a Chainlink node locally using Docker. The Chainlink node will be configured to connect to the Ethereum Sepolia.

[Image: note]Running from source

To run a Chainlink node from source, use the following
instructions. However, it's recommended to run the Chainlink
node with Docker. This is because we continuously build and deploy the code from our repository on Github, which means
you don't need a complete development environment to run a node.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }[Image: note]Supported networks

Chainlink is a blockchain agnostic technology. The LINK Token Contracts page details networks which support the LINK token. You can set up your node to provide data to any of these blockchains.

Ganache is a mock testnet. Although you can run nodes on Ganache, it is not officially supported. Most node operators
should use one of the supported testnets for development and testing.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
## Requirements

• As explained in the requirements page, make sure there are enough resources to run a Chainlink node and a PostgreSQL database.
• Install Docker Desktop. You will run the Chainlink node and PostgreSQL in Docker containers.
• Chainlink nodes must be able to connect to an Ethereum client with an active websocket connection. See Running an Ethereum Client for details. In this tutorial, you can use an external service as your client.

## Using Docker

### Run PostgreSQL

1. Run PostgreSQL in a Docker container. You can replace mysecretpassword with your own password.
docker run --name cl-postgres -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres
2. Confirm that the container is running. Note the 5432 port is published 0.0.0.0:5432->5432/tcp and therefore accessible outside of Docker.
docker ps -a -f name=cl-postgres

If the container is running successfully, the output shows a healthy status:
CONTAINER ID   IMAGE      COMMAND                  CREATED         STATUS         PORTS                    NAMES
dc08cfad2a16   postgres   "docker-entrypoint.s…"   3 minutes ago   Up 3 minutes   0.0.0.0:5432->5432/tcp   cl-postgres

### Run Chainlink node

#### Configure your node

1. Create a local directory to hold the Chainlink data:
Sepoliamkdir ~/.chainlink-sepolia
2. Run the following as a command to create a config.toml file and populate with variables specific to the network you're running on. For a full list of available configuration variables, see the Node Config page.
Be sure to update the value for CHANGEME to the value given by your external Ethereum provider.
Sepoliaecho "[Log]
Level = 'warn'

[WebServer]
AllowOrigins = '\*'
SecureCookies = false

[WebServer.TLS]
HTTPSPort = 0

[[EVM]]
ChainID = '11155111'

[[EVM.Nodes]]
Name = 'Sepolia'
WSURL = 'wss://CHANGE_ME'
HTTPURL = 'https://CHANGE_ME'
" > ~/.chainlink-sepolia/config.toml
3. Create a secrets.toml file with a keystore password and the URL to your database. Update the value for mysecretpassword to the chosen password in Run PostgreSQL. Specify a complex keystore password. This will be your wallet password that you can use to unlock the keystore file generated for you.
Sepoliaecho "[Password]
Keystore = 'mysecretkeystorepassword'
[Database]
URL = 'postgresql://postgres:mysecretpassword@host.docker.internal:5432/postgres?sslmode=disable'
" > ~/.chainlink-sepolia/secrets.toml

      Important  Because you are testing locally, add ?sslmode=disable to the end of your DATABASE_URL. However you should never
do this on a production node.
4. Optionally, you can create an .api file with the credentials for the node's API and Operator Interface. The node stores the credentials from the .api file in the database only the first time you run the container using the database. The .api file cannot override credentials for an existing user in the database.
Create the file in the same directory as your TOML config files and list your API credentials. Change the values for API email and password. The user must be an email address with an @ character and the password must be 16-50 characters in length.
Sepoliaecho "CHANGE_THIS_EXAMPLE_EMAIL
CHANGE_THIS_EXAMPLE_PASSWORD
" > ~/.chainlink-sepolia/.api
5. Start the Chainlink Node by running the Docker image.
Change the version number in smartcontract/chainlink:2.26.0 with the version of the Docker image that you need to run. For most new nodes, use version 2.0.0 or later. Tag versions are available in the Chainlink Docker hub. The latest version does not work.
Chainlink Nodes running 2.0.0 and later require the -config and -secrets flags after the node part of the command.
If you created an .api file with your API and Operator UI login credentials, add -a /chainlink/.api to the end of the docker run command. Otherwise, the node will ask you for these credentials when you start it for the first time. These credentials are stored in the database only when you run a container for the first time against that database. If you need to remove the .api file, delete the container, and start it again without -a /chainlink/.api.
Sepoliacd ~/.chainlink-sepolia && docker run --platform linux/x86_64/v8 --name chainlink -v ~/.chainlink-sepolia:/chainlink -it -p 6688:6688 --add-host=host.docker.internal:host-gateway smartcontract/chainlink:2.26.0 node -config /chainlink/config.toml -secrets /chainlink/secrets.toml start
6. Detach from the container by pressing the Ctrl+P command and then the Ctrl-Q command.
7. Confirm that the container is running. Note that the 6688 port is published 0.0.0.0:6688->6688/tcp and is accessible outside of Docker.
docker ps -a -f name=chainlink

If the container is running, the output shows a healthy status:
CONTAINER ID   IMAGE                           COMMAND                  CREATED         STATUS                   PORTS                                       NAMES
867e792d6f78   smartcontract/chainlink:2.26.0   "chainlink node -con…"   2 minutes ago   Up 2 minutes (healthy)   0.0.0.0:6688->6688/tcp, :::6688->6688/tcp   chainlink
8. You can now connect to your Chainlink node's UI interface by navigating to http://localhost:6688. Use the API
credentials you set up earlier to log in.
If you are using a VPS, you can create an SSH tunnel to your node for 6688:localhost:6688 to enable connectivity to the GUI. Typically this is done with ssh -i $KEY $USER@$REMOTE-IP -L 6688:localhost:6688 -N. An SSH tunnel is recommended over opening public-facing ports specific to the Chainlink node. See the Security and Operation Best Practices page for more details about securing your node.

## Configure users and roles
You can create several users with different role-based access tiers. This allows you to grant access to several users without granting admin privileges to every user. Role-based access can be configured only by using the CLI.

1. Open an interactive bash shell on the container that is running your node:
docker exec -it chainlink /bin/bash
2. Log into the Chainlink CLI. The CLI prompts you for the admin credentials that you configured for your node.
chainlink admin login
3. Add a user with view-only permissions on the node. The CLI prompts you for the new user's credentials.
chainlink admin users create --email=operator-ui-view-only@test.com --role=view

This user can now log into the UI and query the API, but cannot change any settings or jobs.
4. Confirm the current list of users:
chainlink admin users list
5. Log out of the CLI. This prevents users with access to the shell from executing admin commands.
chainlink admin logout
6. Exit from the container.
exit

To learn how to modify user roles and see the full list of available roles, read the Role-Based Access Control page.

================================================================================

# Deploy Your First Smart Contract

Source: https://docs.chain.link/quickstarts/deploy-your-first-contract
Extraction Method: playwright
Components: code_block(1)

## Overview
You can write your first smart contract and run it in your browser without any knowledge about Ethereum or blockchains. This guide shows you how easy it is to develop smart contracts using the Solidity language, a MetaMask wallet and the Remix Development Environment. You can use all of these tools in your browser for free with no signup required.

## Objective
You will create and deploy a simple "Hello world" smart contract using the following process:

1. Write: Write a contract to define how the contract functions, what data it can store, what other contracts it interacts with, and what external APIs it might call.
2. Compile: Pass your smart contract code through a compiler to translate the contract into byte code that the blockchain can understand. For example, Solidity code must be compiled before it can run in the Ethereum Virtual Machine.
3. Deploy: Send the compiled smart contract to the blockchain. From that point forward, the contract cannot be altered. However, you can still interact with the contract in several ways.
4. Run functions: When you run the functions that you defined for the contract, the network processes those functions and modifies the state of your contract. For some functions, the network charges a small fee to complete the work. Your contract can also have functions that transfer funds to other contracts or wallets.

This guide walks you through each step.

[Image: caution]Disclaimer

This tutorial represents an example of using a Chainlink product or service and is provided to help you understand how
to interact with Chainlink's systems and services so that you can integrate them into your own. This template is
provided “AS IS” and “AS AVAILABLE” without warranties of any kind, has not been audited, and may be missing key
checks or error handling to make the usage of the product more clear. Do not use the code in this example in a
production environment without completing your own audits and application of best practices. Neither Chainlink Labs,
the Chainlink Foundation, nor Chainlink node operators are responsible for unintended outputs that are generated due
to errors in code.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
## Steps to implement
1Install and fund your MetaMask walletDeploying smart contracts onchain requires a wallet and ETH. The ETH pays for the work required by the Ethereum network to add the contract to the blockchain and store the variables. The wallet holds the ETH that you need to pay for the transaction. Install MetaMask, configure it to use the Sepolia testnet, and fund your wallet with free testnet ETH.

1. Install and configure the MetaMask extension in your browser.
2. After you install the extension, open your browser extension list and click MetaMask to open MetaMask.
3. Follow the instructions in MetaMask to create a new MetaMask wallet. The new wallet includes a 12-word mnemonic phrase. This phrase is the key to your wallet. Copy that phrase down in a very secure location that only you can access. You can use this phrase to retrieve your wallet later or add it to another browser.
4. Set MetaMask to use the Sepolia test network.
5. Go to faucets.chain.link and follow the steps to send testnet ETH to your MetaMask wallet address. After the faucet completes the transaction, you should have testnet ETH in your MetaMask wallet on the Sepolia testnet. Optionally, you can get testnet ETH from one of the alternative faucets.

Now that you configured your wallet and funded it with testnet ETH, you can write, compile, and deploy your contract.

.accordionContent > :not(astro-slot, astro-island, ul, ol) {
    margin-top: var(--space-4x);
  }

  .accordionContent > :first-child {
    margin-top: 0;
  }class a extends HTMLElement{details;summary;animation;isClosing=!1;isExpanding=!1;contentReference=null;constructor(){super(),this.details=this.querySelector("details"),this.summary=this.details.querySelector("summary"),this.summary.addEventListener("click",t=>this.onClick(t))}connectedCallback(){this.contentReference=this.getAttribute("contentReference")}cancelIfAnimating(){this.animation&&this.animation.cancel()}onClick(t){t.preventDefault(),this.isClosing||!this.details.open?this.open():(this.isExpanding||this.details.open)&&this.shrink()}shrink(){this.details.toggleAttribute("expanded"),this.isClosing=!0;const t=`${this.details.offsetHeight}px`,i=`${this.summary.offsetHeight}px`;this.cancelIfAnimating(),this.animation=this.details.animate({height:[t,i]},{duration:200,easing:"ease-out"}),this.animation.onfinish=()=>this.onAnimationFinish(!1),this.animation.oncancel=()=>this.isClosing=!1}open(){this.details.style.height=`${this.details.offsetHeight}px`,this.details.open=!0,window.requestAnimationFrame(()=>this.expand())}expand(){this.details.toggleAttribute("expanded"),this.isExpanding=!0;let t=0;this.details.querySelectorAll(":scope > :not(summary)").forEach(o=>{o.clientHeight>0&&(t+=o.clientHeight)});const n=`${this.details.offsetHeight}px`,s=`${this.summary.offsetHeight+t}px`;this.cancelIfAnimating();const e=250+Math.min(t,300);this.animation=this.details.animate({height:[n,s]},{duration:e,easing:"ease-out"}),this.animation.onfinish=()=>this.finishAnimationAndUpdateHash(),this.animation.oncancel=()=>this.isExpanding=!1}onAnimationFinish(t){this.details.open=t,this.animation=null,this.isClosing=this.isExpanding=!1,this.details.style.height=""}finishAnimationAndUpdateHash(){if(this.onAnimationFinish(!0),this.contentReference){const t=`#${this.contentReference}`;window.location.hash!==t&&(window.location.hash=t,setTimeout(()=>{const i=document.getElementById(this.contentReference);if(i){const e=i.getBoundingClientRect().top+window.pageYOffset-150;window.scrollTo({top:e,behavior:"smooth"})}},0))}}}customElements.define("astro-accordion",a);2Write, compile, and deploy your first smart contractYour first contract is a simple HelloWorld.sol example. This example shows you how to set and retrieve variables in a smart contract onchain.

[Image: copy to clipboard]
```solidity
// SPDX-License-Identifier: MIT

pragma solidity 0.8.7;

/**
 * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

contract HelloWorld {
    string public message;

    constructor(string memory initialMessage) {
        message = initialMessage;
    }

    function updateMessage(string memory newMessage) public {
        message = newMessage;
    }
}
```

[Open in Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/Tutorials/HelloWorld.sol&autoCompile=true)[What is Remix?](/getting-started/conceptual-overview#what-is-remix)
1. Open the example contract in the Remix IDE. Remix opens and shows the contents of the smart contract. You can modify the code in this editor when you write your own contract.

Open in Remix
What is Remix?
2. Because the code is already written, you can start the compile step. On the left side of Remix, click the Solidity Compiler tab to view the compiler settings.
3. For this contract, use the default compiler settings. Click the Compile HelloWorld.sol button to compile the contract. This converts the contract from Solidity into bytecode that the Ethereum Virtual Machine can understand. Remix automatically detects the correct compiler version depending on the pragma that you specify in the contract.
4. After Remix compiles the contract, deploy it. On the left side of Remix, click the Deploy and Run tab to view the deployment settings.
5. In the deployment settings, select the Injected Provider environment. This tells Remix that you want to deploy your contract to the blockchain that you configured in MetaMask. You could optionally use one of the Javascript VM options, but they run in a virtual environment with no connection to an actual blockchain or Chainlink oracles.
6. Next to the Deploy button, enter a message that you want to send with the smart contract when you deploy it. This contract has a constructor that sets an initial message when you deploy the contract.
7. Click the Deploy button to deploy the contract and its initial message to the blockchain network. MetaMask opens and asks you to confirm payment to deploy the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.
8. In the MetaMask prompt, click Confirm to approve the transaction and spend your testnet ETH required to deploy the contract.
9. After a few seconds, the transaction completes and your contract appears under the Deployed Contracts list in Remix. Click the contract dropdown to view its variables and functions.
10. Click the message variable. Remix retrieves and prints the initial message that you set.

The contract has an address just like your wallet address. If you save this address, you can return to your deployed contract at any time to retrieve variables or execute functions. To see details about your deployed contract, copy the contract address from the list in Remix and search for it in the Etherscan Sepolia Testnet Explorer.

.accordionContent > :not(astro-slot, astro-island, ul, ol) {
    margin-top: var(--space-4x);
  }

  .accordionContent > :first-child {
    margin-top: 0;
  }3Run functions in your contractBecause you deployed the contract to an actual blockchain, several nodes on the test network confirmed your payment for the smart contract. The contract, its variables, and its functions remain in the blockchain permanently. To change the message variable that is stored with your contract, run the updateMessage function.

1. In your deployed contract, enter a new message next to the updateMessage function.
2. Click the updateMessage button to set the new message in the contract data. MetaMask opens and asks you to confirm payment to update the state of your contract.
3. In the new MetaMask prompt, click Confirm to approve the transaction.
4. Click the message variable again to see the updated value. It might take a few seconds before the transaction updates the variable.

.accordionContent > :not(astro-slot, astro-island, ul, ol) {
    margin-top: var(--space-4x);
  }

  .accordionContent > :first-child {
    margin-top: 0;
  }Now you know how to deploy example contracts to a test network and run the functions in those contracts. You can write your own contracts and test them using this same process.

Next, read the Consuming Data Feeds guide to learn how to connect your smart contracts to Chainlink Data Feeds and retrieve onchain data that your smart contracts can act on.

================================================================================

# Foundry Chainlink Toolkit

Source: https://docs.chain.link/quickstarts/foundry-chainlink-toolkit
Extraction Method: playwright
Components: code_block(19)

## Overview
This toolkit makes spinning up, managing, and testing smart contracts and local Chainlink nodes easier using Foundry to deploy and test smart contracts. It can be integrated into existing Foundry projects.

## Objective
This project shows you how to install and run the simplify the development and testing of smart contracts that use Chainlink oracles. This project is aimed primarily at those who use the Foundry toolchain.

[Image: caution]Disclaimer

This tutorial represents an example of using a Chainlink product or service and is provided to help you understand how
to interact with Chainlink's systems and services so that you can integrate them into your own. This template is
provided “AS IS” and “AS AVAILABLE” without warranties of any kind, has not been audited, and may be missing key
checks or error handling to make the usage of the product more clear. Do not use the code in this example in a
production environment without completing your own audits and application of best practices. Neither Chainlink Labs,
the Chainlink Foundation, nor Chainlink node operators are responsible for unintended outputs that are generated due
to errors in code.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
## Before you begin

1. Install Foundry toolchain. Reference the below commands or go to the Foundry documentation.

MacOS/Linux
curl -L https://foundry.paradigm.xyz | bash

This will download foundryup. Restart your terminal session, then install Foundry by running:
foundryup

You might see the following error on MacOS: dyld: Library not loaded: /usr/local/opt/libusb/lib/libusb-1.0.0.dylib To fix this, install libusb: brew install libusb See installation troubleshooting for details.
2. Install GNU make. The functionality of the project is wrapped in the makefile. Reference the below commands based on your OS or go to Make documentation.

MacOS: install Homebrew first, then run
brew install make

Debian/Ubuntu
apt install make

Fedora/RHEL
yum install make
3. Install and run Docker.
4. Integrate the toolkit into your project. The Foundry-Chainlink toolkit is designed to be installed as a Forge dependency:
forge install smartcontractkit/foundry-chainlink-toolkit --no-commit
5. Install the Forge Standard Library in your project:
forge install foundry-rs/forge-std
6. If you need to run this toolkit as a demo standalone application, install the dependencies:
git submodule update

## Steps to implement
1Set up environment variablesUse the env.template file, create or update an .env file in the root directory of your project.
In most cases, you will not need to modify the default values specified in this file.

The following environment variables are available:

• FCT_PLUGIN_PATH - path to the Foundry-Chainlink toolkit root
• ETH_URL - RPC node web socket used by the Chainlink node
• RPC_URL - RPC node http endpoint used by Forge
• PRIVATE_KEY - private key of an account used for deployment and interaction with smart contracts. Once Anvil is started, a set of private keys for local usage is provided. Use one of these for local development
• ROOT - root directory of the Chainlink node
• CHAINLINK_CONTAINER_NAME - Chainlink node container name for the possibility of automating communication with it
• COMPOSE_PROJECT_NAME - Docker network project name for the possibility of automating communication with it. See the Docker Documentation to learn more.
If environment variables related to a Chainlink node, including a Link Token contract address, were changed during your work you should run the make fct-run-nodes command in order for them to be applied.

1. Give Forge permission to read the output directory of the toolkit by adding this setting to the foundry.toml:
fs_permissions = [{ access = "read", path = "lib/foundry-chainlink-toolkit/out"}]

The default path to the root of the Foundry-Chainlink toolkit is lib/foundry-chainlink-toolkit. Unfortunately at the moment foundry.toml cannot read all environment variables. Specify a different path if necessary.
2. Incorporate the makefile-external into your project. To do this, create or update a makefile in the root of your project with:
-include ${FCT_PLUGIN_PATH}/makefile-external

.accordionContent > :not(astro-slot, astro-island, ul, ol) {
    margin-top: var(--space-4x);
  }

  .accordionContent > :first-child {
    margin-top: 0;
  }class a extends HTMLElement{details;summary;animation;isClosing=!1;isExpanding=!1;contentReference=null;constructor(){super(),this.details=this.querySelector("details"),this.summary=this.details.querySelector("summary"),this.summary.addEventListener("click",t=>this.onClick(t))}connectedCallback(){this.contentReference=this.getAttribute("contentReference")}cancelIfAnimating(){this.animation&&this.animation.cancel()}onClick(t){t.preventDefault(),this.isClosing||!this.details.open?this.open():(this.isExpanding||this.details.open)&&this.shrink()}shrink(){this.details.toggleAttribute("expanded"),this.isClosing=!0;const t=`${this.details.offsetHeight}px`,i=`${this.summary.offsetHeight}px`;this.cancelIfAnimating(),this.animation=this.details.animate({height:[t,i]},{duration:200,easing:"ease-out"}),this.animation.onfinish=()=>this.onAnimationFinish(!1),this.animation.oncancel=()=>this.isClosing=!1}open(){this.details.style.height=`${this.details.offsetHeight}px`,this.details.open=!0,window.requestAnimationFrame(()=>this.expand())}expand(){this.details.toggleAttribute("expanded"),this.isExpanding=!0;let t=0;this.details.querySelectorAll(":scope > :not(summary)").forEach(o=>{o.clientHeight>0&&(t+=o.clientHeight)});const n=`${this.details.offsetHeight}px`,s=`${this.summary.offsetHeight+t}px`;this.cancelIfAnimating();const e=250+Math.min(t,300);this.animation=this.details.animate({height:[n,s]},{duration:e,easing:"ease-out"}),this.animation.onfinish=()=>this.finishAnimationAndUpdateHash(),this.animation.oncancel=()=>this.isExpanding=!1}onAnimationFinish(t){this.details.open=t,this.animation=null,this.isClosing=this.isExpanding=!1,this.details.style.height=""}finishAnimationAndUpdateHash(){if(this.onAnimationFinish(!0),this.contentReference){const t=`#${this.contentReference}`;window.location.hash!==t&&(window.location.hash=t,setTimeout(()=>{const i=document.getElementById(this.contentReference);if(i){const e=i.getBoundingClientRect().top+window.pageYOffset-150;window.scrollTo({top:e,behavior:"smooth"})}},0))}}}customElements.define("astro-accordion",a);2Set up chain RPC nodeIn order for a Chainlink node to be able to interact with the blockchain, and to interact with the blockchain using the Forge, you have to know an RPC node http endpoint and web socket for a chosen network compatible with Chainlink.
In addition to the networks listed in this list, Chainlink is compatible with any EVM-compatible networks.

For local testing, we recommend using Anvil, which is a part of the Foundry toolchain.
You can run it using the following command:

[Image: copy to clipboard]
```plaintext
make fct-anvil
```

If the local Ethereum node is restarted, re-initialize the Chainlink cluster or perform a clean spin-up of the Chainlink nodes to avoid possible synchronization errors.

.accordionContent > :not(astro-slot, astro-island, ul, ol) {
    margin-top: var(--space-4x);
  }

  .accordionContent > :first-child {
    margin-top: 0;
  }3Run the exampleScripts for automating the initialization of the test environment and setting up Chainlink jobs will be described below.

To display autogenerated help with a brief description of the most commonly used scripts, run:

[Image: copy to clipboard]
```plaintext
make fct-help
```

For a more detailed description of the available scripts, you can refer to DOCUMENTATION.md in the repository.

.accordionContent > :not(astro-slot, astro-island, ul, ol) {
    margin-top: var(--space-4x);
  }

  .accordionContent > :first-child {
    margin-top: 0;
  }4Initialize testing environment[Image: copy to clipboard]
```plaintext
make fct-init
```

This command automatically initializes the test environment, in particular, it makes clean spin-up of a Chainlink cluster of 5 Chainlink nodes.

Once Chainlink cluster is launched, a Chainlink nodes' Operator GUI will be available at:

• http://127.0.0.1:6711 - Chainlink node 1
• http://127.0.0.1:6722 - Chainlink node 2
• http://127.0.0.1:6733 - Chainlink node 3
• http://127.0.0.1:6744 - Chainlink node 4
• http://127.0.0.1:6755 - Chainlink node 5

For authorization, you must use the credentials specified in the chainlink_api_credentials.

.accordionContent > :not(astro-slot, astro-island, ul, ol) {
    margin-top: var(--space-4x);
  }

  .accordionContent > :first-child {
    margin-top: 0;
  }5Set up Chainlink Jobs[Image: copy to clipboard]
```plaintext
make fct-setup-job
```

This command displays a list of available Chainlink jobs and sets up the selected one.

You can also set up a Chainlink job by calling the respective command. Manual set up of a Chainlink Job is recommended when using a custom Consumer or Aggregator contract, or when a different job configuration is desired. You can create a custom TOML file and use it to create a Chainlink Job instance through the Operator GUI or develop a custom script using the existing scripts provided by this toolkit. Manual setup steps are documented repository for each job type.

#### Direct Request Job
[Image: copy to clipboard]
```plaintext
make fct-setup-direct-request-job
```

This command automatically sets up a Direct Request job.

#### Cron Job
[Image: copy to clipboard]
```plaintext
make fct-setup-cron-job
```

This command automatically sets up a Cron job.

#### Webhook Job
[Image: copy to clipboard]
```plaintext
make fct-setup-webhook-job
```

This command automatically sets up a Webhook job.

#### Keeper Job
[Image: copy to clipboard]
```plaintext
make fct-setup-keeper-job
```

This command automatically sets up a Keeper job.

#### OCR Job
[Image: copy to clipboard]
```plaintext
make fct-setup-ocr-job
```

This command automatically sets up an OCR job.

.accordionContent > :not(astro-slot, astro-island, ul, ol) {
    margin-top: var(--space-4x);
  }

  .accordionContent > :first-child {
    margin-top: 0;
  }
## Project Structure
You can find the full project structure in the repository.

================================================================================

# Historical Price Feeds API

Source: https://docs.chain.link/quickstarts/historical-price-feeds-api
Extraction Method: playwright
Components: code_block(8), table(1)

## Overview
This API endpoint allows you to fetch historical prices from Chainlink price feeds for a specified period. The API endpoint returns the price data in JSON format. You can use this API endpoint to fetch historical prices for a single round or multiple rounds.

## Objective
This example shows you how to set up and run a pre-built API that reads historical price data from Chainlink Price Feeds. The API runs offchain, but reads the data from onchain Chainlink Data Feeds. You can use this API to build your own applications.

[Image: caution]Disclaimer

This tutorial represents an example of using a Chainlink product or service and is provided to help you understand how
to interact with Chainlink's systems and services so that you can integrate them into your own. This template is
provided “AS IS” and “AS AVAILABLE” without warranties of any kind, has not been audited, and may be missing key
checks or error handling to make the usage of the product more clear. Do not use the code in this example in a
production environment without completing your own audits and application of best practices. Neither Chainlink Labs,
the Chainlink Foundation, nor Chainlink node operators are responsible for unintended outputs that are generated due
to errors in code.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
## Before you begin

• Install Node.js >= 14.x.x
• Install Yarn >= 1.22.x

## Steps to implement
1Set up the project
1. Clone the Historical Prices API repo and change directories:
git clone https://github.com/smartcontractkit/quickstarts-historical-prices-api.git && cd quickstarts-historical-prices-api
2. Install the dependencies:
yarn install
3. Build the project:
yarn build
4. Start the server:
yarn start

.accordionContent > :not(astro-slot, astro-island, ul, ol) {
    margin-top: var(--space-4x);
  }

  .accordionContent > :first-child {
    margin-top: 0;
  }class a extends HTMLElement{details;summary;animation;isClosing=!1;isExpanding=!1;contentReference=null;constructor(){super(),this.details=this.querySelector("details"),this.summary=this.details.querySelector("summary"),this.summary.addEventListener("click",t=>this.onClick(t))}connectedCallback(){this.contentReference=this.getAttribute("contentReference")}cancelIfAnimating(){this.animation&&this.animation.cancel()}onClick(t){t.preventDefault(),this.isClosing||!this.details.open?this.open():(this.isExpanding||this.details.open)&&this.shrink()}shrink(){this.details.toggleAttribute("expanded"),this.isClosing=!0;const t=`${this.details.offsetHeight}px`,i=`${this.summary.offsetHeight}px`;this.cancelIfAnimating(),this.animation=this.details.animate({height:[t,i]},{duration:200,easing:"ease-out"}),this.animation.onfinish=()=>this.onAnimationFinish(!1),this.animation.oncancel=()=>this.isClosing=!1}open(){this.details.style.height=`${this.details.offsetHeight}px`,this.details.open=!0,window.requestAnimationFrame(()=>this.expand())}expand(){this.details.toggleAttribute("expanded"),this.isExpanding=!0;let t=0;this.details.querySelectorAll(":scope > :not(summary)").forEach(o=>{o.clientHeight>0&&(t+=o.clientHeight)});const n=`${this.details.offsetHeight}px`,s=`${this.summary.offsetHeight+t}px`;this.cancelIfAnimating();const e=250+Math.min(t,300);this.animation=this.details.animate({height:[n,s]},{duration:e,easing:"ease-out"}),this.animation.onfinish=()=>this.finishAnimationAndUpdateHash(),this.animation.oncancel=()=>this.isExpanding=!1}onAnimationFinish(t){this.details.open=t,this.animation=null,this.isClosing=this.isExpanding=!1,this.details.style.height=""}finishAnimationAndUpdateHash(){if(this.onAnimationFinish(!0),this.contentReference){const t=`#${this.contentReference}`;window.location.hash!==t&&(window.location.hash=t,setTimeout(()=>{const i=document.getElementById(this.contentReference);if(i){const e=i.getBoundingClientRect().top+window.pageYOffset-150;window.scrollTo({top:e,behavior:"smooth"})}},0))}}}customElements.define("astro-accordion",a);2Write, compile, and deploy your first smart contractAfter you complete the setup steps, you can access the UI at http://localhost:3000. The API is available at http://localhost:3000/api/price.

In order to fetch the price for a single round, you need to specify the same start and end timestamps. Make sure that the time frame exists. The API endpoint will return the price for the round that is within the specified time frame.

### Request a single-round
Make a simple curl request to test the API:

[Image: copy to clipboard]
```bash
curl http://localhost:3000/api/price?contractAddress=0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419&startTimestamp=1614556800&endTimestamp=1614556800&chain=mainnet&rpcUrl=https://eth-mainnet.alchemyapi.io/v2/your-api-key
```

Response:

[Image: copy to clipboard]
```json
{
  "description": "ETH/USD",
  "decimals": 8,
  "rounds": [
    {
      "phaseId": "1",
      "roundId": "1",
      "answer": "2000",
      "timestamp": "2021-03-01T00:00:00Z"
    },
    {
      "phaseId": "1",
      "roundId": "2",
      "answer": "2100",
      "timestamp": "2021-03-01T01:00:00Z"
    }
  ]
}
```

.accordionContent > :not(astro-slot, astro-island, ul, ol) {
    margin-top: var(--space-4x);
  }

  .accordionContent > :first-child {
    margin-top: 0;
  }3Request multiple roundsIn order to fetch the prices for multiple rounds, you need to specify different start and end timestamps. Make sure that the start timestamp is less than the end timestamp and that the time frames exist. The API endpoint will return the prices for the rounds that are within the specified time frame.

Make a simple curl request to test the API with multiple rounds returned:

[Image: copy to clipboard]
```bash
GET /api/price?contractAddress=0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419&startTimestamp=1614556800&endTimestamp=1614643200&chain=mainnet&rpcUrl=https://eth-mainnet.alchemyapi.io/v2/your-api-key
```

Example response:

[Image: copy to clipboard]
```json
{
  "description": "ETH/USD",
  "decimals": 8,
  "rounds": [
    {
      "phaseId": "1",
      "roundId": "1",
      "answer": "2000",
      "timestamp": "2021-03-01T00:00:00Z"
    },
    ⋮
    ⋮
  ]
}
```

.accordionContent > :not(astro-slot, astro-island, ul, ol) {
    margin-top: var(--space-4x);
  }

  .accordionContent > :first-child {
    margin-top: 0;
  }
## Reference
The endpoint for this API is GET /api/price.

### Query Parameters

Required | Parameter | Description | Type | Options
--- | --- | --- | --- | ---
✅ | contractAddress | The address of the Chainlink price feed contract. | string | Price Feeds
✅ | startTimestamp | The start timestamp of the period for fetching prices. | number | Unix timestamp in seconds. Example: 1681187628
✅ | endTimestamp | The end timestamp of the period for fetching prices. | number | Unix timestamp in seconds. Example: 1681187628
✅ | chain | The blockchain network where the contract is deployed. | string | mainnet, arbitrum, bsc, polygon , avalanche, fantom, moonbeam, moonriver, optimism, metis, gnosis
 | rpcUrl | The RPC URL for the blockchain network. | string | RPC URLs

### Response
The response is a JSON object with the following properties:

• description: The price pair name.
• decimals: The number of decimals for the answer.
• rounds: An array of round data objects. Each round data object has the following properties:

phaseId: The phase ID of the round.
roundId: The round ID.
answer: The price at the round.
timestamp: The timestamp of the round in UTC.

### Errors
The API endpoint may return one of the following errors:

• Input validation error: This error is returned when the input parameters are not valid.
• Failed to get client for chain: This error is returned when the API fails to get a client for the specified blockchain network.
• Failed to get phase data from contract: This error is returned when the API fails to get phase data from the contract.

================================================================================

# The hub for Chainlink developers

Source: https://docs.chain.link/getting-started/other-tutorials
Extraction Method: playwright
Interactive Elements: tabs w-tabs
Components: code_block(1), interactive_tab(1)

/* Hover for View all button */
.arrow-btn:hover path {
	stroke: var(--biscay);
}

.arrow-btn.arrow-btn--white path {
	stroke: var(--white);
} 
.arrow-btn.arrow-btn--white:hover path {
	stroke: var(--blue-300);
}/* Crop text in the upcoming events card */
.up-event-card__h {
		text-overflow: ellipsis;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
}

.up-event-card__country-name {
		text-overflow: ellipsis;
    display: -webkit-box;
    -webkit-line-clamp: 1;
    -webkit-box-orient: vertical;
}

/* Hover for big upcoming event card */
.upcoming-event:hover .upcoming-event__btn-arr path {
	stroke: white;
}

/* Remove scroll for cards in hero */
.sec-hero__cards-wrap, .up-events__list {
  -webkit-overflow-scrolling: touch;
  -ms-overflow-style: -ms-autohiding-scrollbar;
  -ms-overflow-style: none;  /* IE and Edge */
  scrollbar-width: none;  /* Firefox */
}

.sec-hero__cards-wrap::-webkit-scrollbar, .up-events__list::-webkit-scrollbar {
  display: none; 
}

/* Popular resources styles */
@media (max-width: 991px) {
    .popular-res__col.popular-res__col--active .popular-res__list-wrap {
        height: auto;
    }

    .popular-res__col.popular-res__col--active .popular-res__arr {
        transform: rotate(-180deg);
    }
}/* Devhub navbar styles */
@media (min-width: 992px) {
    .dev-nav-link:hover .dev-nav-link__shape,
    .dev-nav-link.w--current .dev-nav-link__shape,
    .dev-nav-link.w--open .dev-nav-link__shape {
        display: block;
    }
}

.dev-nav-link.dev-nav-link--dd:hover .dev-nav-link__shape path{
	fill: var(--chainlink-blue);
}

[data-nav-menu-open] {
	background-color: white;
}

.w-nav-overlay [data-nav-menu-open] {
    top: 64px;
}

@media (min-width: 991px) {
  .acad-nav-link:hover path {
    stroke: var(--chainlink-blue);
  }
}
  
/* Disable Blue Highlight  */
.dev-nav-link.dev-nav-link--dd {
		-webkit-tap-highlight-color:  rgba(255, 255, 255, 0); 
}Resources<svg xmlns="http://www.w3.org/2000/svg" width="47" height="39" viewBox="0 0 47 39" fill="none">
<g filter="url(#filter0_dd_921_10269)">
<path d="M11 14L27 14L19.7071 6.70711C19.3166 6.31658 18.6834 6.31658 18.2929 6.70711L11 14Z" fill="white"/>
</g>
<defs>
<filter id="filter0_dd_921_10269" x="0.6" y="0.714063" width="46" height="37.5859" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
<feFlood flood-opacity="0" result="BackgroundImageFix"/>
<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
<feMorphology radius="1" operator="dilate" in="SourceAlpha" result="effect1_dropShadow_921_10269"/>
<feOffset dx="4.6" dy="9.3"/>
<feGaussianBlur stdDeviation="7"/>
<feComposite in2="hardAlpha" operator="out"/>
<feColorMatrix type="matrix" values="0 0 0 0 0.596078 0 0 0 0 0.627451 0 0 0 0 0.72549 0 0 0 0.04 0"/>
<feBlend mode="normal" in2="BackgroundImageFix" result="effect1_dropShadow_921_10269"/>
<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
<feMorphology radius="0.3" operator="erode" in="SourceAlpha" result="effect2_dropShadow_921_10269"/>
<feOffset dx="1" dy="-1"/>
<feGaussianBlur stdDeviation="1.5"/>
<feComposite in2="hardAlpha" operator="out"/>
<feColorMatrix type="matrix" values="0 0 0 0 0.596078 0 0 0 0 0.627451 0 0 0 0 0.72549 0 0 0 0.21 0"/>
<feBlend mode="normal" in2="effect1_dropShadow_921_10269" result="effect2_dropShadow_921_10269"/>
<feBlend mode="normal" in="SourceGraphic" in2="effect2_dropShadow_921_10269" result="shape"/>
</filter>
</defs>
</svg>ResourcesCross-ChainCCIPGlobal standard for building secure cross-chain applications.

[Docs](https://docs.chain.link/ccip)[Learn](/products/ccip)[SDK](https://github.com/smartcontractkit/ccip-javascript-sdk)[View all resources](/resources)[Learn about Chainlink](/products/general)DataData resourcesMarket and Data Feeds resources for devs of any level.

[Learn](/products/data)FeedsDecentralized and high-quality data for DeFi, sports, weather, and more.

[Docs](https://docs.chain.link/data-feeds)[Learn](/products/data?sub-product=Data+Feeds)StreamsSecure high-frequency market data for ultra-fast derivative products.

[Docs](https://docs.chain.link/data-streams)[Learn](/products/data?sub-product=Data+Streams)ComputeAutomationHigh-performance, decentralized automation for smart contracts.

[Docs](https://docs.chain.link/chainlink-automation)[Learn](/products/automation)FunctionsServerless platform that fetches data from any API & runs custom compute.

[Docs](https://docs.chain.link/chainlink-functions)[Learn](/products/functions)VRFRandom number generator for blockchain gaming and NFTs.

[Docs](https://docs.chain.link/vrf)[Learn](/products/vrf)FeaturedHardhat CLI for Data Streams[Docs](https://docs.chain.link/data-streams/getting-started-hardhat)Try out Chainlink Automation[Docs](https://docs.chain.link/chainlink-automation/overview/getting-started)[Docs](https://docs.chain.link/)[Demos](/demos)[Tools](/tools)[Changelog](/changelog)[Get Certified](/certification)⌘KIntroducing DataLink: Bringing Institutional Market Data Onchain With Launch Partner Deutsche Börse.[Learn more.](https://blog.chain.link/introducing-datalink/?utm_campaign=datalink&utm_source=chainlink-dev&utm_medium=referral)
# The hub for Chainlink developers
TrendingChainlink Bootcamps
## Introduction to Solidity and ERC-20s
12.6.2025 19:34Chainlink Tools
## Accelerate development with Chainlink Local Simulator
12.6.2025 19:34Chainlink Certification
## Supercharge your career with Chainlink Certification
12.6.2025 19:34Chainlink Tools
## Launch your token with cross-chain functionality in just a few clicks
12.6.2025 19:34[blogSwift Selects Chainlink as a Winner of 2025 Swift Hackathon2.10.2025 20:09](https://blog.chain.link/chainlink-wins-swift-hackathon/)[blogIntroducing DataLink: An Institutional-Grade Service for Publishing Data Onchain1.10.2025 20:09](https://blog.chain.link/introducing-datalink/)[blogSibos 2025: The Future of Digital Assets in Capital Markets | Highlights, Coverage, and More | Chainlink Blog30.9.2025 20:11](https://blog.chain.link/sibos-2025-recap/)[blogIntroducing the Chainlink Digital Transfer Agent Technical Standard30.9.2025 20:11](https://blog.chain.link/digital-transfer-agent-ubs/)[blogThe Swift and Chainlink Partnership: Unlocking the Next Evolution of Global Finance | Chainlink Blog29.9.2025 20:10](https://blog.chain.link/the-swift-and-chainlink-partnership/)[blog체인링크 디지털 자산 인사이트: 스테이블코인 레일, 핵심 인프라로 부상 | Chainlink Blog22.9.2025 9:44](https://blog.chain.link/chainlink-digital-asset-insights-q1-2025-kr/)[blogWhat Is Chainlink? A Technical Deep Dive (Advanced) | Chainlink Blog22.9.2025 9:44](https://blog.chain.link/what-is-chainlink-technical-deep-dive/)[blogWhat Is Chainlink? Explained in 100 Words22.9.2025 9:44](https://blog.chain.link/what-is-chainlink-100-words/)[blogU.S. Department of Commerce and Chainlink Bring Economic Data Onchain9.9.2025 13:59](https://blog.chain.link/united-states-department-of-commerce-macroeconomic-data/)[blogThe Convergence Powering the Next Wave of Global Finance | Chainlink Blog9.9.2025 13:59](https://blog.chain.link/the-convergence-powering-the-next-wave-of-global-finance/)[blogFrom One Week to Three Hours: The CRE Impact9.9.2025 13:59](https://blog.chain.link/cre-impact-on-dapp-development/)[blogChainlink: Integrating the World Into the Tokenized Asset Economy9.9.2025 13:59](https://blog.chain.link/chainlink-oracle-platform/)[blogChainlink Services Achieve ISO 27001 & SOC 2 Compliance9.9.2025 13:59](https://blog.chain.link/chainlink-achieves-iso-soc-2-certifications/)[blog체인링크 리저브: LINK 토큰으로 전략적 준비금을 구축하다 | Chainlink Blog9.9.2025 13:59](https://blog.chain.link/chainlink-reserve-strategic-link-reserve-kr/)[blogChainlink发布Chainlink Reserve，建立战略LINK通证储备 | Chainlink Blog9.9.2025 13:59](https://blog.chain.link/chainlink-reserve-strategic-link-reserve-cn/)[blogChainlink Quarterly Review: Q2 2025 | Chainlink Blog9.9.2025 13:59](https://blog.chain.link/quarterly-review-q2-2025/)[blogIntroducing the Chainlink Reserve: A Strategic LINK Token Reserve9.9.2025 13:59](https://blog.chain.link/chainlink-reserve-strategic-link-reserve/)[blogChainlink Launches Data Streams for U.S. Equities and ETFs7.8.2025 18:00](https://blog.chain.link/chainlink-data-streams-us-equities-etfs/)[blogIntroducing Chainlink State Pricing for DEX-Traded Assets | Chainlink Blog7.8.2025 18:00](https://blog.chain.link/state-pricing/)[blogChainlink Digital Asset Insights: Q2 2025 | Enhancing Trade Settlement Through Chainlink | Chainlink Blog7.8.2025 18:00](https://blog.chain.link/chainlink-digital-asset-insights-q2-2025/)[blogAnnouncing the Chainlink Chromion Hackathon Winners | Chainlink Blog7.8.2025 18:00](https://blog.chain.link/announcing-the-chainlink-chromion-hackathon-winners/)[blogThe Evolution and Outlook for Fund Tokenization | Chainlink Blog7.8.2025 18:00](https://blog.chain.link/the-evolution-and-outlook-for-fund-tokenization/)[blog준비금 증명(Proof-of-Reserve)의 최대 규모 제공자: 체인링크 | Chainlink Blog24.7.2025 12:07](https://blog.chain.link/largest-proof-of-reserve-provider-kr/)[blogHow U.S. States Are Exploring Blockchain | Chainlink Blog24.7.2025 12:07](https://blog.chain.link/how-states-are-exploring-blockchain/)[blogTokenized in America: How the U.S. Financial System Gains Global Market Share by Embracing Blockchain Technology and Tokenization | Chainlink Blog24.7.2025 12:07](https://blog.chain.link/tokenized-in-america/)[blogAutomating Policy Enforcement With Smart Contracts | Chainlink Blog14.7.2025 15:47](https://blog.chain.link/policy-enforcement-via-smart-contracts/)[blogChainlink Automated Compliance Engine (ACE): Technical Overview3.7.2025 16:14](https://blog.chain.link/automated-compliance-engine-technical-overview/)[blogChainlink ACE: Enabling Compliance Across Chains and Jurisdictions3.7.2025 16:14](https://blog.chain.link/automated-compliance-engine/)[blogEnhancing the Integrity of the U.S. Financial System With Proof of Reserves and Proof of Composition | Chainlink Blog3.7.2025 16:14](https://blog.chain.link/the-need-for-proof-of-reserves-and-proof-of-composition/)[blogMastercard and Chainlink: Unlocking the $3T Payments Opportunity by Onboarding Billions of Cardholders to DeFi3.7.2025 16:14](https://blog.chain.link/mastercard-and-chainlink-digital-payments/)[blogHow U.S. Policy Can Support Tokenization3.7.2025 16:14](https://blog.chain.link/how-united-states-can-support-tokenization/)[blog5 Real-World Tokenization Success Stories from Across the U.S. | Chainlink Blog3.7.2025 16:14](https://blog.chain.link/us-tokenization-success-stories/)[blogHow Chainlink Enables Cross-Chain DvP Settlement of Tokenized Assets17.6.2025 13:38](https://blog.chain.link/cre-dvp-kinexys-jp-morgan-ondo-finance/)[blogProof of Reserves for Policymakers: What It Is and Why It Matters17.6.2025 13:38](https://blog.chain.link/proof-of-reserves-for-policymakers/)[blogHow Governments Worldwide Are Exploring Blockchain Technology | Chainlink Blog17.6.2025 13:38](https://blog.chain.link/governments-exploring-blockchain/)[blogBuilding Trust in AI Agentic Workflows | Chainlink Blog12.6.2025 19:34](https://blog.chain.link/building-trust-in-ai-agentic-workflows/)[blogCCIP v1.6 Is Now Live: Unlocking Solana Support, Scaling Chain Integrations, and Reducing User Costs | Chainlink Blog12.6.2025 19:34](https://blog.chain.link/ccip-v1-6-is-now-live/)[blogHow Transfer Agency Requirements Are Met With Blockchain Infrastructure | Chainlink Blog12.6.2025 19:34](https://blog.chain.link/transfer-agency-with-blockchains/)[blogChainlink Digital Asset Insights | Stablecoin Rails Come Into Focus | Chainlink Blog12.6.2025 19:34](https://blog.chain.link/chainlink-digital-asset-insights-q1-2025/)[blogIntroducing Chainlink Rewards: Season Genesis | Chainlink Blog12.6.2025 19:34](https://blog.chain.link/chainlink-rewards-season-genesis/)[blog7 Key Principles for Proof of Reserves12.6.2025 19:34](https://blog.chain.link/7-key-principles-for-proof-of-reserves/)[blogStrengthening U.S. Federal Agencies With Blockchain Technology: 10+ Real-World Use Cases12.6.2025 19:34](https://blog.chain.link/blockchain-federal-agencies/)[blogCCIP Token Developer Attestation Is Now Generally Available | Chainlink Blog12.6.2025 19:34](https://blog.chain.link/token-developer-attestation-generally-available/)[blogProof of Reserve for Strategic Crypto Reserves | Chainlink12.6.2025 19:34](https://blog.chain.link/proof-of-reserve-strategic-bitcoin-reserves/)[blogChainlink’s Work With Coinbase, Apex Group, Paxos, and Other Major Tokenized Asset Industry Institutions12.6.2025 19:34](https://blog.chain.link/chainlink-institutional-tokenization-announcements/)[blogChainlink Quarterly Review: Q1 2025 | Chainlink Blog12.6.2025 19:34](https://blog.chain.link/quarterly-review-q1-2025/)[blogChainlink Payment Abstraction Is Now Live12.6.2025 19:34](https://blog.chain.link/payment-abstraction-svr-fee-conversion/)[blogUnited States Financial System 3.0 | Chainlink Blog12.6.2025 19:34](https://blog.chain.link/united-states-financial-system-3-0/)[blogEmpirical Evidence in AI Oracle Development | Chainlink Blog12.6.2025 19:34](https://blog.chain.link/ai-oracles/)[blogHow Chainlink CCIP Eliminates Vendor Lock-In To Empower Token Issuers | Chainlink Blog12.6.2025 19:34](https://blog.chain.link/chainlink-ccip-no-vendor-lock-in/)[blogEmpowering Agentic AI Within Financial Systems Requires Zero-Knowledge Proofs and Privacy-Preserving Technologies | Chainlink Blog12.6.2025 19:34](https://blog.chain.link/agentic-ai-in-finance/)[blogSergey Nazarov’s Key Insights from the White House Digital Asset Summit | Chainlink Blog12.6.2025 19:34](https://blog.chain.link/white-house-digital-asset-summit-insights/)[blogBlockchain in Government & Public Sector - 7 Use Cases12.6.2025 19:34](https://blog.chain.link/government-blockchain-use-cases/)[blogBuild To Scale: Empowering Innovation Through the Chainlink Ecosystem | Chainlink Blog12.6.2025 19:34](https://blog.chain.link/build-to-scale/)[blogChainlink Digital Asset Insights: Q4 2024 | Chainlink Blog12.6.2025 19:34](https://blog.chain.link/chainlink-digital-asset-insights-q4-2024/)[blogChainlink in 2025: The Final Stage of Blockchain Adoption Is Underway | Chainlink Blog12.6.2025 19:34](https://blog.chain.link/chainlink-2025/)[blogEmpowering Developers With The CCT Standard12.6.2025 19:34](https://blog.chain.link/empowering-developers-with-the-cct-standard/)[blogWhat Is the Cross-Chain Token (CCT) Standard?12.6.2025 19:34](https://blog.chain.link/what-is-cct-cross-chain-token-standard/)[blogChainlink’s Leading Role in Capital Markets and DeFi | 2024 Highlights12.6.2025 19:34](https://blog.chain.link/chainlink-2024-highlights/)[blogIntroducing SVR: A Chainlink-Powered MEV Recapture Solution For DeFi12.6.2025 19:34](https://blog.chain.link/chainlink-smart-value-recapture-svr/)[blogChainlink Digital Asset Insights: Q3 2024 | Chainlink Blog12.6.2025 19:34](https://blog.chain.link/chainlink-digital-asset-insights-q3-2024/)[blogChainlink Unveils Monumental Upgrade To Power Onchain Finance12.6.2025 19:34](https://blog.chain.link/monumental-upgrade-for-onchain-finance/)[blogChainlink Powers 3 Major Use Cases Under the Monetary Authority of Singapore’s Project Guardian | Chainlink Blog12.6.2025 19:34](https://blog.chain.link/chainlink-project-guardian/)[blogChainlink’s Major Banking and Capital Markets Announcements | Chainlink Blog12.6.2025 19:34](https://blog.chain.link/chainlink-banking-capital-markets-announcements/)[blogSmartCon 2024 Key Announcements, Highlights, and More12.6.2025 19:34](https://blog.chain.link/smartcon-2024-recap/)[blogThe Trust Dilemma: Overcoming LLM Hallucinations in Financial Services | Chainlink Blog12.6.2025 19:34](https://blog.chain.link/the-trust-dilemma/)[blogIntroducing Chainlink Runtime Environment (CRE)12.6.2025 19:34](https://blog.chain.link/introducing-chainlink-runtime-environment/)[blogChainlink DECO Sandbox: Privacy Innovation for Onchain Finance12.6.2025 19:34](https://blog.chain.link/deco-sandbox/)[blogIntroducing the CCIP Cross-Chain Token (CCT) Standard | Chainlink Blog12.6.2025 19:34](https://blog.chain.link/ccip-v-1-5-upgrade/)[blogScaling (Re)Staking Protocols Cross-Chain With CCIP12.6.2025 19:34](https://blog.chain.link/scaling-staking-protocols-cross-chain/)[blogSibos 2024: Connecting the Future of Finance Onchain | Highlights12.6.2025 19:34](https://blog.chain.link/sibos-2024-recap/)[blogIntroducing The Chainlink Platform Privacy Suite12.6.2025 19:34](https://blog.chain.link/ccip-private-transactions-blockchain-privacy-manager/)[blogSolving The Corporate Actions Data Problem With Unified Golden Records12.6.2025 19:34](https://blog.chain.link/corporate-actions-data-problem/)[blogSecure Mint Explained: How Chainlink Proof of Reserve Enhances the Security of Stablecoins, Tokenized Assets, and Wrapped Tokens | Chainlink Blog12.6.2025 19:34](https://blog.chain.link/secure-mint/)[blogThe Evolution of CBDCs: From Domestic Experiments to Interoperable Networks | Chainlink Blog12.6.2025 19:34](https://blog.chain.link/evolution-of-central-bank-digital-currencies/)[blogBitcoin Layer 2s: Explained & Examples | Chainlink12.6.2025 19:34](https://blog.chain.link/bitcoin-layer-2/)[blogPwC Germany on How Chainlink Enables Asset Tokenization12.6.2025 19:34](https://blog.chain.link/financial-services-tokenization-pwc/)[blogWhat Is Cross-Chain Compatibility? A Deep Dive | Chainlink12.6.2025 19:34](https://blog.chain.link/cross-chain-compatibility/)[blogBlockchain Interoperability Challenges Explained | Chainlink Blog12.6.2025 19:34](https://blog.chain.link/blockchain-interoperability-challenges/)[blogHow Chainlink Enables Unified Golden Records for Tokenized Assets | Chainlink Blog12.6.2025 19:34](https://blog.chain.link/unified-golden-record/)[blogOn Orchestrating Parallel Broadcasts for Distributed Systems | Chainlink Blog12.6.2025 19:34](https://blog.chain.link/orchestrating-parallel-broadcasts-for-distributed-systems/)[blogThe Intersection Between AI Models and Oracles | Chainlink Blog12.6.2025 19:34](https://blog.chain.link/oracle-networks-ai/)[blogChainlink Block Magic Hackathon Winners12.6.2025 19:34](https://blog.chain.link/block-magic-winners/)[blog3 Key Architectural Decisions Behind CCIP’s Advanced Security12.6.2025 19:34](https://blog.chain.link/ccip-security-features/)[blogCCIP Programmable Token Transfers | Chainlink Blog12.6.2025 19:34](https://blog.chain.link/ccip-programmable-token-transfers/)[blog新报告：超越通证资产发行 | Chainlink Blog12.6.2025 19:34](https://blog.chain.link/definitive-guide-to-tokenized-assets-zh/)[blogTokenization: A Global Unlock for Financial Markets | Chainlink Blog12.6.2025 19:34](https://blog.chain.link/tokenization-opportunity/)[blogHow The Chainlink Platform Unlocks LST and LRT Adoption for DeFi12.6.2025 19:34](https://blog.chain.link/chainlink-for-lsts-and-lrts/)[blogHow To Get Polygon Amoy Testnet MATIC - Guide | Chainlink12.6.2025 19:34](https://blog.chain.link/polygon-amoy-matic/)[blogExploring Consensus With Parallel Proposals: The Difference Between PBFT and BBCA-Chain | Chainlink Blog12.6.2025 19:34](https://blog.chain.link/exploring-consensus-with-parallel-proposals/)[blogScaling Onchain Verifiable Randomness With Chainlink VRF v2.5 | Chainlink Blog12.6.2025 19:34](https://blog.chain.link/introducing-vrf-v2-5/)[blogWhat Is Tokenization? | Chainlink Blog12.6.2025 19:34](https://blog.chain.link/tokenization/)[blogAnnouncing CCIP General Availability | Chainlink Blog12.6.2025 19:34](https://blog.chain.link/ccip-general-availability/)[blogChainlink Product Update: Q1 202412.6.2025 19:34](https://blog.chain.link/product-update-q1-2024/)[blogBeyond Token Issuance: How Interoperability and Real-World Data Unlock the True Value of Tokenized Assets | Chainlink Blog12.6.2025 19:34](https://blog.chain.link/definitive-guide-to-tokenized-assets/)[blogChainlink Digital Asset Insights: Q1 2024 | Chainlink Blog12.6.2025 19:34](https://blog.chain.link/chainlink-digital-asset-insights-q1-2024/)[blogIntroducing Transporter: Cross Chains With Confidence | Chainlink12.6.2025 19:34](https://blog.chain.link/transporter-launch/)[blogAccelerating CCIP Adoption Through Native ETH Transfers | Chainlink12.6.2025 19:34](https://blog.chain.link/ccip-native-eth-and-optimized-pricing/)[blogIntroducing the Chainlink Block Magic Hackathon | Chainlink12.6.2025 19:34](https://blog.chain.link/introducing-chainlink-block-magic-hackathon/)[blogWhat Is a Sybil Attack? | Chainlink12.6.2025 19:34](https://blog.chain.link/sybil-attack/)No items found.[guideTriggering smart contract execution with Chainlink Automation12.6.2025 19:34](https://go.chain.link/masterclasses/module-1-triggering-smart-contract-execution-with-chainlink-automation)[guideSend Arbitrary Data12.6.2025 19:34](https://docs.chain.link/ccip/tutorials/send-arbitrary-data)[guideUsing Chainlink Local to Test CCIP in RemixIDE12.6.2025 19:34](https://docs.chain.link/chainlink-local/build/ccip/remix)[guideUsing the StreamsLookup error handler with Automation12.6.2025 19:34](https://docs.chain.link/chainlink-automation/guides/streams-lookup-error-handler)[guideUsing Chainlink Local to Test CCIP in Your Hardhat Project12.6.2025 19:34](https://docs.chain.link/chainlink-local/build/ccip/hardhat)[guideUsing Chainlink Local to Test CCIP in Your Foundry Project12.6.2025 19:34](https://docs.chain.link/chainlink-local/build/ccip/foundry)[guideGet a Random Number using VRF Direct Funding12.6.2025 19:34](https://docs.chain.link/vrf/v2-5/direct-funding/get-a-random-number)[guideGet a Random Number using a VRF Subscription12.6.2025 19:34](https://docs.chain.link/vrf/v2-5/subscription/get-a-random-number)[guideCreate and manage VRF V2.5 subscriptions12.6.2025 19:34](https://docs.chain.link/vrf/v2-5/subscription/create-manage)[guideRegister a Custom Logic Upkeep12.6.2025 19:34](https://docs.chain.link/chainlink-automation/guides/gas-price-threshold)[guideCCIP Manual Execution12.6.2025 19:34](https://docs.chain.link/ccip/tutorials/manual-execution)[guideOptimizing Gas Limit Settings in CCIP Messages12.6.2025 19:34](https://docs.chain.link/ccip/tutorials/ccipreceive-gaslimit)[guideTransfer USDC with Data12.6.2025 19:34](https://docs.chain.link/ccip/tutorials/usdc)[guideSend Arbitrary Data and Receive Transfer Confirmation12.6.2025 19:34](https://docs.chain.link/ccip/tutorials/send-arbitrary-data-receipt-acknowledgment)[guideChecking CCIP Message Status12.6.2025 19:34](https://docs.chain.link/ccip/tutorials/get-status-offchain)[guideTest CCIP Locally12.6.2025 19:34](https://docs.chain.link/ccip/tutorials/test-ccip-locally)[guideEncode request data offchain12.6.2025 19:34](https://docs.chain.link/chainlink-functions/tutorials/encode-request-offchain)[guideTransfer Tokens with Data - Defensive Example12.6.2025 19:34](https://docs.chain.link/ccip/tutorials/programmable-token-transfers-defensive)[guideUsing User-hosted (gist) Secrets in Requests12.6.2025 19:34](https://docs.chain.link/chainlink-functions/tutorials/api-use-secrets-gist)[guideAutomate your Functions (Custom Logic Automation)12.6.2025 19:34](https://docs.chain.link/chainlink-functions/tutorials/automate-functions-custom-logic)[guideReturn multiple responses and decode them in your smart contract12.6.2025 19:34](https://docs.chain.link/chainlink-functions/tutorials/abi-decoding)[guideUsing Imports with Functions12.6.2025 19:34](https://docs.chain.link/chainlink-functions/tutorials/importing-packages)[guideTransfer Tokens Between Chains12.6.2025 19:34](https://docs.chain.link/ccip/tutorials/cross-chain-tokens)[guideRequest Computation using Chainlink Functions12.6.2025 19:34](https://docs.chain.link/chainlink-functions/tutorials/simple-computation)[guideSimulate your Functions12.6.2025 19:34](https://docs.chain.link/chainlink-functions/resources/simulation)[guideUsing Secrets in Requests with Chainlink Functions12.6.2025 19:34](https://docs.chain.link/chainlink-functions/tutorials/api-use-secrets)[guideUsing the New Chainlink Automation Job Scheduler12.6.2025 19:34](https://go.chain.link/masterclasses/module-2-using-the-new-chainlink-automation-job-scheduler)[guideUsing Off-chain Secrets in Requests with Chainlink Functions12.6.2025 19:34](https://docs.chain.link/chainlink-functions/tutorials/api-use-secrets-offchain)[guideUsing ENS with Data Feeds12.6.2025 19:34](https://docs.chain.link/data-feeds/ens)[guideAccess Data Streams Using Automation12.6.2025 19:34](https://docs.chain.link/chainlink-automation/guides/streams-lookup)[guideTransfer Tokens Between EOAs12.6.2025 19:34](https://docs.chain.link/ccip/tutorials/cross-chain-tokens-from-eoa)[guideTransfer Tokens and Data Across Chains12.6.2025 19:34](https://docs.chain.link/ccip/tutorials/programmable-token-transfers)[guideSecure Upkeeps Using the Forwarder12.6.2025 19:34](https://docs.chain.link/chainlink-automation/forwarder)[guideTest VRF Locally Using a Mock Contract12.6.2025 19:34](https://docs.chain.link/vrf/v2-5/subscription/test-locally)[guideSelecting Quality Data Feeds12.6.2025 19:34](https://docs.chain.link/data-feeds/selecting-data-feeds)[guideRegister a Time Based Upkeep12.6.2025 19:34](https://docs.chain.link/chainlink-automation/job-scheduler)[guideRegister Upkeeps Programmatically12.6.2025 19:34](https://docs.chain.link/chainlink-automation/register-upkeep-in-contract)[guideRegister a Log Trigger Upkeep12.6.2025 19:34](https://docs.chain.link/chainlink-automation/log-trigger)[guideReturn Custom Data Types with Chainlink Functions12.6.2025 19:34](https://docs.chain.link/chainlink-functions/tutorials/api-custom-response)[guideRegister a Custom Logic Upkeep12.6.2025 19:34](https://docs.chain.link/chainlink-automation/guides/register-upkeep)[guideCreating Flexible Upkeeps12.6.2025 19:34](https://docs.chain.link/chainlink-automation/flexible-upkeeps)[guideNFT Automation With PlanetIX12.6.2025 19:34](https://go.chain.link/masterclasses/module-5-nft-automation-with-planetix)[guidePOST Data to an API with Chainlink Functions12.6.2025 19:34](https://docs.chain.link/chainlink-functions/tutorials/api-post-data)[guideDynamic NFTs Enabled by Chainlink Automation12.6.2025 19:34](https://go.chain.link/masterclasses/module-3-dynamic-nfts-enabled-by-chainlink-automation)[guideMastering Cross-Chain Development With Chainlink CCIP12.6.2025 19:34](https://go.chain.link/masterclasses/ccip-module-1)[guideCall an API with HTTP Query Parameters with Chainlink Functions12.6.2025 19:34](https://docs.chain.link/chainlink-functions/tutorials/api-query-parameters)[guideManaging Upkeeps12.6.2025 19:34](https://docs.chain.link/chainlink-automation/manage-upkeeps)[guideDeFi Circuit Breakers Using Proof of Reserve12.6.2025 19:34](https://go.chain.link/masterclasses/module-4-defi-circuit-breakers-using-proof-of-reserve)[guideCross-chain  dApps and Tools12.6.2025 19:34](https://docs.chain.link/ccip/examples)[guideAcquire Test Tokens12.6.2025 19:34](https://docs.chain.link/ccip/test-tokens)[guideCall Multiple Data Sources with Chainlink Functions12.6.2025 19:34](https://docs.chain.link/chainlink-functions/tutorials/api-multiple-calls)[guideChainlink Functions Deep Dive12.6.2025 19:34](https://go.chain.link/masterclasses/functions-module-1)[guideCreate Automation-compatible Contracts12.6.2025 19:34](https://docs.chain.link/chainlink-automation/guides/compatible-contracts)[guideAutomate your Functions (Time-based Automation)12.6.2025 19:34](https://docs.chain.link/chainlink-functions/tutorials/automate-functions/)[videoThe Difference Between Tokenized Real-World Assets and Crypto #shorts12.6.2025 19:34](https://www.youtube.com/watch?v=ng2osNnajzc)[videoFidelity International, Sygnum, & Chainlink Bring NAV Data Onchain for Institutional Liquidity Fund12.6.2025 19:34](https://www.youtube.com/watch?v=8Z3F-3ugMW8)[videoThe Intersection Between AI Models and Oracles | Sergey Nazarov12.6.2025 19:34](https://www.youtube.com/watch?v=fYXHuQjC_I0)[videoClosing Ceremony | Block Magic12.6.2025 19:34](https://www.youtube.com/watch?v=vu9dXmLjEfE)[videoCapitalizing on Fund Tokenization: WisdomTree and Chainlink Share Insights12.6.2025 19:34](https://www.youtube.com/watch?v=7aFbkDlf-gk)[videoThe Market for Tokenized Assets | Sergey Nazarov12.6.2025 19:34](https://www.youtube.com/watch?v=zcT37AwRV-8)[videoChainlink's Security-First CCIP Architecture | Sergey Nazarov12.6.2025 19:34](https://www.youtube.com/watch?v=Eq89FPqR_Ok)[videoRebuilding the World In a Blockchain Format | Sergey Nazarov at Hong Kong Web3 Festival 202412.6.2025 19:34](https://www.youtube.com/watch?v=GdX72g9CQTk)[videoChainlink’s Multidimensional Platform | Johann Eid12.6.2025 19:34](https://www.youtube.com/watch?v=-j83MDkPtY0)[videoHow To Bridge Crypto With Transporter | 1-Minute Guide12.6.2025 19:34](https://www.youtube.com/watch?v=g8HhQaR1Lwo)[videoThe Unified Golden Record for Tokenized Assets | Sergey Nazarov12.6.2025 19:34](https://www.youtube.com/watch?v=uewHWJ6J1jo)[videoUsing Chainlink CCIP To Become Chain-Agnostic | Angie Walker12.6.2025 19:34](https://www.youtube.com/watch?v=yuK6amqdpyc)[videoWhat the Fourth Bitcoin Halving Represents in 202412.6.2025 19:34](https://www.youtube.com/watch?v=vw8o4pYCEIw)[videoCCIP's Role in Orchestrating Global Liquidity | Sergey Nazarov12.6.2025 19:34](https://www.youtube.com/watch?v=L3X6qdpHxbI)[videoChainlink's Strategic Position in Capital Markets in 2024 | Sergey Nazarov12.6.2025 19:34](https://www.youtube.com/watch?v=pe8LXvmhVAo)[videoThe Significance of the Smart NAV Pilot | DTCC, Chainlink, and 10 Industry Participants12.6.2025 19:34](https://www.youtube.com/watch?v=PdleEQ9Upig)[videoWhen AI and Blockchain Collide | Ari Juels and Sergey Nazarov12.6.2025 19:34](https://www.youtube.com/watch?v=tNB5-KmVuWI)[videoThe Two-Step Proof of Reserve Playbook12.6.2025 19:34](https://www.youtube.com/watch?v=srktZ9iDQOw)[videoHow Chainlink Drives Onchain Growth and Prevents Hacks | Johann Eid12.6.2025 19:34](https://www.youtube.com/watch?v=z9cZt8zx3Ro)[videoGenerando Números Aleatorios Usando Chainlink VRF | Chainlink Bootcamp - Día 812.6.2025 19:34](https://www.youtube.com/watch?v=r5Z6vE3iOyo)[videoHow to Tokenize a Real-World Asset: Complete Guide on RWAs With Patrick Collins12.6.2025 19:34](https://www.youtube.com/watch?v=KNUchSEtQV0)[videoWhat’s Next for Stablecoins? | Chainlink x Stablecoin Standard12.6.2025 19:34](https://www.youtube.com/watch?v=0FCxRPKagYU)[videoETH ETF Approved: What This Means for Ethereum and Crypto Adoption12.6.2025 19:34](https://www.youtube.com/watch?v=6d3Qbxb5HII)[videoANZ Banking Group’s Nigel Dobson on Atomic Settlement | The Future Is On Spotlight Series12.6.2025 19:34](https://www.youtube.com/watch?v=bMbvhwVrJRM)[videoHow Swift and Chainlink Are Unlocking Onchain Tokenization at Scale12.6.2025 19:34](https://www.youtube.com/watch?v=b9DSq_LiPUI)[videoTokenizing Assets With Securitize | Carlos Domingo & Sergey Nazarov at Consensus 202412.6.2025 19:34](https://www.youtube.com/watch?v=mUPKMj-23fs)[videoEuroclear and Chainlink on Digital Asset Adoption | Jørgen Ouaknine and Sergey Nazarov at Consensus12.6.2025 19:34](https://www.youtube.com/watch?v=1usY-GfDkV0)[videoBuilding Blockchain Standards for Finance | The Future Is On Spotlight Series12.6.2025 19:34](https://www.youtube.com/watch?v=Qtp8hh6QGS0)[videoTokenization: The Future of Digital Assets | Chainlink Miami Meetup12.6.2025 19:34](https://www.youtube.com/watch?v=_j3xqxxdn90)[videoReplatforming Global Finance | Sergey Nazarov at Fidelity Center for Applied Technology (FCAT)12.6.2025 19:34](https://www.youtube.com/watch?v=AWIigfcBNnQ)[videoScaling Web3 With Aptos and Chainlink | Mo Shaikh and Sergey Nazarov at Consensus 202412.6.2025 19:34](https://www.youtube.com/watch?v=wFGXBD5S8Rc)[videoChainlink's Security-First CCIP Architecture | Sergey Nazarov12.6.2025 19:34](https://www.youtube.com/watch?v=Eq89FPqR_Ok)[videoThe Market for Tokenized Assets | Sergey Nazarov12.6.2025 19:34](https://www.youtube.com/watch?v=zcT37AwRV-8)[videoCapitalizing on Fund Tokenization: WisdomTree and Chainlink Share Insights12.6.2025 19:34](https://www.youtube.com/watch?v=7aFbkDlf-gk)[videoThe Intersection Between AI Models and Oracles | Sergey Nazarov12.6.2025 19:34](https://www.youtube.com/watch?v=fYXHuQjC_I0)[videoFidelity International, Sygnum, & Chainlink Bring NAV Data Onchain for Institutional Liquidity Fund12.6.2025 19:34](https://www.youtube.com/watch?v=8Z3F-3ugMW8)[videoChainlink’s Role in the Quadrillion-Dollar Tokenized Asset Wave | Sergey Nazarov at EthCC 202412.6.2025 19:34](https://www.youtube.com/watch?v=PrWQ9OBYrxA)[videoHow To Bridge USDC12.6.2025 19:34](https://www.youtube.com/watch?v=dCDQ-xetzpM)[videoHow Krypton Aims To Mitigate MEV in DeFi12.6.2025 19:34](https://www.youtube.com/watch?v=EMK_by7Q_bY)[videoHow To Bridge USDC With Transporter | Crypto Tutorials12.6.2025 19:34](https://www.youtube.com/watch?v=uOBeZvJQ20w)[videoGenerating a Global Infrastructure | Sergey Nazarov12.6.2025 19:34](https://www.youtube.com/watch?v=UBGevMniSyI)[videoChainlink Product Update Recap | Q2 202412.6.2025 19:34](https://www.youtube.com/watch?v=R3ATz_F8xOs)[videoThe Migration of All Value Into the Onchain Format | Sergey Nazarov12.6.2025 19:34](https://www.youtube.com/watch?v=_lpfW8jMc3E)[videoTokenized Asset Infrastructure: Paving the Way for the Onchain Economy12.6.2025 19:34](https://www.youtube.com/watch?v=TaAdSElcSu8)[videoHow To Become A Blockchain Developer | Elif Hilal Umucu12.6.2025 19:34](https://www.youtube.com/watch?v=YjF_tumQ7ro)[videoUnleashing The Potential of Tokenization | Mathias Imbach of Sygnum12.6.2025 19:34](https://www.youtube.com/watch?v=tWkaUv6gz7Q)[videoChainlink Functions Tutorials Playlist12.6.2025 19:34](https://www.youtube.com/watch?v=fut2_xDJczQ&list=PLVP9aGDn-X0TrCZGlgkVr-S29cG1Bqt5s)[videoChainlink Data Streams Use Cases | SmartCon 202312.6.2025 19:34](https://www.youtube.com/watch?v=YNoJE1sG7yM)[videoWhat Is the Vision for Chainlink as the Decentralized Computing Marketplace? | Sergey Nazarov12.6.2025 19:34](https://www.youtube.com/watch?v=G8uWGzXHueo)[videoEuroclear’s Jorgen Ouaknine & Stephanie Lheureux on DLT | The Future Is On Spotlight Series12.6.2025 19:34](https://www.youtube.com/watch?v=Vj-gdKfWaiw)[videoCCIP Defense-in-Depth and the Risk Management Network | Lorenz Breidenbach at SmartCon 202312.6.2025 19:34](https://www.youtube.com/watch?v=AvMWluVzzFg)[videoHow To Transfer Tokens and Send Data Cross-Chain With Chainlink CCIP12.6.2025 19:34](https://www.youtube.com/watch?v=yJ1mXgumOAk)[videoChainlink for Capital Markets12.6.2025 19:34](https://www.youtube.com/watch?v=D1G-nxf8ANw&list=PLVP9aGDn-X0SQWdeK8vUb4Lrc_fvHRg7O&index=21)[videoChainlink Functions Masterclass12.6.2025 19:34](https://www.youtube.com/watch?v=t5eVm4bTnzo&list=PLVP9aGDn-X0RY6llt-wcV9bdwOSA3XgtP&index=6)[videoThe Chainlink Origin Story | Block Stories12.6.2025 19:34](https://www.youtube.com/watch?v=Uh9zZ4__abk)[videoGames Are Changing12.6.2025 19:34](https://www.youtube.com/watch?v=BjhBgANjfFk&list=PLVP9aGDn-X0R6B-eoutzPEBuuAerDueXi&index=42)[videoTokenized Finance Is Inevitable | Sergey Nazarov at Barclays Crypto & Blockchain Summit12.6.2025 19:34](https://www.youtube.com/watch?v=8ueUSd7Mb4Y&list=PLVP9aGDn-X0SQWdeK8vUb4Lrc_fvHRg7O&index=20)[videoHow To Use Chainlink Functions (Updated) | Chainlink Engineering Tutorials12.6.2025 19:34](https://www.youtube.com/watch?v=I-g1aaZ3_x4&list=PLVP9aGDn-X0RY6llt-wcV9bdwOSA3XgtP&index=2)[videoIntroducing Chainlink Functions: Connect the World’s APIs to Web312.6.2025 19:34](https://www.youtube.com/watch?v=YlLlg2Fm6Og&list=PLVP9aGDn-X0RY6llt-wcV9bdwOSA3XgtP)[videoConnecting Smart Contracts to AI Art With Chainlink Functions | Google AI Lead Laurence Moroney12.6.2025 19:34](https://www.youtube.com/watch?v=kG-ODpYRREQ&list=PLVP9aGDn-X0RY6llt-wcV9bdwOSA3XgtP&index=3)[videoIntro to Remix and Solidity12.6.2025 19:34](https://www.youtube.com/watch?v=hkh013dMRCY&list=PLVP9aGDn-X0Rm3dqVdz0_z188R8DBleK0&index=8)[videoUnderstanding Proof of Reserve | Chainlink Explained12.6.2025 19:34](https://www.youtube.com/watch?v=V3WLYLzpGXI&list=PLVP9aGDn-X0QsyhRbrcfBHPcURG9nQX09&index=2)[videoTokenizing Real-World Assets On-Chain | Chainlink Tech Talks #1012.6.2025 19:34](https://www.youtube.com/watch?v=3_uDuZ9Pbu0&list=PLVP9aGDn-X0SQWdeK8vUb4Lrc_fvHRg7O&index=4)[videoHow To Use Chainlink Automation To Trigger Smart Contracts in Solidity12.6.2025 19:34](https://www.youtube.com/watch?v=dj0impNJdls&list=PLVP9aGDn-X0Rm3dqVdz0_z188R8DBleK0&index=10)[videoHow To Stake LINK | Chainlink Staking Tutorial12.6.2025 19:34](https://www.youtube.com/watch?v=wfSETSSDG6c&list=PLVP9aGDn-X0QsyhRbrcfBHPcURG9nQX09&index=6)[videoBuild Dynamic Asset Monitoring12.6.2025 19:34](https://www.youtube.com/watch?v=7dINpoH2Kzc)[videoBuild a Dynamic Asset Monitoring NFT in 15 Minutes | Richard Gottleber at SmartCon 202212.6.2025 19:34](https://www.youtube.com/watch?v=7dINpoH2Kzc)[videoBuilding a Web3 Startup Through Community | SmartCon 202212.6.2025 19:34](https://www.youtube.com/watch?v=5RbcjIRxA-Y&list=PLVP9aGDn-X0T2wk796tZmPDL5hz06vn41&index=14)[videoChainlink Price Feeds Simplified | Chainlink Explained12.6.2025 19:34](https://www.youtube.com/watch?v=-pJqlI61ZKc&list=PLVP9aGDn-X0QsyhRbrcfBHPcURG9nQX09)[videoArchitecting Secure Cross-Chain Infrastructure With CCIP | Lorenz Breidenbach at SmartCon 202212.6.2025 19:34](https://www.youtube.com/watch?v=speIh3ctygM&list=PLVP9aGDn-X0RbtuqDBlr9Q8-FTT4MD0d8&index=4)[videoHow DevRel Can Help Web3 Startups Secceed  | Web3 Startups12.6.2025 19:34](https://www.youtube.com/watch?v=-fbHqS-8QoU&list=PLVP9aGDn-X0T2wk796tZmPDL5hz06vn41&index=5)[videoPrivacy-Preserving Oracles With DECO | Dahlia Malkhi and Osama Khan at SmartCon 202212.6.2025 19:34](https://www.youtube.com/watch?v=eJqZQ2_VBzo&list=PLVP9aGDn-X0RbtuqDBlr9Q8-FTT4MD0d8&index=3)[videoFair Sequencing Services in Action | Ari Juels and Pawel Szalachowski at SmartCon 202212.6.2025 19:34](https://www.youtube.com/watch?v=uuu23oqnzck&list=PLVP9aGDn-X0RbtuqDBlr9Q8-FTT4MD0d8&index=5)[videoSWIFT Is Using CCIP for Blockchain Interoperability PoC12.6.2025 19:34](https://www.youtube.com/watch?v=6DgnHKTI-EU&list=PLVP9aGDn-X0SQWdeK8vUb4Lrc_fvHRg7O&index=2)[videoMarketing Tactics for Early-Stage Web3 Startups | Web3 Startups12.6.2025 19:34](https://www.youtube.com/watch?v=ZXvtRRn_AK4&list=PLVP9aGDn-X0T2wk796tZmPDL5hz06vn41&index=6)[videoThe Economics of BFT Protocols | Economics of Web3 |  Chainlink Research Reports12.6.2025 19:34](https://www.youtube.com/watch?v=VtElxXXG3QI&list=PLVP9aGDn-X0RbtuqDBlr9Q8-FTT4MD0d8&index=48)[videoBuilding a Synthetic Asset DeFi Platform: Kain Warwick of Synthetix | Block Stories12.6.2025 19:34](https://www.youtube.com/watch?v=VQwaj1r9J_8)[videoAn Economic Model of Distributed Ledger Consensus | Economics of Web3 |  Chainlink Research Reports12.6.2025 19:34](https://www.youtube.com/watch?v=0KKDVY-_cGc&list=PLVP9aGDn-X0RbtuqDBlr9Q8-FTT4MD0d8&index=47)[videoMeasuring Product-Market Fit In Web3 and What To Do Next | Web3 Startups12.6.2025 19:34](https://www.youtube.com/watch?v=-wXCHWR1FCg&list=PLVP9aGDn-X0T2wk796tZmPDL5hz06vn41&index=3)[videoThe Economics of Arbitrage | Economics of Web3 | Chainlink Research Reports12.6.2025 19:34](https://www.youtube.com/watch?v=a1egRUbJS54&list=PLVP9aGDn-X0RbtuqDBlr9Q8-FTT4MD0d8&index=46)[videoWhat Keeps Stablecoins Stable? Economics of Web3 | Chainlink Research Reports12.6.2025 19:34](https://www.youtube.com/watch?v=SHWc8cEd58Q&list=PLVP9aGDn-X0RbtuqDBlr9Q8-FTT4MD0d8&index=45)[videoProof of Reserve and Stablecoin Stability | Chainlink Research Reports12.6.2025 19:34](https://www.youtube.com/watch?v=c2fnSbgUxTY)[videoFundraising to Build A DAO-to-DAO Uncollateralized Lending Platform | Web3 Startups12.6.2025 19:34](https://www.youtube.com/watch?v=cmjPABKhJJw&list=PLVP9aGDn-X0T2wk796tZmPDL5hz06vn41&index=13)[videoWeb3 Startups: How to Build a Developer Community | Web3 Startups12.6.2025 19:34](https://www.youtube.com/watch?v=OeRxIvr5EPM&list=PLVP9aGDn-X0T2wk796tZmPDL5hz06vn41&index=4)[videoHow Space and Time Raised $10M to Build a Decentralized Data Platform | Web3 Startups12.6.2025 19:34](https://www.youtube.com/watch?v=eU0_kOpI8NI&list=PLVP9aGDn-X0T2wk796tZmPDL5hz06vn41&index=12)[videoEarly-Stage Web3 Startup Funding | Web3 Startups12.6.2025 19:34](https://www.youtube.com/watch?v=-1n4e2wh13I&list=PLVP9aGDn-X0T2wk796tZmPDL5hz06vn41&index=2)[videoUnderstanding Blockchain Adoption | Economics of Web3 | Chainlink Research Reports12.6.2025 19:34](https://www.youtube.com/watch?v=E7JLGUBSgdM&list=PLVP9aGDn-X0RbtuqDBlr9Q8-FTT4MD0d8&index=43)[videoThe Economics of NFTs | Chainlink Research Reports12.6.2025 19:34](https://www.youtube.com/watch?v=sWJpFJdjJzc&list=PLVP9aGDn-X0RbtuqDBlr9Q8-FTT4MD0d8&index=42)[videoSolidity, Blockchain y Smart Contracts - De Cero a Experto12.6.2025 19:34](https://www.youtube.com/watch?v=yN3zpI3sNAE&list=PLVP9aGDn-X0SXhGUjkzTgXB4nKEE3_YvW&index=1)[videoThe Economics of Web3 Research Series12.6.2025 19:34](https://www.youtube.com/watch?v=Kk3iEbPDoyc&list=PLVP9aGDn-X0RbtuqDBlr9Q8-FTT4MD0d8&index=41)[videoReinventing Insurance on the Blockchain: Hugh Karp of Nexus Mutual | Block Stories12.6.2025 19:34](https://www.youtube.com/watch?v=AwwSlfkoWSs&list=PLVP9aGDn-X0SlXjsq41xHrzU1r34aXNUK)[videoVerification Costs and the Economics of Blockchain | Chainlink Research Report12.6.2025 19:34](https://www.youtube.com/watch?v=aupy9yGpjzI&list=PLVP9aGDn-X0RbtuqDBlr9Q8-FTT4MD0d8&index=40)[videoNFTs and the Digital Divide | Ethical Issues Surrounding NFTs and Data Monetization12.6.2025 19:34](https://www.youtube.com/watch?v=pMCaeQIPFpI&list=PLVP9aGDn-X0RbtuqDBlr9Q8-FTT4MD0d8&index=39)[videoUsing Data Feeds with Solana12.6.2025 19:34](https://www.youtube.com/watch?v=PrcAjN0Vw5w&list=PLVP9aGDn-X0QwJVbQvuKr-zrh2_DV5M6J&index=7)[videoSmart Contract Automation Masterclass | Module #212.6.2025 19:34](https://www.youtube.com/watch?v=UT2qpUh0tmA)[videoUnderstanding the Cross-Chain Interoperability Protocol (CCIP)12.6.2025 19:34](https://www.youtube.com/watch?v=btbIgwJy29s&list=PLVP9aGDn-X0QsyhRbrcfBHPcURG9nQX09&index=5)[videoSmart Contract Automation Masterclass | Module #112.6.2025 19:34](https://www.youtube.com/watch?v=D3rMFshrj7c)[videoHow Web3 and Smart Contracts Advance Patient-Centered Healthcare12.6.2025 19:34](https://www.youtube.com/watch?v=EKaTYC8G5Yw&list=PLVP9aGDn-X0RbtuqDBlr9Q8-FTT4MD0d8&index=38)[videoHow DeFi Can Finance Sustainable Energy in Developing Countries12.6.2025 19:34](https://www.youtube.com/watch?v=KD4DMQUFCr0&list=PLVP9aGDn-X0RbtuqDBlr9Q8-FTT4MD0d8&index=37)[videoHow To Create Dynamic NFTs Using Chainlink Automation | Chainlink Engineering Tutorials12.6.2025 19:34](https://www.youtube.com/watch?v=E7Rm1LUKhj4&list=PLVP9aGDn-X0QwJVbQvuKr-zrh2_DV5M6J&index=8)[QuickstartDirect Staking Guide for Third-Party Integrators24.6.2025 11:49](https://docs.chain.link/quickstarts/ccip-direct-staking)[QuickstartAutomated Portfolio Manager12.6.2025 19:34](https://docs.chain.link/quickstarts/automated-portfolio-manager)[QuickstartAutomation Station12.6.2025 19:34](https://docs.chain.link/quickstarts/automation-station)[QuickstartVRF-Enabled LootBox/Pack Contract12.6.2025 19:34](https://docs.chain.link/quickstarts/vrf-enabled-lootbox-pack)[QuickstartHardhat Chainlink Plugin12.6.2025 19:34](https://docs.chain.link/quickstarts/hardhat-plugin)[QuickstartPass VRF Costs to the End User12.6.2025 19:34](https://docs.chain.link/quickstarts/pass-cost-to-end-user)[QuickstartETH Balance Monitor12.6.2025 19:34](https://docs.chain.link/quickstarts/eth-balance-monitor)[QuickstartCircuit Breaker12.6.2025 19:34](https://docs.chain.link/quickstarts/circuit-breaker)[QuickstartVRF-enabled Mystery Box12.6.2025 19:34](https://docs.chain.link/quickstarts/vrf-mystery-box)[QuickstartHistorical Price Feeds API12.6.2025 19:34](https://docs.chain.link/quickstarts/historical-price-feeds-api)[QuickstartDynamic Metadata with Automation12.6.2025 19:34](https://docs.chain.link/quickstarts/dynamic-metadata)[QuickstartDeploy your First Smart Contract12.6.2025 19:34](https://docs.chain.link/quickstarts/deploy-your-first-contract)[QuickstartTime-based Upkeeps12.6.2025 19:34](https://docs.chain.link/quickstarts/time-based-upkeep)[QuickstartBatch Collection Reveal12.6.2025 19:34](https://docs.chain.link/quickstarts/batch-reveal)[QuickstartChainlink Demo App12.6.2025 19:34](https://www.chainlink-demo.app/)[QuickstartChainlink Functions Showcase12.6.2025 19:34](https://docs.chain.link/quickstarts/functions-demo-app)[Quickstartweb3.js Plugin12.6.2025 19:34](https://docs.chain.link/quickstarts/web3js)[QuickstartDev3 Chainlink SDK12.6.2025 19:34](https://docs.chain.link/quickstarts/dev3-chainlink-sdk)[QuickstartChainlink Hardhat Starter Kit12.6.2025 19:34](https://docs.chain.link/quickstarts/chainlink-hardhat-starter-kit)[QuickstartFoundry Chainlink Toolkit12.6.2025 19:34](https://docs.chain.link/quickstarts/foundry-chainlink-toolkit)[QuickstartSolana Pricefeeds Showcase12.6.2025 19:34](https://docs.chain.link/quickstarts/price-feeds-showcase)[courseBootcamp en Español para desarrolladores de Smart Contracts 202312.6.2025 19:34](https://go.chain.link/bootcamp/espanol-2023)[courseChainlink Viet Nam Bootcamp12.6.2025 19:34](https://go.chain.link/bootcamp/xac-nhan-vietnamese-2023)[courseBootcamp para Desenvolvedores de Smart Contracts em Português 202312.6.2025 19:34](https://go.chain.link/bootcamp/confirmacao-portugues-2023)[courseBootcamp 2021 On Demand12.6.2025 19:34](https://go.chain.link/bootcamp/smart-contract-developer-bootcamp-2021)[Beginner TutorialGetting Started with VRF12.6.2025 19:34](https://docs.chain.link/vrf/v2/getting-started)[Beginner TutorialGetting Started with CCIP12.6.2025 19:34](https://docs.chain.link/ccip/getting-started)[Beginner TutorialGetting Started with Data Streams12.6.2025 19:34](https://docs.chain.link/data-streams/getting-started)[Beginner TutorialUsing Data Feeds on StarkNet12.6.2025 19:34](https://docs.chain.link/data-feeds/starknet)[Beginner TutorialUsing Data Feeds on EVM Chains12.6.2025 19:34](https://docs.chain.link/data-feeds/using-data-feeds)[Beginner TutorialData Feeds on Solana12.6.2025 19:34](https://docs.chain.link/data-feeds/solana)[Beginner TutorialGetting Started with Automation12.6.2025 19:34](https://docs.chain.link/chainlink-automation/getting-started)[Beginner TutorialDirect Funding Tutorial12.6.2025 19:34](https://docs.chain.link/vrf/v2/direct-funding)[Beginner TutorialProgrammatic Subscription12.6.2025 19:34](https://docs.chain.link/vrf/v2/subscription/examples/programmatic-subscription)[Beginner TutorialPublique o seu primeiro contrato inteligente em 1 hora12.6.2025 19:34](https://go.chain.link/tutorials/pt-become-a-web3-developer-in-one-hour)[Beginner TutorialBecome a Web3 Developer in One Hour12.6.2025 19:34](https://go.chain.link/tutorials/become-a-web3-developer-in-one-hour)[Beginner TutorialRandom Numbers: Using Chainlink VRF12.6.2025 19:34](https://docs.chain.link/getting-started/intermediates-tutorial)[Beginner TutorialDespliega tu Primer Contrato Inteligente en Una Hora12.6.2025 19:34](https://go.chain.link/tutorials/es-become-a-web3-developer-in-one-hour)[Beginner TutorialDeploy Your First Smart Contract on Arbitrum12.6.2025 19:34](https://go.chain.link/tutorials/deploy-your-first-smart-contract-on-arbitrum)[Beginner TutorialDeploy Your First Smart Contract12.6.2025 19:34](https://docs.chain.link/getting-started/deploy-your-first-contract)[Beginner TutorialConsuming Data Feeds12.6.2025 19:34](https://docs.chain.link/getting-started/consuming-data-feeds)[Beginner TutorialGetting Started with Functions12.6.2025 19:34](https://docs.chain.link/chainlink-functions/getting-started)[Beginner TutorialChainlink Overview12.6.2025 19:34](https://docs.chain.link/getting-started/conceptual-overview)[Beginner TutorialCreate Dynamic NFTs12.6.2025 19:34](https://docs.chain.link/chainlink-automation/tutorials/dynamic-nft)[Beginner TutorialAutomate Top Up for VRF12.6.2025 19:34](https://docs.chain.link/chainlink-automation/tutorials/vrf-sub-monitor)[Beginner TutorialVault Harvester12.6.2025 19:34](https://docs.chain.link/chainlink-automation/tutorials/vault-harvester)[Beginner TutorialAutomate Top Up for contract Balances12.6.2025 19:34](https://docs.chain.link/chainlink-automation/tutorials/eth-balance)[Beginner TutorialBatch NFT Reveal12.6.2025 19:34](https://docs.chain.link/chainlink-automation/tutorials/batch-nft)No items found.[documentationsChainlink Local Solidity contracts API reference12.6.2025 19:34](https://docs.chain.link/chainlink-local/api-reference/solidity)[documentationsChainlink Local Architecture12.6.2025 19:34](https://docs.chain.link/chainlink-local/learn/architecture)[documentationsContributing to Chainlink Local12.6.2025 19:34](https://docs.chain.link/chainlink-local/learn/contributing)[documentationsVRF Cost Estimation on Arbitrum12.6.2025 19:34](https://docs.chain.link/vrf/v2-5/arbitrum-cost-estimation)[documentationsChainlink Local12.6.2025 19:34](https://docs.chain.link/chainlink-local)[documentationsUsing VRF - Direct Funding12.6.2025 19:34](https://docs.chain.link/vrf/v2-5/overview/direct-funding)[documentationsUsing VRF - Subscription Method12.6.2025 19:34](https://docs.chain.link/vrf/v2-5/overview/subscription)[documentationsMigrating from VRF v212.6.2025 19:34](https://docs.chain.link/vrf/v2-5/migration-from-v2)[documentationsMigrating from VRF v112.6.2025 19:34](https://docs.chain.link/vrf/v2-5/migration-from-v1)[documentationsMigrate to Automation v2.112.6.2025 19:34](https://docs.chain.link/chainlink-automation/guides/migrate-to-v2)[documentationsJavaScript code API Reference12.6.2025 19:34](https://docs.chain.link/chainlink-functions/api-reference/javascript-source)[documentationsFunctionsRequest library API Reference12.6.2025 19:34](https://docs.chain.link/chainlink-functions/api-reference/functions-request)[documentationsChainlink Functions Release Notes12.6.2025 19:34](https://docs.chain.link/chainlink-functions/resources/release-notes)[documentationsExample Cross-chain dApps and Tools12.6.2025 19:34](https://docs.chain.link/ccip/examples)[documentationsCCIP Billing12.6.2025 19:34](https://docs.chain.link/ccip/billing)[documentationsData Streams Report Schema12.6.2025 19:34](https://docs.chain.link/data-streams/reference/report-schema)[documentationsChainlink CCIP Service Responsibility12.6.2025 19:34](https://docs.chain.link/ccip/service-responsibility)[documentationsCCIP Service Limits12.6.2025 19:34](https://docs.chain.link/ccip/service-limits)[documentationsData Streams Developer Responsibilities12.6.2025 19:34](https://docs.chain.link/data-streams/developer-responsibilities)[documentationsStreams Direct Reference12.6.2025 19:34](https://docs.chain.link/data-streams/reference/streams-direct)[documentationsStreams Trade Interface12.6.2025 19:34](https://docs.chain.link/data-streams/reference/streams-trade-interface)[documentationsData Streams Liquidity-Weighted Bid-Ask Prices12.6.2025 19:34](https://docs.chain.link/data-streams/concepts/liquidity-weighted-prices)[documentationsStreams Direct SDK12.6.2025 19:34](https://docs.chain.link/data-streams/tutorials/streams-direct/)[documentationsData Streams Architecture12.6.2025 19:34](https://docs.chain.link/data-streams/architecture)[documentationsStreams Trade12.6.2025 19:34](https://docs.chain.link/data-streams/tutorials/streams-trade/)[documentationsData Streams Billing12.6.2025 19:34](https://docs.chain.link/data-streams/billing)[documentationsVRF Supported Networks - Direct Funding Methods12.6.2025 19:34](https://docs.chain.link/vrf/v2/direct-funding/supported-networks)[documentationsVRF Supported Networks12.6.2025 19:34](https://docs.chain.link/vrf/v2-5/supported-networks)[documentationsSecrets Management12.6.2025 19:34](https://docs.chain.link/chainlink-functions/resources/secrets)[documentationsFunctions Service Responsibility12.6.2025 19:34](https://docs.chain.link/chainlink-functions/service-responsibility)[documentationsCCIP Release Notes12.6.2025 19:34](https://docs.chain.link/ccip/release-notes)[documentationsData Streams Interfaces12.6.2025 19:34](https://docs.chain.link/data-streams/reference/interfaces)[documentationsReport Schema Reference12.6.2025 19:34](https://docs.chain.link/data-streams/reference/report-schema)[documentationsData Streams Release Notes12.6.2025 19:34](https://docs.chain.link/data-streams/release-notes)[documentationsData Stream IDs12.6.2025 19:34](https://docs.chain.link/data-streams/stream-ids)[documentationsUsing Solana Data Feeds On-Chain12.6.2025 19:34](https://docs.chain.link/data-feeds/solana/using-data-feeds-solana)[documentationsUsing Solana Data Feeds Off-Chain12.6.2025 19:34](https://docs.chain.link/data-feeds/solana/using-data-feeds-off-chain)[documentationsRate and Volatility Feeds Addresses12.6.2025 19:34](https://docs.chain.link/data-feeds/rates-feeds/addresses?network=ethereum&page=1)[documentationsCCIP Supported Networks12.6.2025 19:34](https://docs.chain.link/ccip/supported-networks)[documentationsTroubleshooting and Debugging Upkeeps12.6.2025 19:34](https://docs.chain.link/chainlink-automation/reference/debugging-errors)[documentationsAutomation Interfaces12.6.2025 19:34](https://docs.chain.link/chainlink-automation/reference/automation-interfaces)[documentationsAutomation Contracts12.6.2025 19:34](https://docs.chain.link/chainlink-automation/reference/automation-contracts)[documentationsAutomation Best Practices12.6.2025 19:34](https://docs.chain.link/chainlink-automation/concepts/best-practice)[documentationsAutomation Release Notes12.6.2025 19:34](https://docs.chain.link/chainlink-automation/overview/automation-release-notes)[documentationsAutomation Supported Networks12.6.2025 19:34](https://docs.chain.link/chainlink-automation/overview/supported-networks)[documentationsAutomation Concepts12.6.2025 19:34](https://docs.chain.link/chainlink-automation/automation-concepts)[documentationsDeveloper Communications12.6.2025 19:34](https://docs.chain.link/resources/developer-communications?parent=gettingStarted)[documentationsEstimating VRF Costs12.6.2025 19:34](https://docs.chain.link/vrf/v2/estimating-costs)[documentationsVRF Best Practices12.6.2025 19:34](https://docs.chain.link/vrf/v2-5/best-practices)[documentationsVRF Security Considerations12.6.2025 19:34](https://docs.chain.link/vrf/v2-5/security)[documentationsCross-chain bridges and associated risks12.6.2025 19:34](https://docs.chain.link/resources/bridge-risks?parent=gettingStarted)[documentationsLINK Token Contracts12.6.2025 19:34](https://docs.chain.link/resources/link-token-contracts?parent=gettingStarted)[documentationsOff-Chain Reporting12.6.2025 19:34](https://docs.chain.link/architecture-overview/off-chain-reporting?parent=gettingStarted)[documentationsFunctionsClient API Reference12.6.2025 19:34](https://docs.chain.link/chainlink-functions/api-reference/functions-client)[documentationsFunctions library API Reference12.6.2025 19:34](https://docs.chain.link/chainlink-functions/api-reference/functions)[documentationsChainlink Functions Service Limits12.6.2025 19:34](https://docs.chain.link/chainlink-functions/resources/service-limits)[documentationsFunctions Supported Networks12.6.2025 19:34](https://docs.chain.link/chainlink-functions/supported-networks)[documentationsFunctions Billing12.6.2025 19:34](https://docs.chain.link/chainlink-functions/resources/billing)[documentationsManaging Subscriptions for Functions12.6.2025 19:34](https://docs.chain.link/chainlink-functions/resources/subscriptions)[documentationsFunctions Playground12.6.2025 19:34](https://docs.chain.link/chainlink-functions/resources/playground)[documentationsFunctions Architecture12.6.2025 19:34](https://docs.chain.link/chainlink-functions/resources/architecture)[documentationsChainlink Functions Concepts12.6.2025 19:34](https://docs.chain.link/chainlink-functions/resources/concepts)[documentationsFeed Registry API Reference12.6.2025 19:34](https://docs.chain.link/data-feeds/feed-registry/feed-registry-functions)[documentationsFeed Registry12.6.2025 19:34](https://docs.chain.link/data-feeds/feed-registry)[documentationsData Feeds API Reference12.6.2025 19:34](https://docs.chain.link/data-feeds/api-reference)[documentationsNFT Floor Price Feed Addresses12.6.2025 19:34](https://docs.chain.link/data-feeds/nft-floor-price/addresses)[documentationsL2 Sequencer Uptime Feeds12.6.2025 19:34](https://docs.chain.link/data-feeds/l2-sequencer-feeds)[documentationsRate and Volatility Feeds12.6.2025 19:34](https://docs.chain.link/data-feeds/rates-feeds)[documentationsNFT Floor Price Feeds12.6.2025 19:34](https://docs.chain.link/data-feeds/nft-floor-price)[documentationsPrice Feeds12.6.2025 19:34](https://docs.chain.link/data-feeds/price-feeds)[documentationsProof of Reserve Feed Addresses12.6.2025 19:34](https://docs.chain.link/data-feeds/proof-of-reserve/addresses)[documentationsProof of Reserve Feeds12.6.2025 19:34](https://docs.chain.link/data-feeds/proof-of-reserve)[documentationsPrice Feed Contract Addresses12.6.2025 19:34](https://docs.chain.link/data-feeds/price-feeds/addresses)[documentationsCCIPReceiver API Reference12.6.2025 19:34](https://docs.chain.link/ccip/api-reference/ccip-receiver)[documentationsCCIP Concepts12.6.2025 19:34](https://docs.chain.link/ccip/concepts)[documentationsCCIP Test Tokens12.6.2025 19:34](https://docs.chain.link/ccip/test-tokens)[documentationsCCIP Best Practices12.6.2025 19:34](https://docs.chain.link/ccip/best-practices)[documentationsCCIP Architecture and Billing12.6.2025 19:34](https://docs.chain.link/ccip/architecture)[documentationsErrors API Reference12.6.2025 19:34](https://docs.chain.link/ccip/api-reference/errors)[documentationsClient Library API Reference12.6.2025 19:34](https://docs.chain.link/ccip/api-reference/client)[documentationsAutomation Architecture12.6.2025 19:34](https://docs.chain.link/chainlink-automation/automation-architecture)[documentationsAutomation Economics12.6.2025 19:34](https://docs.chain.link/chainlink-automation/automation-economics)[documentationsIRouterClient API Reference12.6.2025 19:34](https://docs.chain.link/ccip/api-reference/i-router-client).B{fill:#5873c2}.C{stroke:#5873c2}.D{stroke-linejoin:round}.B{fill:#5873c2}.C{stroke:#5873c2}.D{stroke-width:.472}.E{stroke-linejoin:round}popular[View all resources](/resources)
## Explore resources for every level

### Beginner
[Chainlink Fundamentals Course](https://updraft.cyfrin.io/courses)[Functions 101](https://docs.chain.link/chainlink-functions/getting-started)[Getting Started With Data Feeds](https://docs.chain.link/data-feeds/getting-started)
### Intermediate
[Getting Started With CCIP](https://docs.chain.link/ccip/getting-started)[CCIP: Transfer Tokens and Messages](https://docs.chain.link/ccip/tutorials/programmable-token-transfers-defensive)[Data Streams With Hardhat CLI](https://docs.chain.link/data-streams/getting-started-hardhat)
### Expert
[Error Handling With Data Streams](https://docs.chain.link/chainlink-automation/guides/streams-lookup-error-handler)[Imported Packages for Functions](https://docs.chain.link/chainlink-functions/tutorials/importing-packages)[CCIP Messages With Receipts](https://docs.chain.link/ccip/tutorials/send-arbitrary-data-receipt-acknowledgment)Featured demo[View all demos](/demos)
## Build your first Web3 dApp with these step-by-step demos
Tab 1Tab 2Tab 3[Launch demo](https://rugby-demo.app/)Autoplay video here
```java
pragma solidity ^0.8.7;

import {ResultsConsumer} from "./ResultsConsumer.sol";
import {NativeTokenSender} from "./ccip/NativeTokenSender.sol";
import {AutomationCompatibleInterface} from "@chainlink/contracts/src/v0.8/AutomationCompatible.sol";

struct Config {
  address oracle;
  address ccipRouter;
  address link;
  address weth9Token;
  address exchangeToken;
  address uniswapV3Router;
  uint64 subscriptionId;
  uint64 destinationChainSelector;
  uint32 gasLimit;
  bytes secrets;
  string source;
}

contract SportsPredictionGame is ResultsConsumer, NativeTokenSender, AutomationCompatibleInterface {
  uint256 private constant MIN_WAGER = 0.00001 ether;
  uint256 private constant MAX_WAGER = 0.01 ether;
  uint256 private constant GAME_RESOLVE_DELAY = 2 hours;

  mapping(uint256 => Game) private games;
  mapping(address => mapping(uint256 => Prediction[])) private predictions;

  mapping(uint256 => bytes32) private pendingRequests;

  uint256[] private activeGames;
  uint256[] private resolvedGames;

  struct Game {
    uint256 sportId;
    uint256 externalId;
    uint256 timestamp;
    uint256 homeWagerAmount;
    uint256 awayWagerAmount;
    bool resolved;
    Result result;
  }

  struct Prediction {
    uint256 gameId;
    Result result;
    uint256 amount;
    bool claimed;
  }

  enum Result {
    None,
    Home,
    Away 
  }

  event GameRegistered(uint256 indexed gameId);
  event GameResolved(uint256 indexed gameId, Result result);
  event Predicted(address indexed user, uint256 indexed gameId, Result result, uint256 amount);
  event Claimed(address indexed user, uint256 indexed gameId, uint256 amount);

  error GameAlreadyRegistered();
  error TimestampInPast();
  error GameNotRegistered();
  error GameIsResolved();
  error GameAlreadyStarted();
  error InsufficientValue();
  error ValueTooHigh();
  error InvalidResult();
  error GameNotResolved();
  error GameNotReadyToResolve();
  error ResolveAlreadyRequested();
  error NothingToClaim();

  constructor(
    Config memory config
  )
    ResultsConsumer(config.oracle, config.subscriptionId, config.source, config.secrets, config.gasLimit)
    NativeTokenSender(
      config.ccipRouter,
      config.link,
      config.weth9Token,
      config.exchangeToken,
      config.uniswapV3Router,
      config.destinationChainSelector
    )
  {}

  function predict(uint256 gameId, Result result) public payable {
    Game memory game = games[gameId];
    uint256 wagerAmount = msg.value;

    if (game.externalId == 0) revert GameNotRegistered();
    if (game.resolved) revert GameIsResolved();
    if (game.timestamp < block.timestamp) revert GameAlreadyStarted();
    if (wagerAmount < MIN_WAGER) revert InsufficientValue();
    if (wagerAmount > MAX_WAGER) revert ValueTooHigh();

    if (result == Result.Home) games[gameId].homeWagerAmount += wagerAmount;
    else if (result == Result.Away) games[gameId].awayWagerAmount += wagerAmount;
    else revert InvalidResult();

    predictions[msg.sender][gameId].push(Prediction(gameId, result, wagerAmount, false));
    emit Predicted(msg.sender, gameId, result, wagerAmount);
  }

  function registerAndPredict(uint256 sportId, uint256 externalId, uint256 timestamp, Result result) external payable {
    uint256 gameId = _registerGame(sportId, externalId, timestamp);
    predict(gameId, result);
  }

  function claim(uint256 gameId, bool transfer) external {
    Game memory game = games[gameId];
    address user = msg.sender;

    if (!game.resolved) revert GameNotResolved();

    uint256 totalWinnings = 0;
    Prediction[] memory userPredictions = predictions[user][gameId];
    for (uint256 i = 0; i < userPredictions.length; i++) {
      Prediction memory prediction = userPredictions[i];
      if (prediction.claimed) continue;
      if (game.result == Result.None) {
        totalWinnings += prediction.amount;
      } else if (prediction.result == game.result) {
        uint256 winnings = calculateWinnings(gameId, prediction.amount, prediction.result);
        totalWinnings += winnings;
      }
      predictions[user][gameId][i].claimed = true;
    }

    if (totalWinnings == 0) revert NothingToClaim();

    if (transfer) {
      _sendTransferRequest(user, totalWinnings);
    } else {
      payable(user).transfer(totalWinnings);
    }

    emit Claimed(user, gameId, totalWinnings);
  }

  function _registerGame(uint256 sportId, uint256 externalId, uint256 timestamp) internal returns (uint256 gameId) {
    gameId = getGameId(sportId, externalId);

    if (games[gameId].externalId != 0) revert GameAlreadyRegistered();
    if (timestamp < block.timestamp) revert TimestampInPast();

    games[gameId] = Game(sportId, externalId, timestamp, 0, 0, false, Result.None);
    activeGames.push(gameId);

    emit GameRegistered(gameId);
  }

  function _requestResolve(uint256 gameId) internal {
    Game memory game = games[gameId];

    if (pendingRequests[gameId] != 0) revert ResolveAlreadyRequested();
    if (game.externalId == 0) revert GameNotRegistered();
    if (game.resolved) revert GameIsResolved();
    if (!readyToResolve(gameId)) revert GameNotReadyToResolve();

    pendingRequests[gameId] = _requestResult(game.sportId, game.externalId);
  }

  function _processResult(uint256 sportId, uint256 externalId, bytes memory response) internal override {
    uint256 gameId = getGameId(sportId, externalId);
    Result result = Result(uint256(bytes32(response)));
    _resolveGame(gameId, result);
  }

  function _resolveGame(uint256 gameId, Result result) internal {
    games[gameId].result = result;
    games[gameId].resolved = true;

    resolvedGames.push(gameId);
    _removeFromActiveGames(gameId);

    emit GameResolved(gameId, result);
  }

  function _removeFromActiveGames(uint256 gameId) internal {
    uint256 index;
    for (uint256 i = 0; i < activeGames.length; i++) {
      if (activeGames[i] == gameId) {
        index = i;
        break;
      }
    }
    for (uint256 i = index; i < activeGames.length - 1; i++) {
      activeGames[i] = activeGames[i + 1];
    }
    activeGames.pop();
  }

  function getGameId(uint256 sportId, uint256 externalId) public pure returns (uint256) {
    return (sportId << 128) | externalId;
  }

  function getGame(uint256 gameId) external view returns (Game memory) {
    return games[gameId];
  }

  function getActiveGames() public view returns (Game[] memory) {
    Game[] memory activeGamesArray = new Game[](activeGames.length);
    for (uint256 i = 0; i < activeGames.length; i++) {
      activeGamesArray[i] = games[activeGames[i]];
    }
    return activeGamesArray;
  }

  function getActivePredictions(address user) external view returns (Prediction[] memory) {
    uint256 totalPredictions = 0;
    for (uint256 i = 0; i < activeGames.length; i++) {
      totalPredictions += predictions[user][activeGames[i]].length;
    }
    uint256 index = 0;
    Prediction[] memory userPredictions = new Prediction[](totalPredictions);
    for (uint256 i = 0; i < activeGames.length; i++) {
      Prediction[] memory gamePredictions = predictions[user][activeGames[i]];
      for (uint256 j = 0; j < gamePredictions.length; j++) {
        userPredictions[index] = gamePredictions[j];
        index++;
      }
    }
    return userPredictions;
  }

  function getPastPredictions(address user) external view returns (Prediction[] memory) {
    uint256 totalPredictions = 0;
    for (uint256 i = 0; i < resolvedGames.length; i++) {
      totalPredictions += predictions[user][resolvedGames[i]].length;
    }
    uint256 index = 0;
    Prediction[] memory userPredictions = new Prediction[](totalPredictions);
    for (uint256 i = 0; i < resolvedGames.length; i++) {
      Prediction[] memory gamePredictions = predictions[user][resolvedGames[i]];
      for (uint256 j = 0; j < gamePredictions.length; j++) {
        userPredictions[index] = gamePredictions[j];
        index++;
      }
    }
    return userPredictions;
  }

  function isPredictionCorrect(address user, uint256 gameId, uint32 predictionIdx) external view returns (bool) {
    Game memory game = games[gameId];
    if (!game.resolved) return false;
    Prediction memory prediction = predictions[user][gameId][predictionIdx];
    return prediction.result == game.result;
  }

  function calculateWinnings(uint256 gameId, uint256 wager, Result result) public view returns (uint256) {
    Game memory game = games[gameId];
    uint256 totalWager = game.homeWagerAmount + game.awayWagerAmount;
    uint256 winnings = (wager * totalWager) / (result == Result.Home ? game.homeWagerAmount : game.awayWagerAmount);
    return winnings;
  }

  function readyToResolve(uint256 gameId) public view returns (bool) {
    return games[gameId].timestamp + GAME_RESOLVE_DELAY < block.timestamp;
  }

  function checkUpkeep(bytes memory) public view override returns (bool, bytes memory) {
    Game[] memory activeGamesArray = getActiveGames();
    for (uint256 i = 0; i < activeGamesArray.length; i++) {
      uint256 gameId = getGameId(activeGamesArray[i].sportId, activeGamesArray[i].externalId);
      if (readyToResolve(gameId) && pendingRequests[gameId] == 0) {
        return (true, abi.encodePacked(gameId));
      }
    }
    return (false, "");
  }

  function performUpkeep(bytes calldata data) external override {
    uint256 gameId = abi.decode(data, (uint256));
    _requestResolve(gameId);
  }

  function deletePendingRequest(uint256 gameId) external onlyOwner {
    delete pendingRequests[gameId];
  }
}
```

Code copied!
### Rugby predictions demo
See how Chainlink CCIP, Functions, and Automation combine to power a prediction dApp that uses real-time sports data to trigger automatic payouts.

DemoArchitectureCodeTip: Use the toggle to see the different layers of the demoExplore resources[View all resources](/resources)
## Browse our resources
From beginner tutorials and Quickstarts, videos, and courses, find the learning path that suits you.

Browse by product[CCIPNew](/products/ccip)[VRFNew](/products/vrf)[DataNew](/products/data)[AutomationNew](/products/automation)[FunctionsNew](/products/functions)[GeneralNew](/products/general)Browse by use-case
### DeFi
.use-case-card-link {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  cursor: pointer;
  z-index: 2;
}
### NFTs
.use-case-card-link {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  cursor: pointer;
  z-index: 2;
}
### dApps
.use-case-card-link {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  cursor: pointer;
  z-index: 2;
}
### Real Estate
.use-case-card-link {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  cursor: pointer;
  z-index: 2;
}
### Climate Change
.use-case-card-link {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  cursor: pointer;
  z-index: 2;
}
### Gaming
.use-case-card-link {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  cursor: pointer;
  z-index: 2;
}
### Smart Contracts
.use-case-card-link {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  cursor: pointer;
  z-index: 2;
}
### Insurance
.use-case-card-link {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  cursor: pointer;
  z-index: 2;
}
## Deploy on testnet with Chainlink crypto faucets
[Get testnet tokens](https://faucets.chain.link/)Events & webinars[View all events](https://chain.link/community/events)
## An international movement building tomorrow, today
[Oct7New York CityBlockchain Fundamentals](https://luma.com/cl_fordham01)[Oct29OnlineChainlink Workshop | Cómo crear una Stablecoin con Chainlink](https://luma.com/gjxwhzv7)[Nov3New York CityDay 0: Chainlink Run Club with Blockchain NYC](https://luma.com/9x40bgg8)[Nov3New York CityDay 0: Chainlink Hotpot Social with HotpotDAO](https://luma.com/6xzyw3xg)
## Get the latest Chainlink content straight to your inbox.
Email AddressYes, I agree to receive email communications from Chainlink.Thank you for signing up! Please check your inbox to confirm your subscription.Oops! Something went wrong while submitting the form. Please try again
### Developers

• Docs
• Builder Quick Links
• Faucets
• Developer Hub
• Chainlink Hackathon
• Bootcamp
• Use Cross-Chain (CCIP)
• Use Data Feeds
• Use Randomness (VRF)
• Use Automation
• Use Functions
• Node Operators

### Products

• Cross-Chain
• Data Streams
• Market and Data Feeds
• Functions
• VRF
• Automation
• Proof of Reserve

### Use Cases

• Overview
• Asset Tokenization
• Financial Services
• DeFi
• Gaming
• NFT Collectibles
• Climate Markets
• Enterprise
• Insurance

### Community

• Community Overview
• Grant Program
• Events
• Become an Advocate
• Code of Conduct

### Resources

• Whitepaper
• Blog
• Economics
• Staking
• Rewards
• FAQs
• Education Hub
• What Is DeFi?
• What Is an Oracle?
• What Is a Smart Contract?
• What Is an NFT?
• What Is Web3?

### Chainlink

• Ecosystem
• Data Providers
• Press
• Team
• Circulating Supply
• CareersWE ARE HIRING!
• Brand Assets
• Chainlink Badging

### Contact

• Talk to an expert
• Security
• Support
• Custom Chainlinks
• Press inquiries
• Legal Support
• Legal

### Social

• X
• LinkedIn
• YouTube
• Instagram
• TikTok
• Discord
• Telegram
• Reddit
• Facebook
• WeChat

[Home](https://chain.link/)Chainlink®© 2024 Chainlink FoundationenZH[Privacy Policy](https://chain.link/privacy-policy)[Terms of Service](https://chain.link/terms)- - Google Tag Manager (noscript) --- - End Google Tag Manager (noscript) --[Image: Chainlink Labs logo]SmartCon is LIVE right now. Discover 200+ leading DeFi, NFT, and blockchain projects.
[Sign up today](https://hopin.com/events/smart-contract-summit-1?ref=99e0a4e499f0)[Get your ticket to the web3 event of the yearGet tickets](https://smartcon.chain.link/)[New reportWhy On-Chain Finance Is InevitableRead now](https://blog.chain.link/why-on-chain-finance-is-inevitable)[Image: Chainlink Labs logo]Chainlink Labs is hiring. Come join an industry-leading team.[See current openings](https://www.chainlinklabs.com/jobs?utm_source=chainlink&utm_medium=side-banner&utm_campaign=careers).video-modal-container iframe {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
}/* Tabs Active styles */
.dev-tab.dev-tab-active .dev-tab-icon {
  filter: brightness(0%);
}

.dev-tab.dev-tab-active:hover .dev-tab-icon {
  filter: brightness(0%);
}

.dev-tab:hover .dev-tab-icon {
  filter: brightness(200%);
}

.dev-tab-pane-video-overlay:hover .dev-tab-pane-video-ic-play {
  opacity: 1;
}

/* Code Highlighter Scroll Bar */
/* width */
.code pre::-webkit-scrollbar, .code::-webkit-scrollbar {
  width: 18px;
  height: 18px;
  background: #0E1C2B;
}

/* Track */
.code pre::-webkit-scrollbar-track, .code::-webkit-scrollbar-track {
  background: #0E1C2B;
  border-radius: 9px;
  
}

/* Handle */
.code pre::-webkit-scrollbar-thumb, .code::-webkit-scrollbar-thumb {
  background: rgba(255, 255, 255, 0.2);
  border-radius: 9px;
  border: 6px solid;
  border-color: #0E1C2B;
}

/* Code Highlighter */
pre code.hljs {
  display: block;
  overflow-x: auto;
  padding: 1em;
  padding-left: 24px;
  padding-right: 32px;
  padding-top: 0px;
  font-size: 15px;
}

.code pre {
  margin: 0;
}document.addEventListener("DOMContentLoaded", function () {
    if (/(Mac|iPhone|iPod|iPad)/i.test(navigator.platform)) {
      const macElements = document.querySelectorAll('.show-mac');
      const otherElements = document.querySelectorAll('.show-other-os');

      macElements.forEach(macElement => {
          macElement.style.display = 'inline';
      });

      otherElements.forEach(otherElement => {
          otherElement.style.display = 'none';
      });
  }
});document.addEventListener("DOMContentLoaded", function() {
    if (window.innerWidth < 992) {

    let accordionItems = document.querySelectorAll('.mega-menu-card:not(.mega-menu-card--no-accordeon)');
    let transitionDuration = '0.3s';
    let transitionTiming = 'ease';
    
    accordionItems.forEach(function(item) {
        let content = item.querySelector('.mega-menu-card__content');
        let caret = item.querySelector('.mega-menu-card__caret-vert');
        content.style.transition = 'height ' + transitionDuration + ' ' + transitionTiming;
        caret.style.transition = 'transform ' + transitionDuration + ' ' + transitionTiming;

        item.addEventListener('click', function() {
            let isVisible = content.offsetHeight > 0;

            accordionItems.forEach(function(otherItem) {
                let otherContent = otherItem.querySelector('.mega-menu-card__content');
                let otherCaret = otherItem.querySelector('.mega-menu-card__caret-vert');

                if (otherItem !== item) {
                    otherContent.style.height = '0';
                    otherCaret.style.transform = 'rotate(0deg)';
                }
            });

            content.style.height = isVisible ? '0' : content.scrollHeight + 'px';
            caret.style.transform = isVisible ? 'rotate(0deg)' : 'rotate(90deg)';
        });
    });
    }
});document.addEventListener("DOMContentLoaded", function() {
    if (window.innerWidth < 992) {
      var source = document.getElementById('res-link-source');
      var target = document.getElementById('res-link-target');
      while (source.childNodes.length > 0) {
        target.appendChild(source.childNodes[0]);
      }
    }
});document.addEventListener('DOMContentLoaded', function() {
    if (window.innerWidth < 992) {
      let isBodyScrollDisabled = false;

      // Utility function to toggle body scroll
      function toggleBodyScroll() {
          document.body.style.overflow = isBodyScrollDisabled ? '' : 'hidden';
          isBodyScrollDisabled = !isBodyScrollDisabled;
      }

      // Event listener for .dev-nav__menu-btn
      document.querySelector('.dev-nav__menu-btn').addEventListener('click', toggleBodyScroll);

      // Event listener for .dev-nav__search-wrap
      document.querySelector('.dev-nav__search-wrap').addEventListener('click', function() {
          if (isBodyScrollDisabled) {
              toggleBodyScroll(); // This will re-enable body scroll
          }
      });
    }
});document.addEventListener("DOMContentLoaded", function() {
    // First set of elements
    const closeBtn1 = document.querySelector("[mega-dd='close']");
    const openBtn1 = document.querySelector("[mega-dd='open']");
    const menuWrapper1 = document.querySelector("[mega-dd='wrapper']");
    
    // Second set of elements
    const closeBtn2 = document.querySelector("[mega-dd='close-2']");
    const openBtn2 = document.querySelector("[mega-dd='open-2']");
    const menuWrapper2 = document.querySelector("[mega-dd='wrapper-2']");
    
    const devNavCenter = document.querySelector('.dev-nav__center');
    
    function handleMenuActions(closeBtn, openBtn, menuWrapper) {
        if (window.innerWidth < 992) {
            closeBtn.addEventListener('click', function(event) {
                event.stopPropagation(); // Prevent the click event from bubbling up
                menuWrapper.style.display = 'none';
                devNavCenter.style.zIndex = '10';
            });

            openBtn.addEventListener('click', function() {
                menuWrapper.style.display = 'flex';
                devNavCenter.style.zIndex = '50';
            });
        }
        
        openBtn.addEventListener('click', function() {
            const navMenuOpenElement = document.querySelector('.w-nav-overlay [data-nav-menu-open]');
            if (navMenuOpenElement) {
                navMenuOpenElement.style.top = '0px';
            }
        });

        closeBtn.addEventListener('click', function() {
            document.querySelector('.w-nav-overlay [data-nav-menu-open]').style.top = '64px';
        });
    }
    
    handleMenuActions(closeBtn1, openBtn1, menuWrapper1);
    handleMenuActions(closeBtn2, openBtn2, menuWrapper2);
});document.addEventListener('DOMContentLoaded', function() {
    if (window.innerWidth <= 991) {
        var popularResCols = document.querySelectorAll('.popular-res__col');
        
        popularResCols.forEach(function(popularResCol) {
            var topElement = popularResCol.querySelector('.popular-res__top');
            
            if (topElement) {
                topElement.addEventListener('click', function() {
                    // Check if the parent has the 'popular-res__col--active' class
                    if (popularResCol.classList.contains('popular-res__col--active')) {
                        // Remove 'popular-res__col--active' class from the parent
                        popularResCol.classList.remove('popular-res__col--active');
                    } else {
                        // Remove 'popular-res__col--active' class from all elements
                        popularResCols.forEach(function(col) {
                            col.classList.remove('popular-res__col--active');
                        });
                        // Add 'popular-res__col--active' class to the parent
                        popularResCol.classList.add('popular-res__col--active');
                    }
                });
            }
        });
    }
});Open video in modal
1. Trcak the URL if it has youtube or youtu
2. Extract the youtub video ID and put it in the youtube video API code as videoId parametr
3. On user click on any card-base Run the YouTube Player
4. Emulate click on trigger that opens Video Modal (The interaction is Native Webflow)
5. Autoplay the Video when the player is ready
6. Track user Click on Video modal elemetns that also trigger close modal interaction video-modal-overlay and video-modal-close// Declare global variables to store the YouTube player and videoId
var player;
var videoId;

// Function to extract the video ID from a YouTube URL
function getYouTubeVideoId(url) {
  var videoId = '';
  var match = /(?:youtube\.com\/(?:[^/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?/\s]{11})/i.exec(url);
  if (match && match[1]) {
    videoId = match[1];
  }
  return videoId;
}

// Function to create a new YouTube player
function createYouTubePlayer(videoId) {
  console.log('Creating YouTube player with video ID:', videoId);
  if (player) {
    // Destroy the existing player if it exists
    player.destroy();
  }
  player = new YT.Player('ytb-player', {
    height: '390',
    width: '640',
    videoId: videoId, // Set the video ID
    playerVars: {
      'autoplay': 1, // Enable autoplay
      'playsinline': 1
    },
    events: {
      'onReady': onPlayerReady,
      'onStateChange': onPlayerStateChange
    }
  });
}

// Function to handle when the YouTube player is ready
function onPlayerReady(event) {
  console.log('YouTube player is ready.');
  // Set the videoId variable to the current video's ID
  videoId = event.target.getVideoData().video_id;
  // You can perform any actions you want here when the player is ready.
}

// Function to handle when the YouTube player's state changes
function onPlayerStateChange(event) {
  console.log('YouTube player state has changed.');
  // Handle player state changes here.
}

// Function to initialize the YouTube API
function loadYouTubeAPI() {
  console.log('Loading YouTube API.');
  YT = undefined;
  // This code loads the IFrame Player API code asynchronously.
  var tag = document.createElement('script');
  //tag.src = "https://www.youtube.com/iframe_api?origin=https://testflow-q32023-656b76d57aa7a113f66ed98.webflow.io/";
  //tag.src = "https://www.youtube.com/iframe_api?origin=*";
  tag.src = "https://www.youtube.com/player_api";
  var firstScriptTag = document.getElementsByTagName('script')[0];
  firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
}

// Function to emulate a click on the element with class "video-modal-trigger"
function emulateClickOnModalTrigger() {
  console.log('Emulating click on element with class "video-modal-trigger".');
  var modalTrigger = document.querySelector('.video-modal-trigger');
  modalTrigger.click();
}

// Function to handle card clicks
function handleCardClick(event) {
  var card = event.target.closest('.card-base'); // Find the closest card-base element
  if (!card) return; // If not a card, do nothing
  var href = card.getAttribute('href');
  console.log('Clicked on card with href:', href);
  if (href.includes('youtube') || href.includes('youtu.be')) {
    videoId = getYouTubeVideoId(href);
    if (videoId) {
      console.log('Video ID extracted:', videoId);
      createYouTubePlayer(videoId);
      event.preventDefault(); // Prevent the default link behavior
      emulateClickOnModalTrigger(); // Emulate click on modal trigger
    }
  }
}

// Function to stop the video and destroy the player
function stopVideoAndDestroyPlayer() {
  console.log('Stopping the video and destroying the player.');
  if (player) {
    player.stopVideo();
    player.destroy();
  }
}

// Function to add click event listeners to elements with class "card-base" and dynamically loaded ones
function addClickListenersToCards() {
  console.log('Adding click listeners to elements with class "card-base".');
  document.addEventListener('click', function(event) {
    var card = event.target.closest('.card-base');
    if (card) {
      handleCardClick(event);
    }
  });
}

// Function to add click event listeners to close elements
function addCloseListeners() {
  console.log('Adding click listeners to elements with class "video-modal-overlay" and "video-modal-close".');
  var modalOverlay = document.querySelector('.video-modal-overlay');
  var modalClose = document.querySelector('.video-modal-close');
  modalOverlay.addEventListener('click', function() {
    console.log('Modal overlay clicked.');
    stopVideoAndDestroyPlayer();
  });
  modalClose.addEventListener('click', function() {
    console.log('Close button clicked.');
    stopVideoAndDestroyPlayer();
  });
}

let tries = 0;
const maxTries = 20;
// Make sure the YT api is fully loaded
function retryAndLoad() {

	if(tries >= maxTries) return;

	if(typeof YT === "undefined") {
		console.log("YT not loaded, retrying in 200ms");
		setTimeout( retryAndLoad, 200);
		tries++;
  } else {
    addClickListenersToCards(); // Listen for card clicks
    addCloseListeners(); // Listen for modal close events
  }
}
loadYouTubeAPI();
retryAndLoad();Custom Tabsdocument.addEventListener('DOMContentLoaded', function() {
  // ADD ACTIVE CLASS TO CUSTOM TABS

  // Get all elements with the class "dev-tab"
  const tabs = document.querySelectorAll(".dev-tab");

  // Add click event listener to each tab
  tabs.forEach(tab => {
    tab.addEventListener("click", () => {
      // Remove "dev-tab-active" class from all tabs
      tabs.forEach(otherTab => {
        otherTab.classList.remove("dev-tab-active");
      });

      // Add "dev-tab-active" class to the clicked tab
      tab.classList.add("dev-tab-active");
    });
  });

  // CUSTOM TABS INTERACT WITH NATIVE TABS

  // Find all elements with attribute "tab-custom"
  const customTabElements = document.querySelectorAll('[tab-custom]');

  // Create a mapping of custom tab values to their corresponding native tab elements
  const tabMapping = {};

  // Populate the mapping with values and corresponding native tab elements
  customTabElements.forEach(customTabElement => {
    const customValue = customTabElement.getAttribute('tab-custom');
    const nativeTabElement = document.querySelector(`[tab-native="${customValue}"]`);
    if (nativeTabElement) {
      tabMapping[customValue] = nativeTabElement;
    }

    // Attach a click event listener to each custom tab element
    customTabElement.addEventListener("click", () => {
      if (tabMapping[customValue]) {
        tabMapping[customValue].click();
      } else {
        console.log(`Native element for ${customValue} not found.`);
      }
    });
  });
});Hide events section if there are no eventsdocument.addEventListener("DOMContentLoaded", function () {
    const upEventsRight = document.querySelector(".up-events__right");
    if (upEventsRight && upEventsRight.querySelector(".w-dyn-empty")) {
        const eventsElement = document.querySelector("#events");
        if (eventsElement) {
            eventsElement.style.display = "none";
        }
    }
});Main nav show/hide overlay 
<script>
        window.onload = function() {
            var overlay = document.querySelector('.res-nav-overlay');
            
            window.addEventListener('scroll', function() {
                var scrollPosition = window.scrollY;

                if (scrollPosition >= 12) {
                    overlay.style.opacity = '0.8';
                } else {
                    overlay.style.opacity = '0';
                }
            });
        }
</script>function loadJS(FILE_URL, callback, type = "text/javascript") {
  let scriptEle = document.createElement("script");
  const urlWithAppendedDate = `${FILE_URL}?v=${Date.now()}`;
  scriptEle.setAttribute("src", urlWithAppendedDate);
  scriptEle.setAttribute("type", type);
  scriptEle.setAttribute("defer", true);

  document.body.appendChild(scriptEle);

  // success event 
  scriptEle.addEventListener("load", (callback) => {
    console.log("File loaded");
    callback();
  });
   // error event
  scriptEle.addEventListener("error", (ev) => {
    console.log("Error on loading file", ev);
  });
}
function loadCSS(FILE_URL) {
  let scriptEle = document.createElement("link");
  const urlWithAppendedDate = `${FILE_URL}?v=${Date.now()}`;
  scriptEle.setAttribute("href", urlWithAppendedDate);
  scriptEle.setAttribute("rel", "stylesheet");
  scriptEle.setAttribute("type", "text/css");

  document.body.appendChild(scriptEle);

  // success event 
  scriptEle.addEventListener("load", () => {
    console.log("File loaded")
  });
   // error event
  scriptEle.addEventListener("error", (ev) => {
    console.log("Error on loading file", ev);
  });
}Search dialog from external packageRollback plan: Please replace the content of Href with the following: https://cdn.jsdelivr.net/npm/chainlink-algolia-search@0.10.1/dist/index.cssvar currentPageURL=document.location.href,cdomain="chain.link",now=new Date,time=now.getTime(),expireTime=time+15552E6;now.setTime(expireTime);currentPageURL.includes("utm_medium")&&(document.cookie="__wf_campaign_url\x3d"+encodeURIComponent(currentPageURL)+";expires\x3d"+now.toUTCString()+";path\x3d/;domain\x3d"+cdomain);(function(){function c(){var a=document.querySelector('input[class*\x3d"aiDrawerInput"]');a&&!a._chatListenerAttached&&(a._chatListenerAttached=!0,a.addEventListener("keydown",function(b){b=b||window.event;b.key!=="Enter"&&b.keyCode!==13||a.value.trim()===""||(window.dataLayer=window.dataLayer||[],window.dataLayer.push({event:"user_ai_query",user_ai_query:a.value.trim()}))}))}var d=new MutationObserver(function(a){(a=document.querySelector('input[class*\x3d"aiDrawerInput"]'))&&c()});d.observe(document.body,
{childList:!0,subtree:!0});c()})();window.process = window.process ||{};
  process.env = window.process.env || {};
  process.env.NODE_ENV = "production";Rollback plan: Please replace the content of the import with the following: https://cdn.jsdelivr.net/npm/chainlink-algolia-search@0.10.1/dist/webflow-import.mjsimport { webflowComponentImport } from 'https://cdn.jsdelivr.net/npm/@chainlink/cl-search-frontend@0.11.4/dist/webflow-import.mjs';
  webflowComponentImport( {
	elementId:"search-container",
    algoliaAppId: "K1NK1TQHV9",
    algoliaPublicApiKey: "6499ecf5d48e511595fd0f88f1c2c0fa",
    popularCards:[
      {
          url: "https://docs.chain.link/",
          imgSrc: "https://cdn.prod.website-files.com/64cc2c23d8dbd707cdb556d8/684b2a334369d2fb64c04591_Docs.svg",
          label: "Docs",
      },
      { 
          url: "https://dev.chain.link/demos",
          imgSrc: "https://cdn.prod.website-files.com/64cc2c23d8dbd707cdb556d8/684b2a33b0dd30e514591610_Demos.svg",
          label: "Demos"
      }
    ]});END:Search dialog from external packageStart of HubSpot Embed CodeEnd of HubSpot Embed CodeStart of External scriptimport { manageBanner } from 'https://thisdot.github.io/chainlink-webflow-cms-api/webflow-script/banner.js';
  manageBanner({
    bannerSelector: ".header-banner",
    bannerDescriptionSelector: '.header-banner-description',
    closeButtonSelector: ".banner-close",
  });End of External scriptAsk AI

================================================================================

# Getting Started with Any API

Source: https://docs.chain.link/any-api/getting-started
Extraction Method: playwright
Components: code_block(3)

# Getting Started with Any API
[Image: danger]Use Chainlink Functions

The Any API docs remain as a public historical reference for node operators. Please use Chainlink Functions instead.

Chainlink Functions provides your smart contracts access to trust-minimized compute infrastructure, allowing you to fetch data from APIs and perform custom computation. Read the Chainlink Functions
documentation to learn more.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }In this guide, you will learn how to request data from a public API in a smart contract. This includes understanding what Tasks and External adapters are and how Oracle Jobs use them. You will also learn how to find the Oracle Jobs and Tasks for your contract and how to request data from an Oracle Job.

## How does the request and receive cycle work for API calls?
The request and receive cycle describes how a smart contract requests data from an oracle and receives the response in a separate transaction. If you need a refresher, check out the Basic Request Model.

For contracts that use Chainlink VRF, you request randomness from a VRF oracle and then await the response. The fulfillment function is already given to us from the VRFConsumerBase contract, so oracles already know where to send the response to. However, with API calls, the contract itself defines which function it wants to receive the response to.

Before creating any code, you should understand how Oracle jobs can get data onchain.

## What are jobs?
Chainlink nodes require Jobs to do anything useful. In the case of a Request and Receive job, the Direct Request job monitors the blockchain for a request from a smart contract. Once it catches a request, it runs the tasks (both core and external adapters) that the job is configured to run and eventually returns the response to the requesting contract.

## What are tasks?
Each oracle job has a configured set of tasks it must complete when it is run. These tasks are split into two subcategories:

• Tasks - These are tasks that come built-in to each node. (examples: http, ethabidecode, etc).
• External Adapters - These are custom adapters built by node operators and community members, which perform specific tasks like calling a particular endpoint with a specific set of parameters (like authentication secrets that shouldn't be publicly visible).

### Tasks
If a job needs to make a GET request to an API, find a specific unsigned integer field in a JSON response, then submit that back to the requesting contract, it would need a job containing the following Tasks:

• HTTP calls the API. the method must be set to GET.
• JSON Parse parses the JSON and extracts a value at a given keypath.
• Multiply multiplies the input by a multiplier. Used to remove the decimals.
• ETH ABI Encode converts the data to a bytes payload according to ETH ABI encoding.
• ETH Tx submits the transaction to the chain, completing the cycle.

The job specs example can be found here.
Let's walk through a real example, where you will retrieve 24 volumes of the ETH/USD pair from the cryptocompare API.

1. HTTP calls the API and returns the body of an HTTP GET result for ETH/USD pair. Example:

[Image: copy to clipboard]
```json
{"RAW":
  {"ETH":
    {"USD":
      {
        ...,
        "VOLUMEDAYTO":953806939.7194247,
        "VOLUME24HOUR":703946.0675653099,
        "VOLUME24HOURTO":1265826345.488568
        ...,
      }
    }
  }
}
```

1. JSON Parse walks a specified path ("RAW,ETH,USD,VOLUME24HOUR") and returns the value found at that result. Example: 703946.0675653099
2. Multiply parses the input into a float and multiplies it by the 10^18. Example: 703946067565309900000000
3. ETH ABI Encode formats the input into an integer and then converts it into Solidity's uint256 format. Example: 0xc618a1e4
4. ETH Tx takes the given input, places it into the data field of the transaction, signs a transaction, and broadcasts it to the network. Example: transaction result

Note: Some tasks accept parameters to be passed to them to inform them how to run. Example: JSON Parse accepts a path parameter which informs the task where to find the data in the JSON object.

Let's see what this looks like in a contract:

### Contract example
[Image: copy to clipboard]
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import {Chainlink, ChainlinkClient} from "@chainlink/contracts/src/v0.8/operatorforwarder/ChainlinkClient.sol";
import {ConfirmedOwner} from "@chainlink/contracts/src/v0.8/shared/access/ConfirmedOwner.sol";
import {LinkTokenInterface} from "@chainlink/contracts/src/v0.8/shared/interfaces/LinkTokenInterface.sol";

/**
 * Request testnet LINK and ETH here: https://faucets.chain.link/
 * Find information on LINK Token Contracts and get the latest ETH and LINK faucets here: https://docs.chain.link/docs/link-token-contracts/
 */

/**
 * THIS IS AN EXAMPLE CONTRACT WHICH USES HARDCODED VALUES FOR CLARITY.
 * THIS EXAMPLE USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

contract APIConsumer is ChainlinkClient, ConfirmedOwner {
    using Chainlink for Chainlink.Request;

    uint256 public volume;
    bytes32 private jobId;
    uint256 private fee;

    event RequestVolume(bytes32 indexed requestId, uint256 volume);

    /**
     * @notice Initialize the link token and target oracle
     *
     * Sepolia Testnet details:
     * Link Token: 0x779877A7B0D9E8603169DdbD7836e478b4624789
     * Oracle: 0x6090149792dAAeE9D1D568c9f9a6F6B46AA29eFD (Chainlink DevRel)
     * jobId: ca98366cc7314957b8c012c72f05aeeb
     *
     */
    constructor() ConfirmedOwner(msg.sender) {
        _setChainlinkToken(0x779877A7B0D9E8603169DdbD7836e478b4624789);
        _setChainlinkOracle(0x6090149792dAAeE9D1D568c9f9a6F6B46AA29eFD);
        jobId = "ca98366cc7314957b8c012c72f05aeeb";
        fee = (1 * LINK_DIVISIBILITY) / 10; // 0,1 * 10**18 (Varies by network and job)
    }

    /**
     * Create a Chainlink request to retrieve API response, find the target
     * data, then multiply by 1000000000000000000 (to remove decimal places from data).
     */
    function requestVolumeData() public returns (bytes32 requestId) {
        Chainlink.Request memory req = _buildChainlinkRequest(
            jobId,
            address(this),
            this.fulfill.selector
        );

        // Set the URL to perform the GET request on
        req._add(
            "get",
            "https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD"
        );

        // Set the path to find the desired data in the API response, where the response format is:
        // {"RAW":
        //   {"ETH":
        //    {"USD":
        //     {
        //      "VOLUME24HOUR": xxx.xxx,
        //     }
        //    }
        //   }
        //  }
        // request.add("path", "RAW.ETH.USD.VOLUME24HOUR"); // Chainlink nodes prior to 1.0.0 support this format
        req._add("path", "RAW,ETH,USD,VOLUME24HOUR"); // Chainlink nodes 1.0.0 and later support this format

        // Multiply the result by 1000000000000000000 to remove decimals
        int256 timesAmount = 10 ** 18;
        req._addInt("times", timesAmount);

        // Sends the request
        return _sendChainlinkRequest(req, fee);
    }

    /**
     * Receive the response in the form of uint256
     */
    function fulfill(
        bytes32 _requestId,
        uint256 _volume
    ) public recordChainlinkFulfillment(_requestId) {
        emit RequestVolume(_requestId, _volume);
        volume = _volume;
    }

    /**
     * Allow withdraw of Link tokens from the contract
     */
    function withdrawLink() public onlyOwner {
        LinkTokenInterface link = LinkTokenInterface(_chainlinkTokenAddress());
        require(
            link.transfer(msg.sender, link.balanceOf(address(this))),
            "Unable to transfer"
        );
    }
}
```

[Open in Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/APIRequests/APIConsumer.sol&autoCompile=true)[What is Remix?](/getting-started/conceptual-overview#what-is-remix)Here is a breakdown of each component of this contract:

1. Constructor: This sets up the contract with the Oracle address, Job ID, and LINK fee that the oracle charges for the job.
2. requestVolumeData functions: This builds and sends a request - which includes the fulfillment functions selector - to the oracle. Notice how it adds the get, path and times parameters. These are read by the Tasks in the job to perform correctly. get is used by HTTP, path is used by JSON Parse and times is used by Multiply.
3. fulfill function: This is where the result is sent upon the Oracle Job's completion.

Note: The calling contract should own enough LINK to pay the fee, which by default is 0.1 LINK. You can use this tutorial to learn how to fund your contract.

This is an example of a basic HTTP GET request. However, it requires defining the API URL directly in the smart contract. This can, in fact, be extracted and configured on the Job level inside the Oracle node. You can follow the APIConsumer tutorial here.

### External adapters
If all the parameters are defined within the Oracle job, the only things a smart contract needs to define to consume are:

• JobId
• Oracle address
• LINK fee
• Fulfillment function

This will make your smart contract much more succinct. The requestVolumeData function from the code example above would look more like this:

[Image: copy to clipboard]
```solidity
function requestVolumeData() public returns (bytes32 requestId) {
    Chainlink.Request memory req = _buildChainlinkRequest(jobId, address(this), this.fulfill.selector);

    // Extra parameters don't need to be defined here because they are already defined in the job

    return _sendChainlinkRequest(req, fee);
}
```

You can follow a full Existing Job Tutorial here.
More on External Adapters can be found here.

## Further reading
To learn more about connecting smart contracts to external APIs, read our blog posts:

• Connect a Smart Contract to the Twitter API
• Connect a Tesla Vehicle API to a Smart Contract
• OAuth and API Authentication in Smart Contracts

================================================================================

# Chainlink Any API Documentation

Source: https://docs.chain.link/any-api/introduction
Extraction Method: playwright
Components: table(1)

# Chainlink Any API Documentation
[Image: danger]Use Chainlink Functions

The Any API docs remain as a public historical reference for node operators. Please use Chainlink Functions instead.

Chainlink Functions provides your smart contracts access to trust-minimized compute infrastructure, allowing you to fetch data from APIs and perform custom computation. Read the Chainlink Functions
documentation to learn more.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }Connecting to any API with Chainlink enables your contracts to access to any external data source through our decentralized oracle network. We understand making smart contracts compatible with offchain data adds to the complexity of building smart contracts. We created a framework with minimal requirements, yet unbounded flexibility, so developers can focus more on the functionality of smart contracts rather than what feeds them. Chainlink's decentralized oracle network provides smart contracts with the ability to push and pull data, facilitating the interoperability between onchain and offchain applications.

Whether your contract requires sports results, the latest weather, or any other publicly available data, the Chainlink contract library provides the tools required for your contract to consume it.

[Image: note]Prerequisites

You should be familiar with the Chainlink Basic Request Model. If
you are new to developing smart contracts on Ethereum, see the Getting Started
guide to learn the basics.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }[Image: note]Note on Price Feed Data

If your smart contracts need access to price feed data, try using Chainlink Data Feeds.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
### Requesting offchain data
Outlined below are multiple ways developers can connect smart contracts to offchain data feeds. Click a request type to learn more about it:

Request Type | Description
--- | ---
HTTP GET Single Word Response | This guide explains how to make an HTTP GET request and parse the json response to retrieve the value of one single attribute.
HTTP GET Multi-Variable Responses | This guide explains how to make an HTTP GET request and parse the json response to retrieve the values of multiple attributes.
HTTP GET Element in Array Response | This guide explains how to make an HTTP GET request that returns a json array and parse it to retrieve the target element's value.
HTTP GET Large Responses | This guide explains how to make an HTTP Get request that returns a json containing an arbitrary-length raw byte data and parse it to return the data as bytes data type.
Existing Job Request | This guide explains how to call a job that leverages External adapters and returns the relevant data to the smart contract. This allows building succinct smart contracts that do not need to comprehend the URL or the response format of the target API.

### Building external adapters
To learn more about building external adapters and adding them to nodes, refer to the External Adapters documentation.

To understand different use cases for using any API, refer to Other Tutorials.

================================================================================

# ChainlinkClient API Reference

Source: https://docs.chain.link/any-api/api-reference
Extraction Method: playwright
Components: code_block(48), table(7)

# ChainlinkClient API Reference
[Image: danger]Use Chainlink Functions

The Any API docs remain as a public historical reference for node operators. Please use Chainlink Functions instead.

Chainlink Functions provides your smart contracts access to trust-minimized compute infrastructure, allowing you to fetch data from APIs and perform custom computation. Read the Chainlink Functions
documentation to learn more.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }[Image: note]API reference for ChainlinkClient

ChainlinkClient contracts
can communicate with Operator contracts.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
## Index

### Methods

Name | Description
--- | ---
setChainlinkOracle | Sets the stored address for the oracle contract
setChainlinkToken | Sets the stored address for the LINK token
buildChainlinkRequest | Instantiates a Request object with the required parameters
buildOperatorRequest | Instantiates a Request object with the required parameters. Note the oracle must be an Operator contract
sendChainlinkRequest | Sends the request payload to the stored address stored as chainlinkOracleAddress
sendChainlinkRequestTo | Sends a request to the oracle address specified
sendOperatorRequest | Sends the request payload to the stored address stored as chainlinkOracleAddress. Note the oracle must be an Operator contract
sendOperatorRequestTo | Sends a request to the oracle address specified. Note the oracle must be an Operator contract
validateChainlinkCallback | Secures the fulfillment callback to make sure it is only called by permissioned senders
addChainlinkExternalRequest | Allows a Chainlinked contract to track unfulfilled requests that it hasn't created itself
cancelChainlinkRequest | Cancels Chainlink requests attempting to contact an unresponsive node
useChainlinkWithENS | Looks up the addresses of the LINK token and Oracle contract through ENS
updateChainlinkOracleWithENS | Updates the stored oracle address with the latest address resolved through ENS
chainlinkTokenAddress | Returns the stored address of the LINK token
chainlinkOracleAddress | Returns the stored address of the oracle contract

### Events

Name | Description
--- | ---
ChainlinkRequested | Emitted from a Chainlinked contract when a request is sent to an oracle
ChainlinkFulfilled | Emitted from a Chainlinked contract when a request is fulfilled by an oracle
ChainlinkCancelled | Emitted from a Chainlinked contract when a request is cancelled

### Modifiers

Name | Description
--- | ---
recordChainlinkFulfillment | Used on fulfillment callbacks to ensure that the caller and requestId are valid. This is the modifier equivalent of the method validateChainlinkCallback

### Constants

Name | Description
--- | ---
LINK_DIVISIBILITY | Helper uint256 to represent the divisibility of a LINK token. Equivalent to 10^18

### Structs

Name | Description
--- | ---
Chainlink.Request | All of the parameters that can be passed over in a Chainlink request

## Methods
Below you'll find each helper explained in greater detail alongside respective implementation examples to help you leverage these methods once you start building your own Chainlinked contract.

After the function signature and a short description, two code examples are provided, one focusing on the exact usage of the method and one where the helper is presented in the context of a full contract.

### setChainlinkOracle
[Image: copy to clipboard]
```solidity
function _setChainlinkOracle(
  address _oracle
)
```

Sets a private storage variable provided for convenience if your contract only needs to talk to one oracle and you do not want to specify it on every request. Once an oracle is set with setChainlinkOracle that is the address used with sendChainlinkRequest.

Retrieve the oracle address using chainlinkOracleAddress. These getters and setters are provided to enforce that changes to the oracle are explicitly made in the code.

[Image: copy to clipboard]
```solidity
constructor(address _oracle)
{
  _setChainlinkOracle(_oracle);
}
```

### setChainlinkToken
[Image: copy to clipboard]
```solidity
_setChainlinkToken(
  address _link
)
```

Sets the stored address for the LINK token which is used to send requests to Oracles. There are different token addresses on different network. See LINK Token Contracts for the address of the LINK token on the network you're deploying to.

[Image: copy to clipboard]
```solidity
constructor(address _link)
  public
{
  _setChainlinkToken(_link);
}
```

### buildChainlinkRequest
Use buildOperatorRequest function if the oracle is an Operator
contract.

[Image: copy to clipboard]
```solidity
function _buildChainlinkRequest(
    bytes32 _jobId,
    address _callbackAddress,
    bytes4 _callbackFunctionSignature
) returns (Chainlink.Request memory request)
```

Instantiates a Request from the Chainlink contract. A Request is a struct which contains the necessary parameters to be sent to the oracle contract. The buildChainlinkRequest function takes an ID, which can be a Job ID, a callback address to receive the resulting data, and a callback function signature to call on the callback address.

[Image: copy to clipboard]
```solidity
function requestPrice()
  public
{
  bytes32 jobId = "493610cff14346f786f88ed791ab7704";
  bytes4 selector = this.myCallback.selector;
  // build a request that calls the myCallback function defined
  //   below by specifying the address of this contract and the function
  //   selector of the myCallback
  Chainlink.Request memory request = _buildChainlinkRequest(
    jobId,
    address(this),
    selector);
}
```

### buildOperatorRequest
This function is similar to buildChainlinkRequestfunction. One major difference
is that buildOperatorRequest does not allow setting up the address of the callback. The callback address
is set to the address of the calling contract.

It is recommended to use buildOperatorRequest but make sure the oracle you are contacting is an Operator
contract.

[Image: copy to clipboard]
```solidity
function buildOperatorRequest(
    bytes32 _jobId,
    bytes4 _callbackFunctionSignature
) returns (Chainlink.Request memory request)
```

Instantiates a Request from the Chainlink contract. A Request is a struct that contains the necessary parameters to be sent to the oracle contract. The buildOperatorRequest function takes an ID, which can be a Job ID, and a callback function signature to call on the calling contract address.

[Image: copy to clipboard]
```solidity
function requestPrice()
  public
{
  bytes32 jobId = "493610cff14346f786f88ed791ab7704";
  bytes4 selector = this.myCallback.selector;
  // build a request that calls the myCallback function defined
  //   below by specifying the function selector of myCallback
  Chainlink.Request memory request = buildOperatorRequest(
    jobId,
    selector);
}
```

### sendChainlinkRequest
Use sendOperatorRequest function if the oracle is an Operator
contract.

[Image: copy to clipboard]
```solidity
function _sendChainlinkRequest(
    Chainlink.Request memory _req,
    uint256 _payment
) returns (bytes32 requestId)
```

Sends the request payload to the stored oracle address. It takes a Chainlink.Request and the amount of LINK to send amount as parameters. The request is serialized and calls oracleRequest on the address stored in chainlinkOracleAddress via the LINK token's transferAndCall method.

sendChainlinkRequest returns the ID of the request. If your application needs to, your contract can store that ID, but you don't need to. The ChainlinkClient helpers will store the ID under the hood, along with the oracle address, and use them when you call recordChainlinkFulfillment in your callback function to make sure only that the address you want can call your Chainlink callback function.

sendChainlinkRequest emits a ChainlinkRequested event containing the request ID, if you would like to use it in your Web3 application.

[Image: copy to clipboard]
```solidity
function requestPrice()
  public
{
  Chainlink.Request memory request = _buildChainlinkRequest(jobId, address(this), this.callback.selector);
  uint256 paymentAmount = 1 * LINK_DIVISIBILITY / 10; // Equivalent to 0.1 LINK

  // send the request that you just built
  _sendChainlinkRequest(request, paymentAmount);
}
```

### sendChainlinkRequestTo
Use sendOperatorRequestTo function if the oracle is an Operator
contract.

[Image: copy to clipboard]
```solidity
function _sendChainlinkRequestTo(
  address _oracle,
  Chainlink.Request memory _req,
  uint256 _payment
) returns (bytes32 requestId)
```

Similar to sendChainlinkRequest, sendChainlinkRequestTo sends a Request but allows the target oracle to be specified. It requires an address, a Request, and an amount, and returns the requestId. This allows a requesting contract to create and track requests sent to multiple oracle contract addresses.

sendChainlinkRequestTo emits a ChainlinkRequested event containing the request ID, if you would like to use it in your Web3 application.

[Image: copy to clipboard]
```solidity
function requestPriceFrom(address _oracle)
  public
{
  Chainlink.Request memory request = _buildChainlinkRequest(jobId, address(this), this.callback.callbackSelector);
  uint256 paymentAmount = 1 * LINK_DIVISIBILITY; // = 1 LINK

  // send the request that you just built to a specified oracle
  _sendChainlinkRequestTo(_oracle, request, paymentAmount);
}
```

### sendOperatorRequest
This function is similar to sendChainlinkRequestfunction.
It is recommended to use sendOperatorRequest but make sure the oracle you are contacting is an Operator
contract.

[Image: copy to clipboard]
```solidity
function sendOperatorRequest(
    Chainlink.Request memory _req,
    uint256 _payment
) returns (bytes32 requestId)
```

The sendOperatorRequest function sends the request payload to the stored oracle address. It takes a Chainlink.Request and the amount of LINK to send amount as parameters. The request is serialized and calls operatorRequest on the address stored in chainlinkOracleAddress using the LINK token's transferAndCall method.

sendOperatorRequest returns the ID of the request. Optionally, your contract can store the ID if your application needs it. The ChainlinkClient helpers store the ID and the oracle address and use them when you call recordChainlinkFulfillment in your callback function. This ensures that only the specified address can call your Chainlink callback function.

sendOperatorRequest emits a ChainlinkRequested event containing the request ID that you can use in your Web3 application.

[Image: copy to clipboard]
```solidity
function requestPrice()
  public
{
  Chainlink.Request memory request = buildOperatorRequest(jobId, this.callback.selector);
  uint256 paymentAmount = 1 * LINK_DIVISIBILITY / 10; // Equivalent to 0.1 LINK

  // send the request that you just built
  sendOperatorRequest(request, paymentAmount);
}
```

### sendOperatorRequestTo
This function is similar to sendChainlinkRequestTofunction.
It is recommended to use sendOperatorRequestTo, but make sure the oracle you are contacting is an Operator
contract.

[Image: copy to clipboard]
```solidity
function _sendChainlinkRequestTo(
  address _oracle,
  Chainlink.Request memory _req,
  uint256 _payment
) returns (bytes32 requestId)
```

Similar to sendOperatorRequest, sendOperatorRequestTo sends a Request but allows the target oracle to be specified. It requires an address, a Request, and an amount, and returns the requestId. This allows a requesting contract to create and track requests sent to multiple oracle contract addresses.

sendOperatorRequestTo emits a ChainlinkRequested event containing a request ID that you can use in your Web3 application.

[Image: copy to clipboard]
```solidity
function requestPriceFrom(address _oracle)
  public
{
  Chainlink.Request memory request = buildOperatorRequest(jobId, this.callback.callbackSelector);
  uint256 paymentAmount = 1 * LINK_DIVISIBILITY; // = 1 LINK

  // send the request that you just built to a specified oracle
  sendOperatorRequestTo(_oracle, request, paymentAmount);
}
```

### validateChainlinkCallback
[Image: copy to clipboard]
```solidity
function validateChainlinkCallback(
    bytes32 _requestId
)
```

Used on fulfillment callbacks to ensure that the caller and requestId are valid. They protect ChainlinkClient callbacks from being called by malicious callers. validateChainlinkCallback allows for a request to be called

This is the method equivalent of the modifier recordChainlinkFulfillment. Either validateChainlinkCallback or recordChainlinkFulfillment should be used on all fulfillment functions to ensure that the caller and requestId are valid. Use the modifier or the method, not both.

validateChainlinkCallback emits a ChainlinkFulfilled event.

[Image: copy to clipboard]
```solidity
function myCallback(bytes32 _requestId, uint256 _price)
  public
{
  validateChainlinkCallback(_requestId);
  currentPrice = _price;
}
```

[Image: caution]Do not call multiple times

Do not call validateChainlinkCallback multiple times. The nature of validating the callback is to ensure the response is only received once and not replayed. Calling a second time with the same method ID will trigger a revert. Similarly, your callback should validate using either validateChainlinkCallback or recordChainlinkFulfillment, not both.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
### addChainlinkExternalRequest
[Image: copy to clipboard]
```solidity
function addChainlinkExternalRequest(
  address _oracle,
  bytes32 _requestId
)
```

addChainlinkExternalRequest allows a Chainlink contract to track unfulfilled requests that it hasn't created itself. For example, contract A creates a request and sets the callback for contract B. Contract B needs to know about the request created by contract A so that it can validate the callback when it is executed.

[Image: copy to clipboard]
```solidity
function expectResponseFor(bytes32 _requestId)
  public
{
  addChainlinkExternalRequest(chainlinkOracleAddress(), _requestId);
}
```

[Image: caution]Be careful adding external requests

Being able to change a request means that you can change the data fed into a contract. Permissioning someone to make external requests can allow them to change the outcome of your contract. You should be sure to make sure that they are a trusted to do so. If they are not trusted to do so, you should put the request making logic onchain where it is auditable and tamperproof.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
### cancelChainlinkRequest
[Image: copy to clipboard]
```solidity
function _cancelChainlinkRequest(bytes32 _requestId,
    uint256 _payment,
    bytes4 _callbackFunc,
    uint256 _expiration
)
```

In case an oracle node does not respond, it may be necessary to retrieve the LINK used to pay for the unfulfilled request. The cancelChainlinkRequest will send the cancel request to the address used for the request, which transfers the amount of LINK back to the requesting contract, and delete it from the tracked requests.

The default expiration for a request is five minutes, after which it can be cancelled. The cancellation must be sent by the address which was specified as the callback location of the contract.

For the sake of efficient gas usage, only a hash of the request's parameters are stored onchain. In order to validate the terms of the request and that it can be calculated, the request parameters must be provided. Additionally, cancellation must be called by the address which the callback would otherwise have been called on.

cancelChainlinkRequest emits a ChainlinkCancelled event.

[Image: copy to clipboard]
```solidity
function cancelRequest(
    bytes32 _requestId,
    uint256 _payment,
    bytes4 _callbackFunc,
    uint256 _expiration
) public {
  _cancelChainlinkRequest(_requestId, _payment, _callbackFunc, _expiration);
}
```

### useChainlinkWithENS
[Image: copy to clipboard]
```solidity
function useChainlinkWithENS(
  address _ens,
  bytes32 _node
)
```

Allows a Chainlink contract to store the addresses of the LINK token and oracle contract addresses without supplying the addresses themselves. We use ENS where available to resolve these addresses. It requires the address of the ENS contract and the node (which is a hash) for the domain.

If your Oracle provider supports using ENS for rolling upgrades to their oracle contract, once you've pointed your Chainlinked contract to the ENS records then you can update the records using updateChainlinkOracleWithENS.

[Image: copy to clipboard]
```solidity
address constant ROPSTEN_ENS = 0x112234455C3a32FD11230C42E7Bccd4A84e02010;
bytes32 constant ROPSTEN_CHAINLINK_ENS = 0xead9c0180f6d685e43522fcfe277c2f0465fe930fb32b5b415826eacf9803727;

constructor(){
  useChainlinkWithENS(ROPSTEN_ENS, ROPSTEN_CHAINLINK_ENS);
}
```

[Image: caution]Updating oracle addresses

If an oracle provider supports listing their oracle on ENS, that provides the added security of being able to update any issues that may arise. The tradeoff here is that by using their ENS record, you are allowing whoever controls that record and the corresponding code it points to. If your contract does this, you must either audit the updated code and make sure it matches Operator.sol or trust whoever can update the records.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
### updateChainlinkOracleWithENS
[Image: copy to clipboard]
```solidity
function updateChainlinkOracleWithENS()
```

Updates the stored oracle contract address with the latest address resolved through the ENS contract. This requires the oracle provider to support listing their address on ENS.

This method only works after useChainlinkWithENS has been called on the contract.

[Image: copy to clipboard]
```solidity
function updateOracleAddressToLatest() public {
  updateChainlinkOracleWithENS();
}
```

[Image: caution]Updating oracle addresses

If an oracle provider supports listing their oracle on ENS, that provides the added security of being able to update any issues that may arise. The tradeoff here is that by using their ENS record, you are allowing whoever controls that record and the corresponding code it points to. If your contract does this, you must either audit the updated code and make sure it matches Operator.sol or trust whoever can update the records.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
### chainlinkTokenAddress
[Image: copy to clipboard]
```solidity
function _chainlinkTokenAddress() returns (address)
```

The chainlinkTokenAddress function is a helper used to return the stored address of the Chainlink token. This variable is protected and so only made available through getters and setters.

[Image: copy to clipboard]
```solidity
function withdrawLink() public {
  LinkTokenInterface link = LinkTokenInterface(_chainlinkTokenAddress());

  require(link.transfer(msg.sender, link.balanceOf(address(this))), "Unable to transfer");
}
```

### chainlinkOracleAddress
The chainlinkOracleAddress function is a helper used to return the stored address of the oracle contract.

[Image: copy to clipboard]
```solidity
function getOracle() public view returns (address) {
  return chainlinkOracleAddress();
}
```

## Events

### ChainlinkRequested
[Image: copy to clipboard]
```solidity
event ChainlinkRequested(
  bytes32 indexed id
)
```

Emitted when sendChainlinkRequest and sendChainlinkRequestTo are called. Includes the request ID as an event topic.

### ChainlinkFulfilled
[Image: copy to clipboard]
```solidity
event ChainlinkFulfilled(
  bytes32 indexed id
)
```

Emitted when validateChainlinkCallback or recordChainlinkFulfillment are called. Includes the request ID as an event topic.

### ChainlinkCancelled
[Image: copy to clipboard]
```solidity
event ChainlinkCancelled(
  bytes32 indexed id
)
```

Emitted when cancelChainlinkRequest is called. Includes the request ID as an event topic.

## Constants

### LINK_DIVISIBILITY
LINK_DIVISIBILITY is a uint256 constant to represent one whole unit of the LINK token (1000000000000000000). It can be used with another value to specify payment in an easy-to-read format, instead of hardcoding magic numbers.

[Image: copy to clipboard]
```solidity
uint256 constant private ORACLE_PAYMENT = 100 * LINK_DIVISIBILITY; // = 100 LINK
```

## Modifiers

### recordChainlinkFulfillment
recordChainlinkFulfillment is used on fulfillment callbacks to ensure that the caller and requestId are valid. This is the method equivalent of the method validateChainlinkCallback.

Either validateChainlinkCallback or recordChainlinkFulfillment should be used on all Chainlink callback functions to ensure that the sender and requestId are valid. They protect ChainlinkClient callbacks from being called by malicious callers. Do not call both of them, or your callback may revert before you can record the reported response.

[Image: copy to clipboard]
```solidity
function myCallback(bytes32 _requestId, uint256 _price)
  public
  recordChainlinkFulfillment(_requestId) // always validate callbacks
{
  currentPrice = _price;
}
```

## Chainlink.Request
[Image: copy to clipboard]
```solidity
library Chainlink {
  struct Request {
    bytes32 id;
    address callbackAddress;
    bytes4 callbackFunctionId;
    uint256 nonce;
    Buffer.buffer buf;
  }
}
```

The Chainlink Request struct encapsulates all of the fields needed for a Chainlink request and its corresponding response callback.

The Chainlink protocol aims to be flexible and not restrict application developers. The Solidity Chainlink Request model is a great example of that. It is exceptionally flexible, given the limitations of Solidity. The request can contain an arbitrary amount of keys and values to be passed offchain to the oracles for each request. It does so by converting the parameters into CBOR, and then storing them in a buffer. This allows for any number of parameters all of different types to be encoded onchain.

The request's ID is generated by hashing the sender's address and the request's nonce. This scheme ensures that only the requester can generate their request ID, and no other contract can trigger a response from an oracle with that ID. New requests whose IDs match an unfulfilled request ID will not be accepted by the oracle.

[Image: caution]Intended for memory

The Request object was intended to be stored in memory. If you have a reason to persist the struct in storage, it is recommended that you do so by copying each attribute over and explicitly copying the bytes in the buffer.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
### Attributes

Name | Description
--- | ---
id | Identifier for the request
callbackAddress | Address that the response will be sent to upon fulfillment
callbackFunctionId | Selector of the function on the callbackAddress that will be invoked with the response upon fulfillment
nonce | Used to generate the request ID
buf | Buffer that stores additional user defined parameters as CBOR

### Methods

Name | Description
--- | ---
add | Add a string value to the run request parameters
addBytes | Add a bytes value to the run request parameters
addInt | Add an integer value to the run request parameters
addUint | Add an unsigned integer to the run request parameters
addStringArray | Add an array of strings as a value in the run request parameters
setBuffer | Directly set the CBOR of the run request parameters

#### add
[Image: copy to clipboard]
```solidity
function add(
  Request memory self,
  string _key,
  string _value
)
```

Add a string value to the run request parameters. Commonly used for get with jobs using httpGet tasks.

[Image: copy to clipboard]
```solidity
function requestEthereumPrice()
  public
{
  Chainlink.Request memory req = _buildChainlinkRequest(jobId, this, this.fulfill.selector);

  req._add("get", "https://min-api.cryptocompare.com/data/price?fsym=ETH&tsyms=USD,EUR,JPY");

  _sendChainlinkRequest(req, 1 * LINK_DIVISIBILITY); // =1 LINK
}
```

#### addBytes
[Image: copy to clipboard]
```solidity
function addBytes(
  Request memory self,
  string _key,
  bytes _value
)
```

Add a CBOR bytes type value to the run request parameters.

[Image: copy to clipboard]
```solidity
function requestEmojiPopularity(bytes _unicode)
  public
{
  Chainlink.Request memory req = _buildChainlinkRequest(jobId, this, this.fulfill.selector);

  req.addBytes("emojiUnicode", _unicode);

  _sendChainlinkRequest(req, LINK_DIVISIBILITY * 1);
}
```

Note that this can also be used as a workaround to pass other data types like arrays or addresses. For instance, to add an address, one would first encode it using abi.encode then pass the result to addBytes:

[Image: copy to clipboard]
```solidity
Chainlink.Request memory req = _buildChainlinkRequest(jobId, this, this.fulfill.selector);

req.addBytes("address", abi.encode(msg.sender)); // msg.sender used in this example. Replace it with your address
```

#### addInt
[Image: copy to clipboard]
```solidity
function addInt(
  Request memory self,
  string _key,
  int256 _value
)
```

Add a CBOR signed integer type value to the run request parameters. Commonly used with the times parameter of any job using a multiply task.

[Image: copy to clipboard]
```solidity
function requestPrice()
  public
{
  Chainlink.Request memory req = _buildChainlinkRequest(jobId, this, this.fulfill.selector);

  req._addInt("times", 100);

  _sendChainlinkRequest(req, LINK_DIVISIBILITY * 1);
}
```

#### addUint
[Image: copy to clipboard]
```solidity
function addUint(
  Request memory self,
  string _key,
  uint256 _value
)
```

Add a CBOR unsigned integer type value to the run request parameters. Commonly used with the times parameter of any job using a multiply task.

[Image: copy to clipboard]
```solidity
function requestPrice()
  public
{
  Chainlink.Request memory req = _buildChainlinkRequest(jobId, this, this.fulfill.selector);

  req.addUint("times", 100);

  _sendChainlinkRequest(req, LINK_DIVISIBILITY * 1);
}
```

#### addStringArray
[Image: copy to clipboard]
```solidity
function addStringArray(
  Request memory self,
  string _key,
  string[] memory _values
)
```

Add a CBOR array of strings to the run request parameters. Commonly used with the path parameter for any job including a jsonParse task.

[Image: copy to clipboard]
```solidity
function requestPrice(string _currency)
  public
{
  Chainlink.Request memory req = _buildChainlinkRequest(JOB_ID, this, this.myCallback.selector);
  string[] memory path = new string[](2);
  path[0] = _currency;
  path[1] = "recent";

  // specify templated fields in a job specification
  req.addStringArray("path", path);

  _sendChainlinkRequest(req, PAYMENT);
}
```

#### setBuffer
[Image: copy to clipboard]
```solidity
function setBuffer(
  Request memory self,
  bytes _data
)
```

Set the CBOR payload directly on the request object, avoiding the cost of encoding the parameters in CBOR. This can be helpful when reading the bytes from storage or having them passed in from offchain where they were pre-encoded.

[Image: copy to clipboard]
```solidity
function requestPrice(bytes _cbor)
  public
{
  Chainlink.Request memory req = _buildChainlinkRequest(JOB_ID, this, this.myCallback.selector);

  req.setBuffer(_cbor);

  _sendChainlinkRequest(req, PAYMENT);
}
```

[Image: caution]Be careful setting the request buffer directly

Moving the CBOR encoding logic offchain can save some gas, but it also opens up the opportunity for people to encode parameters that not all parties agreed to. Be sure that whoever is permissioned to call setBuffer is trusted or auditable.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }

================================================================================

# Make a GET Request

Source: https://docs.chain.link/any-api/get-request/introduction
Extraction Method: playwright

# Make a GET Request
[Image: danger]Use Chainlink Functions

The Any API docs remain as a public historical reference for node operators. Please use Chainlink Functions instead.

Chainlink Functions provides your smart contracts access to trust-minimized compute infrastructure, allowing you to fetch data from APIs and perform custom computation. Read the Chainlink Functions
documentation to learn more.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }This series of guides explains how to make HTTP GET requests to external APIs from smart contracts, using Chainlink's Request & Receive Data cycle.

### Response Types
Make sure to choose an oracle job that supports the data type that your contract needs to consume. Multiple data types are available such as:

• uint256 - Unsigned integers
• int256 - Signed integers
• bool - True or False values
• string - String
• bytes32 - Strings and byte values. If you need to return a string, use bytes32. Here's one method of converting bytes32 to string. Currently, any return value must fit within 32 bytes. If the value is bigger than that, make multiple requests.
• bytes - Arbitrary-length raw byte data

## Setting the LINK token address, Oracle, and JobId
The setChainlinkToken function sets the LINK token address for the network you are deploying to. The setChainlinkOracle function sets a specific Chainlink oracle that a contract makes an API call from. The jobId refers to a specific job for that node to run.

Each job is unique and returns different types of data. For example, a job that returns a bytes32 variable from an API would have a different jobId than a job that retrieved the same data, but in the form of a uint256 variable.

Check the Find Existing Jobs page to learn how to find a job suitable to your use case.

## Examples

### Single Word Response
This guide explains how to make an HTTP GET request and parse the json response to retrieve the value of one single attribute.

### Multi-Variable Responses
This guide explains how to make an HTTP GET request and parse the json response to retrieve the values of multiple attributes.

### Fetch data from an Array
This guide explains how to make an HTTP GET request that returns a json array and parse it to retrieve the target element's value.

### Large Responses
This guide explains how to make an HTTP Get request that returns a json containing an arbitrary-length raw byte data and parse it to return the data as bytes data type.

### Make an Existing Job Request
This guide explains how to call a job that leverages External adapters and returns the relevant data to the smart contract. This allows building succinct smart contracts that do not need to comprehend the URL or the response format of the target API.

================================================================================

# Single Word Response

Source: https://docs.chain.link/any-api/get-request/examples/single-word-response
Extraction Method: playwright
Components: code_block(3)

# Single Word Response
[Image: danger]Use Chainlink Functions

The Any API docs remain as a public historical reference for node operators. Please use Chainlink Functions instead.

Chainlink Functions provides your smart contracts access to trust-minimized compute infrastructure, allowing you to fetch data from APIs and perform custom computation. Read the Chainlink Functions
documentation to learn more.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }This guide explains how to make an HTTP GET request to an external API from a smart contract using Chainlink's Request & Receive Data cycle and receive a single response.

[Image: note]Prerequisites

You should be familiar with the Chainlink Basic Request Model. If
you are new to developing smart contracts on Ethereum, see the Getting Started
guide to learn the basics.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
## Example
This example shows how to:

• Fetch a single word response in a single call.

The Cryptocompare GET /data/pricemultifull API returns the current trading info (price, vol, open, high, low) of any list of cryptocurrencies in any other currency that you need. To check the response, you can directly paste the following URL in your browser https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD or run this command in your terminal:

[Image: copy to clipboard]
```bash
curl -X 'GET' \
  'https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD' \
  -H 'accept: application/json'
```

The response should be similar to the following example:

[Image: copy to clipboard]
```json
{
  "RAW": {
    "ETH": {
      "USD": {
        "TYPE": "5",
        "MARKET": "CCCAGG",
        "FROMSYMBOL": "ETH",
        "TOSYMBOL": "USD",
        "FLAGS": "2049",
        "PRICE": 2867.04,
        "LASTUPDATE": 1650896942,
        "MEDIAN": 2866.2,
        "LASTVOLUME": 0.16533939,
        "LASTVOLUMETO": 474.375243849,
        "LASTTRADEID": "1072154517",
        "VOLUMEDAY": 195241.78281014622,
        "VOLUMEDAYTO": 556240560.4621655,
        "VOLUME24HOUR": 236248.94641103,
        ...
}
```

To consume an API with multiple responses, your contract must import ChainlinkClient. This contract exposes a struct called Chainlink.Request, which your contract should use to build the API request. The request should include the following parameters:

• Link token address
• Oracle address
• Job id
• Request fee
• Task parameters
• Callback function signature

[Image: caution]Note on Funding Contracts

Making a GET request will fail unless your deployed contract has enough LINK to pay for it. Learn how to Acquire testnet LINK and Fund your contract.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }Assume that a user wants to call the API above and retrieve only the 24h ETH trading volume from the response.

[Image: copy to clipboard]
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import {Chainlink, ChainlinkClient} from "@chainlink/contracts/src/v0.8/operatorforwarder/ChainlinkClient.sol";
import {ConfirmedOwner} from "@chainlink/contracts/src/v0.8/shared/access/ConfirmedOwner.sol";
import {LinkTokenInterface} from "@chainlink/contracts/src/v0.8/shared/interfaces/LinkTokenInterface.sol";

/**
 * Request testnet LINK and ETH here: https://faucets.chain.link/
 * Find information on LINK Token Contracts and get the latest ETH and LINK faucets here: https://docs.chain.link/docs/link-token-contracts/
 */

/**
 * THIS IS AN EXAMPLE CONTRACT WHICH USES HARDCODED VALUES FOR CLARITY.
 * THIS EXAMPLE USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

contract APIConsumer is ChainlinkClient, ConfirmedOwner {
    using Chainlink for Chainlink.Request;

    uint256 public volume;
    bytes32 private jobId;
    uint256 private fee;

    event RequestVolume(bytes32 indexed requestId, uint256 volume);

    /**
     * @notice Initialize the link token and target oracle
     *
     * Sepolia Testnet details:
     * Link Token: 0x779877A7B0D9E8603169DdbD7836e478b4624789
     * Oracle: 0x6090149792dAAeE9D1D568c9f9a6F6B46AA29eFD (Chainlink DevRel)
     * jobId: ca98366cc7314957b8c012c72f05aeeb
     *
     */
    constructor() ConfirmedOwner(msg.sender) {
        _setChainlinkToken(0x779877A7B0D9E8603169DdbD7836e478b4624789);
        _setChainlinkOracle(0x6090149792dAAeE9D1D568c9f9a6F6B46AA29eFD);
        jobId = "ca98366cc7314957b8c012c72f05aeeb";
        fee = (1 * LINK_DIVISIBILITY) / 10; // 0,1 * 10**18 (Varies by network and job)
    }

    /**
     * Create a Chainlink request to retrieve API response, find the target
     * data, then multiply by 1000000000000000000 (to remove decimal places from data).
     */
    function requestVolumeData() public returns (bytes32 requestId) {
        Chainlink.Request memory req = _buildChainlinkRequest(
            jobId,
            address(this),
            this.fulfill.selector
        );

        // Set the URL to perform the GET request on
        req._add(
            "get",
            "https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD"
        );

        // Set the path to find the desired data in the API response, where the response format is:
        // {"RAW":
        //   {"ETH":
        //    {"USD":
        //     {
        //      "VOLUME24HOUR": xxx.xxx,
        //     }
        //    }
        //   }
        //  }
        // request.add("path", "RAW.ETH.USD.VOLUME24HOUR"); // Chainlink nodes prior to 1.0.0 support this format
        req._add("path", "RAW,ETH,USD,VOLUME24HOUR"); // Chainlink nodes 1.0.0 and later support this format

        // Multiply the result by 1000000000000000000 to remove decimals
        int256 timesAmount = 10 ** 18;
        req._addInt("times", timesAmount);

        // Sends the request
        return _sendChainlinkRequest(req, fee);
    }

    /**
     * Receive the response in the form of uint256
     */
    function fulfill(
        bytes32 _requestId,
        uint256 _volume
    ) public recordChainlinkFulfillment(_requestId) {
        emit RequestVolume(_requestId, _volume);
        volume = _volume;
    }

    /**
     * Allow withdraw of Link tokens from the contract
     */
    function withdrawLink() public onlyOwner {
        LinkTokenInterface link = LinkTokenInterface(_chainlinkTokenAddress());
        require(
            link.transfer(msg.sender, link.balanceOf(address(this))),
            "Unable to transfer"
        );
    }
}
```

[Open in Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/APIRequests/APIConsumer.sol&autoCompile=true)[What is Remix?](/getting-started/conceptual-overview#what-is-remix)To use this contract:

1. Open the contract in Remix.
2. Compile and deploy the contract using the Injected Provider environment. The contract includes all the configuration variables for the Sepolia testnet. Make sure your wallet is set to use Sepolia. The constructor sets the following parameters:

The Chainlink Token address for Sepolia by calling the setChainlinkToken function.
The Oracle contract address for Sepolia by calling the setChainlinkOracle function.
The jobId: A specific job for the oracle node to run. In this case, you must call a job that is configured to call a public API, parse a number from the response and remove any decimals from it. We are going to use a generic GET>uint256 job that can be found here.
3. Fund your contract with 0.1 LINK. To learn how to send LINK to contracts, read the Fund Your Contracts page.
4. Call the volume function to confirm that the volume state variable is equal to zero.
5. Run the requestVolumeData function. This builds the Chainlink.Request using the correct parameters:

The req._add("get", "CRYPTOCOMPARE_URL") request parameter provides the oracle node with the URL from which to fetch ETH-USD trading info.
The req._add('path', 'RAW,ETH,USD,VOLUME24HOUR') request parameter tells the oracle node where to fetch the 24h ETH volume in the json response. It uses a JSONPath expression with comma(,) delimited string for nested objects. For example: 'RAW,ETH,USD,VOLUME24HOUR'.
The req._addInt('times', timesAmount) request parameter provides the oracle node with the multiplier timesAmount by which the fetched volume is multiplied. Use this to remove any decimals from the volume. Note: The times parameter is mandatory. If the API that you call returns a number without any decimals then provide 1as timesAmount.
The APIConsumer in the example above is flexible enough to call any public API as long as the URL in get, path, and timesAmount are correct.
6. After few seconds, call the volume function. You should get a non-zero response.

### Response Types
Make sure to choose an oracle job that supports the data type that your contract needs to consume. Multiple data types are available such as:

• uint256 - Unsigned integers
• int256 - Signed integers
• bool - True or False values
• string - String
• bytes32 - Strings and byte values. If you need to return a string, use bytes32. Here's one method of converting bytes32 to string. Currently, any return value must fit within 32 bytes. If the value is bigger than that, make multiple requests.
• bytes - Arbitrary-length raw byte data

## Setting the LINK token address, Oracle, and JobId
The setChainlinkToken function sets the LINK token address for the network you are deploying to. The setChainlinkOracle function sets a specific Chainlink oracle that a contract makes an API call from. The jobId refers to a specific job for that node to run.

Each job is unique and returns different types of data. For example, a job that returns a bytes32 variable from an API would have a different jobId than a job that retrieved the same data, but in the form of a uint256 variable.

Check the Find Existing Jobs page to learn how to find a job suitable to your use case.

================================================================================

# Testnet Oracles

Source: https://docs.chain.link/any-api/testnet-oracles
Extraction Method: playwright
Components: code_block(10), table(2)

# Testnet Oracles
[Image: danger]Use Chainlink Functions

The Any API docs remain as a public historical reference for node operators. Please use Chainlink Functions instead.

Chainlink Functions provides your smart contracts access to trust-minimized compute infrastructure, allowing you to fetch data from APIs and perform custom computation. Read the Chainlink Functions
documentation to learn more.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }[Image: tip]Link token address and Faucet details

To retrieve the LINK token address or get faucet details for your testnet of choice, see the LINK Token Contracts page.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
## Operator Contracts
Testnet Operator contracts are deployed and maintained on the following networks:

Testnet | Oracle Address
--- | ---
Ethereum Sepolia | 0x6090149792dAAeE9D1D568c9f9a6F6B46AA29eFD
Avalanche Fuji | 0x022EEA14A6010167ca026B32576D6686dD7e85d2
Binance Testnet | 0xCC79157eb46F5624204f47AB42b3906cAA40eaB7
Fantom Testnet | 0xCC79157eb46F5624204f47AB42b3906cAA40eaB7

## Jobs

### Job IDs
To make testing simple, jobs are configured with the following properties:

• Each request on a testnet costs 0.1 LINK.
• Each oracle will wait for 1 confirmation before processing a request.
• Jobs have the same IDs across each testnet.
• Parameters are required. See examples for code snippets.

Purpose | Tasks | Job ID | Required Parameters
--- | --- | --- | ---
GET>bytes: HTTP GET to any public API parse the response return arbitrary-length raw byte data bytes. The job specs can be found here | HttpJsonParseEthabiencode | 7da2702f37fd48e5b1b9a5715e3509b6 | get: stringpath: JSONPath expression with comma(,) delimited string
GET>uint256: HTTP GET to any public API parse the response multiply the result by a multiplier return an unsigned integer uint256 .  The job specs can be found here | HttpJsonParseMultiplyEthabiencode | ca98366cc7314957b8c012c72f05aeeb | get: stringpath: JSONPath expression with comma(,) delimited stringtimes: int
GET>int256: HTTP GET to any public API parse the response multiply the result by a multiplier return a signed integer int256.  The job specs can be found here | HttpJsonParseMultiplyEthabiencode | fcf4140d696d44b687012232948bdd5d | get: stringpath: JSONPath expression with comma(,) delimited stringtimes: int
GET>bool: HTTP GET to any public API parse the response return a boolean bool.  The job specs can be found here | HttpJsonParseEthabiencode | c1c5e92880894eb6b27d3cae19670aa3 | get: stringpath: JSONPath expression with comma(,) delimited string
GET>string: HTTP GET to any public API parse the response return a sequence of characters string.  The job specs can be found here | HttpJsonParseEthabiencode | 7d80a6386ef543a3abb52817f6707e3b | get: stringpath: JSONPath expression with comma(,) delimited string

### Examples

#### Get > bytes
A full example can be found here.

##### Request method
[Image: copy to clipboard]
```solidity
function request() public {
  Chainlink.Request memory req = _buildChainlinkRequest('7da2702f37fd48e5b1b9a5715e3509b6', address(this), this.fulfill.selector);
  req._add(
      'get',
      'https://ipfs.io/ipfs/QmZgsvrA1o1C8BGCrx6mHTqR1Ui1XqbCrtbMVrRLHtuPVD?filename=big-api-response.json'
  );
  req._add('path', 'image');
  _sendChainlinkRequest(req, (1 * LINK_DIVISIBILITY) / 10); // 0,1*10**18 LINK
}
```

##### Callback method
[Image: copy to clipboard]
```solidity
bytes public data;
string public imageUrl;
function fulfill(bytes32 requestId, bytes memory bytesData) public recordChainlinkFulfillment(requestId) {
    data = bytesData;
    imageUrl = string(data);
}
```

#### Get > uint256
A full example can be found here.

##### Request method
[Image: copy to clipboard]
```solidity
function request() public {
  Chainlink.Request memory req = _buildChainlinkRequest('ca98366cc7314957b8c012c72f05aeeb', address(this), this.fulfill.selector);
  req._add(
      'get',
      'https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD'
  );
  req._add('path', 'RAW,ETH,USD,VOLUME24HOUR');
  req._addInt('times', 10**18); // Multiply by times value to remove decimals. Parameter required so pass '1' if the number returned doesn't have decimals
  _sendChainlinkRequest(req, (1 * LINK_DIVISIBILITY) / 10); // 0,1*10**18 LINK
}
```

##### Callback method
[Image: copy to clipboard]
```solidity
uint256 public volume;
function fulfill(bytes32 _requestId, uint256 _volume) public recordChainlinkFulfillment(_requestId) {
  volume = _volume;
}
```

#### Get > int256

##### Request method
[Image: copy to clipboard]
```solidity
function request() public {
  Chainlink.Request memory req = _buildChainlinkRequest('fcf4140d696d44b687012232948bdd5d', address(this), this.fulfill.selector);
  req._add(
      'get',
      'https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD'
  );
  req._add('path', 'RAW,ETH,USD,VOLUME24HOUR');
  req._addInt('times', 10**18); // Multiply by times value to remove decimals. Parameter required so pass '1' if the number returned doesn't have decimals
  _sendChainlinkRequest(req, (1 * LINK_DIVISIBILITY) / 10); // 0,1*10**18 LINK
}
```

##### Callback method
[Image: copy to clipboard]
```solidity
int256 public volume;
function fulfill(bytes32 _requestId, int256 _volume) public recordChainlinkFulfillment(_requestId) {
  volume = _volume;
}
```

#### Get > bool

##### Request method
[Image: copy to clipboard]
```solidity
function request() public {
  Chainlink.Request memory req = _buildChainlinkRequest('c1c5e92880894eb6b27d3cae19670aa3', address(this), this.fulfill.selector);
  req._add(
      'get',
      'https://app.proofi.com/api/verify/eip155/0xCB5085214B6318aF3dd0FBbb5E74fbF6bf332151?contract=0x2f7f7E44ca1e2Ca1A54db4222cF97ab47EE026F1'
  );
  req._add('path', 'approved');
  _sendChainlinkRequest(req, (1 * LINK_DIVISIBILITY) / 10); // 0,1*10**18 LINK
}
```

##### Callback method
[Image: copy to clipboard]
```solidity
bool public approved;
function fulfill(bytes32 _requestId, bool _approved) public recordChainlinkFulfillment(_requestId) {
  approved = _approved;
}
```

#### Get > string
A full example can be found here.

##### Request method
[Image: copy to clipboard]
```solidity
function request() public {
  Chainlink.Request memory req = _buildChainlinkRequest('7d80a6386ef543a3abb52817f6707e3b', address(this), this.fulfill.selector);
  req._add(
      'get',
      'https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&per_page=10'
  );
  req._add('path', '0,id');
  _sendChainlinkRequest(req, (1 * LINK_DIVISIBILITY) / 10); // 0,1*10**18 LINK
}
```

##### Callback method
[Image: copy to clipboard]
```solidity
string public id;
function fulfill(bytes32 _requestId, string memory _id) public recordChainlinkFulfillment(_requestId) {
  id = _id;
}
```

================================================================================

# Courses | Chainlink Certifications

Source: https://dev.chain.link/certification
Extraction Method: playwright

/* Devhub navbar styles */
@media (min-width: 992px) {
    .dev-nav-link:hover .dev-nav-link__shape,
    .dev-nav-link.w--current .dev-nav-link__shape,
    .dev-nav-link.w--open .dev-nav-link__shape {
        display: block;
    }
}

.dev-nav-link.dev-nav-link--dd:hover .dev-nav-link__shape path{
	fill: var(--chainlink-blue);
}

[data-nav-menu-open] {
	background-color: white;
}

.w-nav-overlay [data-nav-menu-open] {
    top: 64px;
}

@media (min-width: 991px) {
  .acad-nav-link:hover path {
    stroke: var(--chainlink-blue);
  }
}
  
/* Disable Blue Highlight  */
.dev-nav-link.dev-nav-link--dd {
		-webkit-tap-highlight-color:  rgba(255, 255, 255, 0); 
}Resources<svg xmlns="http://www.w3.org/2000/svg" width="47" height="39" viewBox="0 0 47 39" fill="none">
<g filter="url(#filter0_dd_921_10269)">
<path d="M11 14L27 14L19.7071 6.70711C19.3166 6.31658 18.6834 6.31658 18.2929 6.70711L11 14Z" fill="white"/>
</g>
<defs>
<filter id="filter0_dd_921_10269" x="0.6" y="0.714063" width="46" height="37.5859" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
<feFlood flood-opacity="0" result="BackgroundImageFix"/>
<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
<feMorphology radius="1" operator="dilate" in="SourceAlpha" result="effect1_dropShadow_921_10269"/>
<feOffset dx="4.6" dy="9.3"/>
<feGaussianBlur stdDeviation="7"/>
<feComposite in2="hardAlpha" operator="out"/>
<feColorMatrix type="matrix" values="0 0 0 0 0.596078 0 0 0 0 0.627451 0 0 0 0 0.72549 0 0 0 0.04 0"/>
<feBlend mode="normal" in2="BackgroundImageFix" result="effect1_dropShadow_921_10269"/>
<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
<feMorphology radius="0.3" operator="erode" in="SourceAlpha" result="effect2_dropShadow_921_10269"/>
<feOffset dx="1" dy="-1"/>
<feGaussianBlur stdDeviation="1.5"/>
<feComposite in2="hardAlpha" operator="out"/>
<feColorMatrix type="matrix" values="0 0 0 0 0.596078 0 0 0 0 0.627451 0 0 0 0 0.72549 0 0 0 0.21 0"/>
<feBlend mode="normal" in2="effect1_dropShadow_921_10269" result="effect2_dropShadow_921_10269"/>
<feBlend mode="normal" in="SourceGraphic" in2="effect2_dropShadow_921_10269" result="shape"/>
</filter>
</defs>
</svg>ResourcesCross-ChainCCIPGlobal standard for building secure cross-chain applications.

[Docs](https://docs.chain.link/ccip)[Learn](/products/ccip)[SDK](https://github.com/smartcontractkit/ccip-javascript-sdk)[View all resources](/resources)[Learn about Chainlink](/products/general)DataData resourcesMarket and Data Feeds resources for devs of any level.

[Learn](/products/data)FeedsDecentralized and high-quality data for DeFi, sports, weather, and more.

[Docs](https://docs.chain.link/data-feeds)[Learn](/products/data?sub-product=Data+Feeds)StreamsSecure high-frequency market data for ultra-fast derivative products.

[Docs](https://docs.chain.link/data-streams)[Learn](/products/data?sub-product=Data+Streams)ComputeAutomationHigh-performance, decentralized automation for smart contracts.

[Docs](https://docs.chain.link/chainlink-automation)[Learn](/products/automation)FunctionsServerless platform that fetches data from any API & runs custom compute.

[Docs](https://docs.chain.link/chainlink-functions)[Learn](/products/functions)VRFRandom number generator for blockchain gaming and NFTs.

[Docs](https://docs.chain.link/vrf)[Learn](/products/vrf)FeaturedHardhat CLI for Data Streams[Docs](https://docs.chain.link/data-streams/getting-started-hardhat)Try out Chainlink Automation[Docs](https://docs.chain.link/chainlink-automation/overview/getting-started)[Docs](https://docs.chain.link/)[Demos](/demos)[Tools](/tools)[Changelog](/changelog)[Get Certified](/certification)⌘K
## Supercharge your career with blockchain developer courses
Get Chainlink certified on Cyfrin, with hands-on learning in Web3, blockchain, tokenization, and smart contracts. Prove your skills and readiness to lead Chainlink-powered projects.Learn to build secure dApps using Chainlink’s core services—Data Feeds, VRF, Automation, and CCIP—through a developer-focused certification course.‍

[Start learning](https://updraft.cyfrin.io/courses/chainlink-fundamentals).acad-acc-item.acad-acc-item--active .acad-acc-item__desc {
    height: auto;
    padding-bottom: 24px;
  }
  
  .acad-acc-item.acad-acc-item--active .acad-acc-item__h {
  	color: white;
  }
  .acad-acc-item.acad-acc-item--active .acad-acc-item__arr {
    transform: rotate(-180deg);
  }
  
  .acad-acc-item__top:hover .acad-acc-item__h {
  	color: white;
    transition: 200ms ease;
  }THE PLATFORM
## The Learning Environment

### Hands-on learning built by experts
Experience interactive learning where you'll engage in experiential learning through practical use cases and coding exercises. Dive deep into real-world applications and build your skills with guided practice.

### Practice your skills
Hands-on, high feedback quizzes and tests to grow your blockchain learning and challenge your smart contract development.

### Become a certified Chainlink developer
Achieve a prestigious certification that is highly regarded in the blockchain industry. This certification not only validates your expertise but also significantly enhances your professional credibility and career prospects.

OTHER LEARNINGS
## Access free learning resources

### Chainlink Developer Bootcamps
Chainlink gives blockchain developers an easy-to-use framework for writing onchain applications. Join a bootcamp to learn how.

[Explore](https://chain.link/bootcamp)
### DevHub Videos
Start learning the basics of smart contracts with these step-by-step video tutorials made by expert Chainlink Labs developers.

[Explore](https://dev.chain.link/resources/videos)
### DevHub Resources
Understand Chainlink’s mission and platform by exploring tutorials, docs, blogs, and more, and learn how Chainlink services underpin the blockchain industry.

[Explore](https://dev.chain.link/resources)
### Developers

• Docs
• Builder Quick Links
• Faucets
• Developer Hub
• Chainlink Hackathon
• Bootcamp
• Use Cross-Chain (CCIP)
• Use Data Feeds
• Use Randomness (VRF)
• Use Automation
• Use Functions
• Node Operators

### Products

• Cross-Chain
• Data Streams
• Market and Data Feeds
• Functions
• VRF
• Automation
• Proof of Reserve

### Use Cases

• Overview
• Asset Tokenization
• Financial Services
• DeFi
• Gaming
• NFT Collectibles
• Climate Markets
• Enterprise
• Insurance

### Community

• Community Overview
• Grant Program
• Events
• Become an Advocate
• Code of Conduct

### Resources

• Whitepaper
• Blog
• Economics
• Staking
• Rewards
• FAQs
• Education Hub
• What Is DeFi?
• What Is an Oracle?
• What Is a Smart Contract?
• What Is an NFT?
• What Is Web3?

### Chainlink

• Ecosystem
• Data Providers
• Press
• Team
• Circulating Supply
• CareersWE ARE HIRING!
• Brand Assets
• Chainlink Badging

### Contact

• Talk to an expert
• Security
• Support
• Custom Chainlinks
• Press inquiries
• Legal Support
• Legal

### Social

• X
• LinkedIn
• YouTube
• Instagram
• TikTok
• Discord
• Telegram
• Reddit
• Facebook
• WeChat

[Home](https://chain.link/)Chainlink®© 2024 Chainlink FoundationenZH[Privacy Policy](https://chain.link/privacy-policy)[Terms of Service](https://chain.link/terms)document.addEventListener('DOMContentLoaded', function() {
  var popularResCols = document.querySelectorAll('.acad-acc-item');
  popularResCols.forEach(function(popularResCol) {
    popularResCol.addEventListener('click', function() {
      if (!this.classList.contains('acad-acc-item--active')) {
        // Remove 'popular-res__col--active' class from all elements
        popularResCols.forEach(function(col) {
          col.classList.remove('acad-acc-item--active');
        });
        // Add 'popular-res__col--active' class to the clicked element
        this.classList.add('acad-acc-item--active');
      }
    });
  });
});const items = document.querySelectorAll('.acad-acc-item');
const absoluteItems = document.querySelectorAll('.plat-absolute');

// Define the z-index and transform pairs
const zIndexValues = [3, 2, 1];
const transformValues = [
  'translate(0, 0)',    // For z-index 3
  'translate(-16px, -16px)', // For z-index 2
  'translate(-32px, -32px)'  // For z-index 1
];

items.forEach((item, index) => {
  item.addEventListener('click', function() {
    //console.log("Clicked index:", index);

    // Apply z-index and transform based on the clicked index
    absoluteItems.forEach((el, i) => {
      const newIndex = (i - index + absoluteItems.length) % absoluteItems.length; // Calculate new index based on clicked item
      el.style.zIndex = zIndexValues[newIndex]; // Apply corresponding z-index
      el.style.transform = transformValues[newIndex]; // Apply corresponding transform
    });

    //console.log("After rotation:");
    absoluteItems.forEach((el) => {
      //console.log(`zIndex=${el.style.zIndex}, transform=${el.style.transform}`);
    });
  });
});document.addEventListener("DOMContentLoaded", function () {
    if (/(Mac|iPhone|iPod|iPad)/i.test(navigator.platform)) {
      const macElements = document.querySelectorAll('.show-mac');
      const otherElements = document.querySelectorAll('.show-other-os');

      macElements.forEach(macElement => {
          macElement.style.display = 'inline';
      });

      otherElements.forEach(otherElement => {
          otherElement.style.display = 'none';
      });
  }
});document.addEventListener("DOMContentLoaded", function() {
    if (window.innerWidth < 992) {

    let accordionItems = document.querySelectorAll('.mega-menu-card:not(.mega-menu-card--no-accordeon)');
    let transitionDuration = '0.3s';
    let transitionTiming = 'ease';
    
    accordionItems.forEach(function(item) {
        let content = item.querySelector('.mega-menu-card__content');
        let caret = item.querySelector('.mega-menu-card__caret-vert');
        content.style.transition = 'height ' + transitionDuration + ' ' + transitionTiming;
        caret.style.transition = 'transform ' + transitionDuration + ' ' + transitionTiming;

        item.addEventListener('click', function() {
            let isVisible = content.offsetHeight > 0;

            accordionItems.forEach(function(otherItem) {
                let otherContent = otherItem.querySelector('.mega-menu-card__content');
                let otherCaret = otherItem.querySelector('.mega-menu-card__caret-vert');

                if (otherItem !== item) {
                    otherContent.style.height = '0';
                    otherCaret.style.transform = 'rotate(0deg)';
                }
            });

            content.style.height = isVisible ? '0' : content.scrollHeight + 'px';
            caret.style.transform = isVisible ? 'rotate(0deg)' : 'rotate(90deg)';
        });
    });
    }
});document.addEventListener("DOMContentLoaded", function() {
    if (window.innerWidth < 992) {
      var source = document.getElementById('res-link-source');
      var target = document.getElementById('res-link-target');
      while (source.childNodes.length > 0) {
        target.appendChild(source.childNodes[0]);
      }
    }
});document.addEventListener('DOMContentLoaded', function() {
    if (window.innerWidth < 992) {
      let isBodyScrollDisabled = false;

      // Utility function to toggle body scroll
      function toggleBodyScroll() {
          document.body.style.overflow = isBodyScrollDisabled ? '' : 'hidden';
          isBodyScrollDisabled = !isBodyScrollDisabled;
      }

      // Event listener for .dev-nav__menu-btn
      document.querySelector('.dev-nav__menu-btn').addEventListener('click', toggleBodyScroll);

      // Event listener for .dev-nav__search-wrap
      document.querySelector('.dev-nav__search-wrap').addEventListener('click', function() {
          if (isBodyScrollDisabled) {
              toggleBodyScroll(); // This will re-enable body scroll
          }
      });
    }
});document.addEventListener("DOMContentLoaded", function() {
    // First set of elements
    const closeBtn1 = document.querySelector("[mega-dd='close']");
    const openBtn1 = document.querySelector("[mega-dd='open']");
    const menuWrapper1 = document.querySelector("[mega-dd='wrapper']");
    
    // Second set of elements
    const closeBtn2 = document.querySelector("[mega-dd='close-2']");
    const openBtn2 = document.querySelector("[mega-dd='open-2']");
    const menuWrapper2 = document.querySelector("[mega-dd='wrapper-2']");
    
    const devNavCenter = document.querySelector('.dev-nav__center');
    
    function handleMenuActions(closeBtn, openBtn, menuWrapper) {
        if (window.innerWidth < 992) {
            closeBtn.addEventListener('click', function(event) {
                event.stopPropagation(); // Prevent the click event from bubbling up
                menuWrapper.style.display = 'none';
                devNavCenter.style.zIndex = '10';
            });

            openBtn.addEventListener('click', function() {
                menuWrapper.style.display = 'flex';
                devNavCenter.style.zIndex = '50';
            });
        }
        
        openBtn.addEventListener('click', function() {
            const navMenuOpenElement = document.querySelector('.w-nav-overlay [data-nav-menu-open]');
            if (navMenuOpenElement) {
                navMenuOpenElement.style.top = '0px';
            }
        });

        closeBtn.addEventListener('click', function() {
            document.querySelector('.w-nav-overlay [data-nav-menu-open]').style.top = '64px';
        });
    }
    
    handleMenuActions(closeBtn1, openBtn1, menuWrapper1);
    handleMenuActions(closeBtn2, openBtn2, menuWrapper2);
});document.addEventListener("DOMContentLoaded", function() {
  const urlParams = new URLSearchParams(window.location.search);
  if (urlParams.has("scroll") && urlParams.get("scroll") === "courses") {
    const coursesSection = document.getElementById("courses");
    if (coursesSection) {
      coursesSection.scrollIntoView({ behavior: "smooth" });
    }
  }
});document.addEventListener("DOMContentLoaded", function () {
  const openBtn = document.querySelector("[mega-dd='open']");
    if (openBtn) {
        openBtn.classList.add('w--current');
    }
});var currentPageURL=document.location.href,cdomain="chain.link",now=new Date,time=now.getTime(),expireTime=time+15552E6;now.setTime(expireTime);currentPageURL.includes("utm_medium")&&(document.cookie="__wf_campaign_url\x3d"+encodeURIComponent(currentPageURL)+";expires\x3d"+now.toUTCString()+";path\x3d/;domain\x3d"+cdomain);(function(){function c(){var a=document.querySelector('input[class*\x3d"aiDrawerInput"]');a&&!a._chatListenerAttached&&(a._chatListenerAttached=!0,a.addEventListener("keydown",function(b){b=b||window.event;b.key!=="Enter"&&b.keyCode!==13||a.value.trim()===""||(window.dataLayer=window.dataLayer||[],window.dataLayer.push({event:"user_ai_query",user_ai_query:a.value.trim()}))}))}var d=new MutationObserver(function(a){(a=document.querySelector('input[class*\x3d"aiDrawerInput"]'))&&c()});d.observe(document.body,
{childList:!0,subtree:!0});c()})();Main nav show/hide overlay 
<script>
        window.onload = function() {
            var overlay = document.querySelector('.res-nav-overlay');
            
            window.addEventListener('scroll', function() {
                var scrollPosition = window.scrollY;

                if (scrollPosition >= 12) {
                    overlay.style.opacity = '0.8';
                } else {
                    overlay.style.opacity = '0';
                }
            });
        }
</script>function loadJS(FILE_URL, callback, type = "text/javascript") {
  let scriptEle = document.createElement("script");
  const urlWithAppendedDate = `${FILE_URL}?v=${Date.now()}`;
  scriptEle.setAttribute("src", urlWithAppendedDate);
  scriptEle.setAttribute("type", type);
  scriptEle.setAttribute("defer", true);

  document.body.appendChild(scriptEle);

  // success event 
  scriptEle.addEventListener("load", (callback) => {
    console.log("File loaded");
    callback();
  });
   // error event
  scriptEle.addEventListener("error", (ev) => {
    console.log("Error on loading file", ev);
  });
}
function loadCSS(FILE_URL) {
  let scriptEle = document.createElement("link");
  const urlWithAppendedDate = `${FILE_URL}?v=${Date.now()}`;
  scriptEle.setAttribute("href", urlWithAppendedDate);
  scriptEle.setAttribute("rel", "stylesheet");
  scriptEle.setAttribute("type", "text/css");

  document.body.appendChild(scriptEle);

  // success event 
  scriptEle.addEventListener("load", () => {
    console.log("File loaded")
  });
   // error event
  scriptEle.addEventListener("error", (ev) => {
    console.log("Error on loading file", ev);
  });
}Search dialog from external packageRollback plan: Please replace the content of Href with the following: https://cdn.jsdelivr.net/npm/chainlink-algolia-search@0.10.1/dist/index.csswindow.process = window.process ||{};
  process.env = window.process.env || {};
  process.env.NODE_ENV = "production";Rollback plan: Please replace the content of the import with the following: https://cdn.jsdelivr.net/npm/chainlink-algolia-search@0.10.1/dist/webflow-import.mjsimport { webflowComponentImport } from 'https://cdn.jsdelivr.net/npm/@chainlink/cl-search-frontend@0.11.4/dist/webflow-import.mjs';
  webflowComponentImport( {
	elementId:"search-container",
    algoliaAppId: "K1NK1TQHV9",
    algoliaPublicApiKey: "6499ecf5d48e511595fd0f88f1c2c0fa",
    popularCards:[
      {
          url: "https://docs.chain.link/",
          imgSrc: "https://cdn.prod.website-files.com/64cc2c23d8dbd707cdb556d8/684b2a334369d2fb64c04591_Docs.svg",
          label: "Docs",
      },
      { 
          url: "https://dev.chain.link/demos",
          imgSrc: "https://cdn.prod.website-files.com/64cc2c23d8dbd707cdb556d8/684b2a33b0dd30e514591610_Demos.svg",
          label: "Demos"
      }
    ]});END:Search dialog from external packageStart of HubSpot Embed CodeEnd of HubSpot Embed CodeStart of External scriptimport { manageBanner } from 'https://thisdot.github.io/chainlink-webflow-cms-api/webflow-script/banner.js';
  manageBanner({
    bannerSelector: ".header-banner",
    bannerDescriptionSelector: '.header-banner-description',
    closeButtonSelector: ".banner-close",
  });End of External scriptAsk AI

================================================================================

# Smart Contract Overview

Source: https://docs.chain.link/getting-started/conceptual-overview
Extraction Method: playwright
Components: code_block(7)

# Smart Contract Overview
Welcome to the Smart Contract Getting Started guide. This overview explains the basic concepts of smart contract development and oracle networks.

Skip ahead:
To get your hands on the code right away, you can skip this overview:

• Deploy Your First Smart Contract: If you are new to smart contracts, deploy your first smart contract in an interactive web development environment.
• Learn how to use Data Feeds: If you are already familiar with smart contracts and want to learn how to create hybrid smart contracts, use Chainlink Data Feeds to get asset price data onchain.

Playclass i extends HTMLElement{connectedCallback(){this.videoId=this.getAttribute("videoid");let e=this.querySelector(".lty-playbtn");if(this.playLabel=e&&e.textContent.trim()||this.getAttribute("playlabel")||"Play",this.dataset.title=this.getAttribute("title")||"",this.style.backgroundImage||(this.style.backgroundImage=`url("https://i.ytimg.com/vi/${this.videoId}/hqdefault.jpg")`,this.upgradePosterImage()),e||(e=document.createElement("button"),e.type="button",e.classList.add("lty-playbtn"),this.append(e)),!e.textContent){const t=document.createElement("span");t.className="lyt-visually-hidden",t.textContent=this.playLabel,e.append(t)}this.addNoscriptIframe(),e.nodeName==="A"&&(e.removeAttribute("href"),e.setAttribute("tabindex","0"),e.setAttribute("role","button"),e.addEventListener("keydown",t=>{(t.key==="Enter"||t.key===" ")&&(t.preventDefault(),this.activate())})),this.addEventListener("pointerover",i.warmConnections,{once:!0}),this.addEventListener("focusin",i.warmConnections,{once:!0}),this.addEventListener("click",this.activate),this.needsYTApi=this.hasAttribute("js-api")||navigator.vendor.includes("Apple")||navigator.userAgent.includes("Mobi")}static addPrefetch(e,t,a){const r=document.createElement("link");r.rel=e,r.href=t,a&&(r.as=a),document.head.append(r)}static warmConnections(){i.preconnected||(i.addPrefetch("preconnect","https://www.youtube-nocookie.com"),i.addPrefetch("preconnect","https://www.google.com"),i.addPrefetch("preconnect","https://googleads.g.doubleclick.net"),i.addPrefetch("preconnect","https://static.doubleclick.net"),i.preconnected=!0)}fetchYTPlayerApi(){window.YT||window.YT&&window.YT.Player||(this.ytApiPromise=new Promise((e,t)=>{var a=document.createElement("script");a.src="https://www.youtube.com/iframe_api",a.async=!0,a.onload=r=>{YT.ready(e)},a.onerror=t,this.append(a)}))}async getYTPlayer(){return this.playerPromise||await this.activate(),this.playerPromise}async addYTPlayerIframe(){this.fetchYTPlayerApi(),await this.ytApiPromise;const e=document.createElement("div");this.append(e);const t=Object.fromEntries(this.getParams().entries());this.playerPromise=new Promise(a=>{let r=new YT.Player(e,{width:"100%",videoId:this.videoId,playerVars:t,events:{onReady:n=>{n.target.playVideo(),a(r)}}})})}addNoscriptIframe(){const e=this.createBasicIframe(),t=document.createElement("noscript");t.innerHTML=e.outerHTML,this.append(t)}getParams(){const e=new URLSearchParams(this.getAttribute("params")||[]);return e.append("autoplay","1"),e.append("playsinline","1"),e}async activate(){if(this.classList.contains("lyt-activated"))return;if(this.classList.add("lyt-activated"),this.needsYTApi)return this.addYTPlayerIframe(this.getParams());const e=this.createBasicIframe();this.append(e),e.focus()}createBasicIframe(){const e=document.createElement("iframe");return e.width=560,e.height=315,e.title=this.playLabel,e.allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture",e.allowFullscreen=!0,e.src=`https://www.youtube-nocookie.com/embed/${encodeURIComponent(this.videoId)}?${this.getParams().toString()}`,e}upgradePosterImage(){setTimeout(()=>{const e=`https://i.ytimg.com/vi_webp/${this.videoId}/sddefault.webp`,t=new Image;t.fetchPriority="low",t.referrerpolicy="origin",t.src=e,t.onload=a=>{a.target.naturalHeight==90&&a.target.naturalWidth==120||(this.style.backgroundImage=`url("${e}")`)}},100)}}customElements.define("lite-youtube",i);
## What is a smart contract? What is a hybrid smart contract?
When deployed to a blockchain, a smart contract is a set of instructions that can be executed without intervention from third parties. The smart contract code defines how it responds to input, just like the code of any other computer program.

A valuable feature of smart contracts is that they can store and manage onchain assets (like ETH or ERC20 tokens), just like you can with an Ethereum wallet. Because they have an onchain address like a wallet, they can do everything any other address can. This enables you to program automated actions when receiving and transferring assets.

Smart contracts can connect to real-world market prices of assets to produce powerful applications. Securely connecting smart contracts with offchain data and services is what makes them hybrid smart contracts. This is done using oracles.

## What language is a smart contract written in?
The most popular language for writing smart contracts on Ethereum and EVM Chains is Solidity. It was created by the Ethereum Foundation specifically for smart contract development and is constantly being updated. Other languages exist for writing smart contracts on Ethereum and EVM Chains, but Solidity is the language used for Chainlink smart contracts.

If you've ever written Javascript, Java, or other object-oriented scripting languages, Solidity should be easy to understand. Similar to object-oriented languages, Solidity is considered to be a contract-oriented language.

Some networks are not EVM-compatible and use languages other than Solidity for smart contracts, such as Solana in Rust or Starknet in Cairo.

## What does a smart contract look like?
The structure of a smart contract is similar to that of a class in Javascript, with a few differences. For example, the following HelloWorld contract is a simple smart contract that stores a single variable and includes a function to update the value of that variable.

[Image: copy to clipboard]
```solidity
// SPDX-License-Identifier: MIT

pragma solidity 0.8.7;

/**
 * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

contract HelloWorld {
    string public message;

    constructor(string memory initialMessage) {
        message = initialMessage;
    }

    function updateMessage(string memory newMessage) public {
        message = newMessage;
    }
}
```

[Open in Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/Tutorials/HelloWorld.sol&autoCompile=true)[What is Remix?](/getting-started/conceptual-overview#what-is-remix)
### Solidity versions
The first thing that every Solidity file must have is the Solidity version definition. The HelloWorld.sol contract uses version 0.8.7, which is defined in the contract as pragma solidity 0.8.7;

You can see the latest versions of the Solidity compiler here. You might also notice smart contracts that are compatible with a range of versions.

[Image: copy to clipboard]
```solidity
pragma solidity >=0.7.0 <0.9.0;
```

This means that the code is written for Solidity version 0.7.0, or a newer version of the language up to, but not including version 0.9.0. The pragma selects the compiler, which defines how the code is treated.

### Naming a Contract
The contract keyword defines the name of the contract, which in this example is HelloWorld. This is similar to declaring a class in Javascript. The implementation of HelloWorld is inside this definition and denoted with curly braces.

[Image: copy to clipboard]
```solidity
contract HelloWorld {

}
```

### Variables
Like Javascript, contracts can have state variables and local variables. State variables are variables with values that are permanently stored in contract storage. The values of local variables, however, are present only until the function is executing. There are also different types of variables you can use within Solidity, such as string, uint256, etc. Check out the Solidity documentation to learn more about the different kinds of variables and types.

Visibility modifiers are used to define the level of access to these variables. Here are some examples of state variables with different visibility modifiers:

[Image: copy to clipboard]
```solidity
string public message;
uint256 internal internalVar;
uint8 private privateVar;
```

Learn more about state variables visibility here.

### Constructors
Another familiar concept to programmers is the constructor. When you deploy a contract, the constructor sets the state of the contract when it is first created.

In HelloWorld, the constructor takes in a string as a parameter and sets the message state variable to that string.

[Image: copy to clipboard]
```solidity
constructor(string memory initialMessage) {
  message = initialMessage;
}
```

### Functions
Functions can access and modify the state of the contract or call other functions on external contracts. HelloWorld has a function named updateMessage, which updates the current message stored in the state.

[Image: copy to clipboard]
```solidity
constructor(string memory initialMessage) {
  message = initialMessage;
}

function updateMessage(string memory newMessage) public {
  message = newMessage;
}
```

Functions use visibility modifiers to define the access level. Learn more about functions visibility here.

### Interfaces
An interface is another concept that is familiar to programmers of other languages. Interfaces define functions without their implementation, which leaves inheriting contracts to define the actual implementation themselves. This makes it easier to know what functions to call in a contract. Here's an example of an interface:

[Image: copy to clipboard]
```solidity
// SPDX-License-Identifier: MIT

pragma solidity 0.8.7;

/**
 * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

interface numberComparison {
    function isSameNum(uint a, uint b) external view returns (bool);
}

contract Test is numberComparison {
    constructor() {}

    function isSameNum(uint a, uint b) external pure override returns (bool) {
        if (a == b) {
            return true;
        } else {
            return false;
        }
    }
}
```

[Open in Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/Tutorials/Test.sol&autoCompile=true)[What is Remix?](/getting-started/conceptual-overview#what-is-remix)For this example, override is necessary in the Test contract function because it overrides the base function contained in the numberComparison interface. The contract uses pure instead of view because the isSameNum function in the Test contract does not return a storage variable.

## What does "deploying" mean?
Deploying a smart contract is the process of pushing the code to the blockchain, at which point it resides with an onchain address. Once it's deployed, the code cannot be changed and is said to be immutable.

As long as the address is known, its functions can be called through an interface, on Etherscan, or through a library like web3js, web3py, ethers, and more. Contracts can also be written to interact with other contracts on the blockchain.

## What is a LINK token?
The LINK token is an ERC677 token that inherits functionality from the ERC20 token standard and allows token transfers to contain a data payload. It is used to pay node operators for retrieving data for smart contracts and also for deposits placed by node operators as required by contract creators.

Any wallet that handles ERC20 tokens can store LINK tokens. The ERC677 token standard that the LINK token implements still retains all functionality of ERC20 tokens.

## What are oracles?
Oracles provide a bridge between the real-world and onchain smart contracts by being a source of data that smart contracts can rely on, and act upon.

Oracles play a critical role in facilitating the full potential of smart contract utility. Without a reliable connection to real-world conditions, smart contracts cannot effectively serve the real-world.

## How do smart contracts use oracles?
Oracles are most popularly used with Data Feeds. DeFi platforms like AAVE and Synthetix use Chainlink data feed oracles to obtain accurate real-time asset prices in their smart contracts.

Chainlink data feeds are sources of data aggregated from many independent Chainlink node operators. Each data feed has an onchain address and functions that enable contracts to read from that address. For example, the ETH / USD feed.

Smart contracts also use oracles to get other capabilities onchain:

• Generate Verifiable Random Numbers (VRF): Use Chainlink VRF to consume randomness in your smart contracts.
• Call External APIs (Any API): Request & Receive data from any API using the Chainlink contract library.
• Automate Smart Contracts using Chainlink Automation: Automating smart contract functions and regular contract maintenance.

## What is Remix?
PlayRemix is a web IDE (integrated development environment) for creating, running, and debugging smart contracts in the browser. It is developed and maintained by the Ethereum foundation. Remix allows Solidity developers to write smart contracts without a development machine since everything required is included in the web interface. It allows for a simplified method of interacting with deployed contracts, without the need for a command line interface. Remix also has support for samples. This means that Remix can load code from Github.

To learn how to use Remix, see the Deploying Your First Smart Contract
 guide.

[Deploy Your First Smart Contract](/quickstarts/deploy-your-first-contract)
## What is MetaMask?
Contracts are deployed by other addresses on the network. To deploy a smart contract, you need an address. Not only that, but you need an address which you can easily use with Remix. Fortunately, MetaMask is just what is needed. MetaMask allows anyone to create an address, store funds, and interact with Ethereum compatible blockchains from a browser extension.

================================================================================

# Acquire testnet LINK

Source: https://docs.chain.link/resources/acquire-link
Extraction Method: playwright

# Acquire testnet LINK
The Getting Started guides show you how to send ETH on the Sepolia testnet, but some contracts might require you to use LINK token instead. This page shows you how to obtain testnet LINK and send it to your MetaMask wallet.

## Configure MetaMask to use LINK tokens
To see your LINK token balance in MetaMask, you must manually add the token.

1. Open up MetaMask.
2. At the bottom of the MetaMask windows, click Import tokens.
3. Find the LINK token contract address for the network that you want to use. On Sepolia, the LINK token address is: 0x779877A7B0D9E8603169DdbD7836e478b4624789. See the LINK Token Contracts page to find the addresses for different testnets.
4. Paste the token contract address into MetaMask in the Token Address input. The token symbol and decimals of precision will auto-populate.
5. Click Next. A new window will appear, showing the LINK token details.
6. Click Import Tokens to confirm adding the new token.

MetaMask should now display the new LINK token balance.

## Get testnet LINK from a faucet

1. Go to faucets.chain.link.
2. In MetaMask, select the network where you want to receive testnet LINK.
3. Click Connect wallet so the faucet app can detect the network and wallet address.
4. If you want to receive testnet funds at a different address, paste it in the Wallet address section. This field defaults to your connected wallet address.
5. In the Request type section, select the testnet funds that you want to receive.
6. Complete the Captcha and click Send request. The funds are transferred from the faucet to the wallet address that you specified.

After the transaction is confirmed onchain, the faucet app shows "Request complete" and the transaction hash of your request.

================================================================================

# Cross-chain bridges and associated risks

Source: https://docs.chain.link/resources/bridge-risks
Extraction Method: playwright

# Cross-chain bridges and associated risks
When working with Chainlink on layer-2 chains and sidechains, you must export your LINK tokens from Ethereum to the target chain using a cross-chain bridge. Follow this video for an example of moving LINK tokens from Ethereum to Polygon.

Cross-chain bridges come with their own risks. In fact, bridge attacks constitute some of the largest cryptocurrency hacks by value. When moving your LINK tokens or any asset across chains, understand the risks that you are taking with your assets. Chainlink Labs does not endorse any bridge. Ultimately, you are responsible for assessing the bridge that you use to move your assets.

Read the What is a cross-chain bridge, Trade-offs, and Risks sections to learn more about bridges and trust assumptions in their designs. After you read these sections, you will have a better understanding of bridge risks and which aspects you should evaluate when using a bridge.

## What is a Cross-chain bridge
With the proliferation of layer-1 blockchains and layer-2 scaling solutions, the web3 ecosystem has become multi-chain. Each blockchain comes with its own approach to scalability, security, and trust.

However, blockchains are not natively capable of communicating with each other, which makes blockchain interoperability protocols critical for allowing dApps to interact with any onchain network and tap into each blockchain's unique assets and features.

A bridge is a core element of cross-chain interoperability. Bridges exist to connect blockchain networks and enable connectivity between them.

Bridges enable the following:

• Cross-chain transfer of assets and information
• dApps can leverage the strengths and benefits of different chains
• Collaboration between developers from different blockchain ecosystems to build new platforms and products for users

As an analogy, you can use the blockchains as cities mental model:

• Layer-1 blockchains are like cities.
• Layer-2 solutions are equivalent to skyscrapers. As described in the mental model, “Each rollup is like a vertical blockchain that extends from the ground L1”.
• Bridges are like roads and streets that connect different cities and skyscrapers.

## Trade-offs
With the growing number of layer-1 and layer-2 chains, the number of bridges has also grown, surpassing one hundred. So, how do you choose the correct bridge?

When choosing a bridge, there is no perfect solution, only trade-offs. As explained in the interoperability trilemma and Ethereum foundation docs, bridge designs must compromise between the following characteristics:

• Trust-minimization: The system does not introduce new trust or security assumptions beyond those of the underlying blockchains. Read trust-minimization for more details.
• Generalizability: The system enables the transfer of complex arbitrary data. Data could be messages or assets/funds.
• Extensibility: How hard is it to integrate a new blockchain?
• Latency: How long does it take to complete a transaction?
• Costs: How much does it cost to transfer data across chains via a bridge?

## Risks
When choosing a bridge, be aware of the following risks.

### Smart contract risks
Bugs and vulnerabilities can expose users' assets to different kinds of exploits. Read this detailed analysis for an example of a bridge exploit where the attacker could leverage a logical error in the bridge’s smart contract.

### Systemic financial risks
To transfer tokens cross-chain, many bridges lock tokens on the source chain and mint derivative or wrapped tokens on the destination chain representing the locked tokens. A hack of the locked tokens or an infinite mint attack on the wrapped tokens can make all wrapped tokens worthless and expose entire blockchains to risk.

### Early stage
Given that bridges are relatively new, there are many unanswered questions related to how bridges will perform in different market conditions.

### Trust-minimization (Counterparty risk)
To overcome cross-chain interoperability challenges, some bridges use offchain actors or validators. These actors introduce new trust assumptions in addition to the underlying blockchain trust assumptions. These bridges act as a custodian and are, therefore, trust-based.
In contrast, some bridge designs rely on underlying blockchains' validators and, therefore, do not add any trust assumptions.
To summarize:

• Trusted (custodial) bridges require a third party to validate movements over the bridge. Users are required to give up control of their crypto assets, so trust is involved as they rely on the bridge operator's reputation.
• Trustless (non-custodial) bridges leverage smart contracts to store and release funds on either side of the bridge. These bridges are trust-minimized because they don't make new trust assumptions beyond the underlying blockchains.

Trustlessness in bridges does not exist in an absolute form (trusted vs. trustless). As explained in the blockchain-interoperability blog, there are four general interoperability solutions for validating the state of a source blockchain and relaying the subsequent transaction to the destination blockchain:

#### Web2 Verification
Web2 verification is when someone uses a web2 service to execute a cross-chain transaction. The most common example in practice is when users leverage centralized exchanges to swap or bridge their own tokens. The user simply deposits their assets into an address on the source chain that's under the control of the exchange and then withdraws the same tokens or different tokens (via a swap on the exchange) to an address on a destination chain controlled by the user.

Web2 verification can be fairly convenient for personal transactions and requires less technical expertise. However, it is limited only to swapping and bridging tokens which requires trust in a centralized custodian.

#### External verification
External verification is where a group of validator nodes are responsible for verifying transactions. These validators do not belong to either of the two blockchains’ validator sets and they also have their trust assumptions irrespective of the underlying blockchains.

External verification typically requires an honest majority assumption, where a majority of the external validator nodes must behave honestly for the integrity of the cross-chain interaction to be upheld. However, additional techniques can be used to increase trust-minimization, such as:

• Optimistic bridge verification
• Risk management networks
• Cryptoeconomic staking

Despite an additional trust assumption, external verification is currently the only practical way to perform cross-chain contract calls between certain types of blockchains while still providing trust-minimized guarantees. It’s also a highly generalized and extensible form of cross-chain computation that is capable of supporting more complex cross-chain applications.

[Image: note]Cryptography risk

Some externally verified bridges are secured by multisig wallets.
Ronin is one example. Multisig wallets are
also referred to as m-of-n multisigs, with M being the required number of signatures or keys and N being the total
number of signatures or keys (m≤n). This means that an attacker only needs to exploit M keys to be able to hack the
whole system. In this case, users must trust that the third party is decentralized enough, signers are independent of
each other, and that each signer has proper key management in place. Read this detailed
analysis for an example of a bridge exploit where the attacker could compromise M
keys.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }[Image: note]Optimistic bridges

Optimistic bridges rely on honest watchers to monitor the bridges' operations and report any risks. Because the
watchers of an optimistic system are permissionless, there is no way to know if there is not at least one single
watcher monitoring the system. Therefore, the cost of a successful attack is limitless as it requires an attacker to
know who the watchers are and hack all of them.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }Here are some examples of externally verified bridges that use different techniques to increase trust-minimization :

• Binance bridge is a trusted bridge using the security standards of Binance.
• Polygon POS bridge uses a proof of stake (PoS) consensus algorithm for network security.
• Nomad is an optimistic bridge. It uses optimistic verification where messages are optimistically signed on the origin chain and a timeout period is enforced on the destination. During this period, a set of actors called watchers can inspect the messages and flag any detected risks.

#### Local verification
Local verification is when the counterparties in a cross-chain interaction verify the state of one another. If both deem the other valid, the cross-chain transaction is executed, resulting in peer-to-peer cross-chain transactions. Cross-chain swaps using local verification are often referred to as atomic swaps.

This model has a high level of trust-minimization given reasonable blockchain assumptions, as the swap either happens or both transactions fail. Furthermore, the model works so long as both parties are economically adversarial: they cannot collude to steal funds during atomic swaps.

Note that local verification is not very generalizable to a variety of cross-chain contract calls, and comes with tradeoffs like the inadvertent call option problem — a situation where the second party in an atomic swap can either act or not act on the swap, giving them an inadvertent call option for a certain period of time. Thus, local verification is mostly used in cross-chain liquidity protocols involving liquidity pools that exist independently on each chain.

Hop or Connext Legacy are examples of locally verified bridges.

#### Native verification
In this design, the validators of the destination blockchains are responsible for verifying the state of the source blockchain to confirm a given transaction. This is typically done by running a light client of the source chain in the virtual machine of the destination chain or running them both side-by-side. Native verification is the most trust-minimized form of cross-chain communication, but it is more expensive, offers less development flexibility, and is more suited to blockchains with similar state machines, such as between Ethereum and EVM-based layer-2 networks or only among Cosmos SDK-based blockchains.

The NEAR Rainbow Bridge is an example of a natively verified bridge. A smart contract with Ethereum light client functionality is deployed on the NEAR blockchain and a smart contract with NEAR protocol light client functionality is deployed on Ethereum. These light clients hold the latest block headers and verify that cross-chain transactions are done across both chains. The trust model relies only on Ethereum and Near validators.

================================================================================

# Install Frameworks

Source: https://docs.chain.link/resources/create-a-chainlinked-project
Extraction Method: playwright
Components: code_block(2)

# Install Frameworks
You can install and use Chainlink in your projects either manually or by using the Chainlink Starter Kits. Once you have the Chainlink library installed, you can more easily access the Chainlink ecosystem.

[Image: note]Important

If you're new to smart contract development and want a step-by-step guide, try out our Getting Started guide.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
## Installing into existing projects
Chainlink is supported by Hardhat, Brownie, Truffle, and other frameworks.

If you already have a project, install the @chainlink/contracts NPM package.

### NPM
Install using NPM:

[Image: copy to clipboard]
```shell
npm install @chainlink/contracts --save
```

### Yarn
Install using Yarn:

[Image: copy to clipboard]
```shell
yarn add @chainlink/contracts
```

## Create a new project
If you're creating a new project from scratch, these commands will help you set up your project to interact with Chainlink tools and features via the use of our Starter Kits.

### Hardhat Starter Kit
For the latest instructions, see the following repositories:

• Hardhat Starter Kit
• Hardhat Starter Kit (TypeScript)

To learn more about Hardhat, read the Hardhat Documentation.

For more details on how to use Chainlink with Hardhat, see the blog post for How to use Hardhat with Chainlink.

### Brownie Starter Kit
For the latest instructions, see the Brownie Starter Kit repository.

To learn more about Brownie, read the Brownie Documentation.

For more details on how to use Chainlink with Brownie, see the Develop a DeFi Project Using Python blog post.

### Truffle Starter Kit
For the latest instructions, see the Truffle Starter Kit repository.

To learn more about Truffle, read the Truffle Suite Documentation.

For more details on how to use Chainlink with Truffle, see our blog post about Using Truffle to interact with Chainlink Smart Contracts.

### Foundry Starter Kit
For the latest instructions, see the following repositories:

• Foundry Starter Kit
• Foundry Starter Kit (Huff)

To learn more about Foundry, read the Foundry Documentation.

### Apeworx Starter Kit (Vyper)
For the latest instructions, see the Apeworx Starter Kit repository.

To learn more about Truffle, read the Apeworx Documentation.

### Anchor Starter Kit (Solana)
For the latest instructions, see the Chainlink Solana Starter Kit repository.

To learn more about Anchor, see the Anchor Documentation.

## Testing Chainlink contracts
See our blog post on Testing Chainlink Smart Contracts or watch the Chainlink Hackathon Workshop.

Tests samples can be found on Hardhat Starter Kit and Truffle Starter Kit respectively.

================================================================================

# Developer Communications

Source: https://docs.chain.link/resources/developer-communications
Extraction Method: playwright

# Developer Communications
The Chainlink Developer mailing list is the best place to stay up to date on

• Releases
• Package Updates
• New Features
• Breaking Changes
• Events
• Connecting with other developers

## Subscribe to the latest Chainlink Developer news
Email Address
### 微信中文开发者社区

### (WeChat Chinese Developer Community)
https://u.wechat.com/MFfVjWlXvRIvwy5_hxFgvaE

================================================================================

# Fund Your Contracts

Source: https://docs.chain.link/resources/fund-your-contract
Extraction Method: playwright

# Fund Your Contracts
Some smart contracts require funding at their addresses so they can operate without you having to call functions manually and pay for the transactions through MetaMask. This guide explains how to fund Solidity contracts with LINK or ETH.

## Retrieve the contract address

1. In Remix, deploy your contract and wait until you see a new contract in the Deployed Contracts section.
2. On the left side panel, use the Copy button located near the contract title to copy the contract address to your clipboard.

astro-island,astro-slot,astro-static-slot{display:contents}(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).only=e;window.dispatchEvent(new Event("astro:only"));})();(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();
## Send funds to your contract

1. Open MetaMask.
2. Select the network that you want to send funds on. For example, select the Sepolia testnet.
3. Click the Send button to initiate a transaction.
4. Paste your contract address in the address field.
5. In the Asset drop down menu, select the type of asset that you need to send to your contract. For example, you can send LINK. If LINK is not listed, follow the guide to Acquire testnet LINK.
6. In the Amount field, enter the amount of LINK that you want to send.
7. Click Next to review the transaction details and the gas cost.
8. If the transaction details are correct, click Confirm and wait for the transaction to process.

[Image: caution]Transaction fee didn't update?

You may need to click Fastest, Fast, Slow, or Advanced Options after entering the Amount to update the gas limit for the token transfer to be successful.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }

================================================================================

# Hackathon Resources

Source: https://docs.chain.link/resources/hackathon-resources
Extraction Method: playwright

# Hackathon Resources
[Image: note]Note on Resources

For a comprehensive list of resources, refer to the Learning Resources page.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }This page lists useful resource to help you get started with Hackathon projects. If you want to check out code from past hackathons to get some inspiration, check out the Blog to find past hackathons and winners.

## Starter kits
You can use the starter kits to help test, deploy, interact with, and maintain your smart contracts. Starter kits are available for several different languages and frameworks. You can see the full list of available starter kits in the Starter Kits GitHub repository.

## Support communications
Always refer to the getting help page for the latest information about how to get support.

• Getting Help
• Stack Overflow
• Stack Exchange Ethereum
• Hackathon Discord
• Developer Discord

## Tutorials
If you are new to Smart Contracts, read the Getting Started Guide.

• Learning Resources
• Video Tutorials
• What is Ethereum?
• Developer Blog featuring several tutorials
• Testing Chainlink Smart Contracts
• NFTs and Chainlink
• Build an external adapter

## Inspiration

• 77 Use Cases by Chainlink
• Blog posts featuring past hackathons and winners

## Partners and BUILD projects

### Partners

• CTOR Labs
• Quicknode
• Covalent
• 0xcord

### BUILD projects

• Source Network
• Thirdfi

## Join the community
The Chainlink community is some of the most inviting groups of engineers always looking to help you grow to the next stage.

• Twitter
• Reddit
• Telegram
• Blog

================================================================================

# LINK Token Contracts

Source: https://docs.chain.link/resources/link-token-contracts
Extraction Method: playwright
Components: table(139)

# LINK Token Contracts
[Image: note]Talk to an expert

Contact us to talk to an expert about the networks that
support the LINK token.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }LINK tokens are used to pay node operators for retrieving data for smart contracts and also for deposits placed by node operators as required by contract creators. The smallest denomination of LINK is called a Juel, and 1,000,000,000,000,000,000 (1e18) Juels are equal to 1 LINK. This is similar to Wei, which is the smallest denomination of ETH.

The LINK token is an ERC677 token that inherits functionality from the ERC20 token standard and allows token transfers to contain a data payload. Read more about the ERC677 transferAndCall token standard.

To use Chainlink services on a given blockchain, it is necessary to use LINK tokens. You can transfer tokens across blockchains by using Chainlink CCIP or applications such as Transporter and XSwap.

[Image: note]Interfaces and Applications

Chainlink CCIP is a messaging protocol. Third parties may build user interfaces or other applications on top of CCIP.
Neither Chainlink Labs nor the Chainlink Foundation owns, controls, endorses, or assumes any responsibility for any
such interfaces or applications. You are solely responsible for your use of such interfaces or applications. Please
visit the Chainlink Foundation Terms of Service for more information.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }[Image: caution]Understand Risks associated with Bridges

If you are using a cross-chain bridge to transfer your LINK tokens, read the Bridges and Associated Risks guide to understand what cross-chain bridges are and the risks associated with using them.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
## 0G

### 0G Galileo Testnet

Parameter | Value
--- | ---
Chain ID | 16601
Address | 0xd211bd4ff8fd68c16016c5c7a66b6e10f6227c49
Name | Chainlink Token on 0G Galileo Testnet
Symbol | LINK
Decimals | 18

## Abstract

### Abstract Mainnet

Parameter | Value
--- | ---
Chain ID | 2741
Address | 0x2Ea38D6cDb6774992d4A62fe622f4405663729Dd
Name | Chainlink Token
Symbol | LINK
Decimals | 18

### Abstract Sepolia Testnet

Parameter | Value
--- | ---
Chain ID | 11124
Address | 0x6641415a61bCe80D97a715054d1334360Ab833Eb
Name | Chainlink Token
Symbol | LINK
Decimals | 18

## Apechain

### Apechain Mainnet

Parameter | Value
--- | ---
Chain ID | 33139
Address | 0xf575731b78981B86d34321d875A3D25a48479be6
Name | Chainlink Token
Symbol | LINK
Decimals | 18

### Apechain Curtis Testnet

Parameter | Value
--- | ---
Chain ID | 33111
Address | 0xa787B3E0471b718bBfEaA59B502fd0C4EBd7b74E
Name | Chainlink Token on Apechain Curtis Testnet
Symbol | LINK

## Arbitrum

### Arbitrum Mainnet
ETH is used to pay for transactions on the Arbitrum Mainnet.

You can use the Arbitrum Bridge to transfer ETH and LINK from Ethereum Mainnet to Arbitrum Mainnet.

Parameter | Value
--- | ---
Chain ID | 42161
Address | 0xf97f4df75117a78c1A5a0DBb814Af92458539FB4
Name | Chainlink Token on Arbitrum Mainnet
Symbol | LINK
Decimals | 18
Network status | arbiscan.freshstatus.io

### Arbitrum Sepolia Testnet
Testnet ETH is used to pay for transactions on Arbitrum Sepolia.

Testnet ETH and LINK are available at faucets.chain.link/arbitrum-sepolia.

Parameter | Value
--- | ---
Chain ID | 421614
Address | 0xb1D4538B4571d411F07960EF2838Ce337FE1E80E
Name | Chainlink Token on Arbitrum Sepolia Testnet
Symbol | LINK
Decimals | 18
Network status | arbiscan.freshstatus.io

## Astar

### Astar Mainnet
ASTR is used to pay for transactions on Astar Mainnet.

Parameter | Value
--- | ---
Chain ID | 592
Address | 0x31EFB841d5e0b4082F7E1267dab8De1b853f2A9d
Name | ChainLink Token on Astar Mainnet
Symbol | LINK
Decimals | 18
Network status | portal.astar.network/astar/dashboard

### Astar Shibuya
SBY is used to pay for transactions on Astar Shibuya. Testnet SBY is available at Astar Shibuya Faucet.

Testnet LINK is available at faucets.chain.link/astar-shibuya.

Parameter | Value
--- | ---
Chain ID | 81
Address | 0xe74037112db8807B3B4B3895F5790e5bc1866a29
Name | ChainLink Token on Astar Shibuya
Symbol | LINK
Decimals | 18
Network status | portal.astar.network/shibuya-testnet/dashboard

## Avalanche

### Avalanche Mainnet
AVAX is used to pay for transactions on Avalanche Mainnet. Use the Avalanche Bridge to transfer LINK from Ethereum Mainnet to Avalanche.

Parameter | Value
--- | ---
Chain ID | 43114
Address | 0x5947BB275c521040051D82396192181b413227A3
Name | Chainlink Token on Avalanche Mainnet
Symbol | LINK
Decimals | 18
Network status | status.avax.network

### Avalanche Fuji Testnet
Testnet AVAX is used to pay for transactions on Avalanche Fuji.

Testnet AVAX and LINK are available at faucets.chain.link/fuji. Testnet AVAX is also available at core.app/tools/testnet-faucet.

Parameter | Value
--- | ---
Chain ID | 43113
Address | 0x0b9d5D9136855f6FEc3c0993feE6E9CE8a297846
Name | Chainlink Token on Avalanche Fuji Testnet
Symbol | LINK
Decimals | 18
Network status | status.avax.network

## BASE

### BASE Mainnet
ETH is used to pay for transactions on BASE. You can use the BASE Bridge to transfer ETH from Ethereum Mainnet to BASE Mainnet. To transfer LINK from Ethereum to Base, use Transporter or XSwap Bridge.

Parameter | Value
--- | ---
Chain ID | 8453
Address | 0x88Fb150BDc53A65fe94Dea0c9BA0a6dAf8C6e196
Name | Chainlink Token on BASE Mainnet
Symbol | LINK
Decimals | 18
Network status | basescan.org

### BASE Sepolia Testnet
Testnet ETH is used to pay for transactions on BASE Sepolia.

Testnet ETH and LINK are available at faucets.chain.link/base-sepolia. Testnet ETH is also available from one of the BASE Network Faucets.

Parameter | Value
--- | ---
Chain ID | 84532
Address | 0xE4aB69C077896252FAFBD49EFD26B5D171A32410
Name | Chainlink Token on BASE Sepolia Testnet
Symbol | LINK
Decimals | 18
Network status | sepolia.basescan.org

## Berachain

### Berachain Mainnet

Parameter | Value
--- | ---
Chain ID | 80094
Address | 0x71052BAe71C25C78E37fD12E5ff1101A71d9018F
Name | Chainlink Token on Berachain Mainnet
Symbol | LINK
Decimals | 18

### Berachain Bartio Testnet

Parameter | Value
--- | ---
Chain ID | 80084
Address | 0x52CEEed7d3f8c6618e4aaD6c6e555320d0D83271
Name | ChainLink Token on Berachain Bartio Testnet
Symbol | LINK
Decimals | 18

## Bitlayer

### Bitlayer Mainnet

Parameter | Value
--- | ---
Chain ID | 200901
Address | 0x56B275c0Ec034a229a1deD8DB17089544bc276D9
Name | Chainlink Token on Bitlayer Mainnet
Symbol | LINK
Decimals | 18
Network status | bitlayer.org

### Bitlayer Testnet
Testnet LINK are available at faucets.chain.link/bitlayer-testnet.

Parameter | Value
--- | ---
Chain ID | 200810
Address | 0x2A5bACb2440BC17D53B7b9Be73512dDf92265e48
Name | Chainlink Token on Bitlayer Testnet
Symbol | LINK
Decimals | 18
Network status | bitlayer.org

## Blast

### Blast Mainnet
ETH is used to pay for transactions on Blast. You can use the Blast Bridge to transfer ETH from Ethereum Mainnet to Blast Mainnet.

Parameter | Value
--- | ---
Chain ID | 81457
Address | 0x93202eC683288a9EA75BB829c6baCFb2BfeA9013
Name | Chainlink Token on Blast Mainnet
Symbol | LINK
Decimals | 18
Network status | blastscan.io

### Blast Sepolia Testnet
Testnet ETH is used to pay for transactions on Blast Sepolia. Testnet ETH is available from one of the Blast Network Faucets. Testnet ETH and LINK are also available at faucets.chain.link/blast-sepolia.

Parameter | Value
--- | ---
Chain ID | 168587773
Address | 0x02c359ebf98fc8BF793F970F9B8302bb373BdF32
Name | Chainlink Token on Blast Sepolia Testnet
Symbol | LINK
Decimals | 18
Network status | sepolia.blastscan.io

## BNB Chain

### BNB Chain Mainnet
BNB is used to pay for transactions on the BNB Chain Mainnet.

[Image: caution]ERC-677 LINK on BNB Chain

The LINK provided by the BNB Chain Bridge is not ERC-677
compatible, so you cannot use it with Chainlink services or oracle nodes. Use the

[Chainlink PegSwap service](https://pegswap.chain.link/)to convert bridged LINK to the official ERC-677 LINK token on BNB Chain.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
Parameter | Value
--- | ---
Chain ID | 56
Address | 0x404460C6A5EdE2D891e8297795264fDe62ADBB75
Name | Chainlink Token on BNB Chain Mainnet
Symbol | LINK
Decimals | 18
Network status | bscscan.freshstatus.io

### BNB Chain Testnet
Testnet BNB is used to pay for transactions on the BNB Chain testnet. Testnet BNB is available at testnet.bnbchain.org/faucet-smart.

Testnet Native and LINK is available at faucets.chain.link/bnb-chain-testnet.

Parameter | Value
--- | ---
Chain ID | 97
Address | 0x84b9B910527Ad5C03A9Ca831909E21e236EA7b06
Name | Chainlink Token on BNB Chain Testnet
Symbol | LINK
Decimals | 18
Network status | bscscan.freshstatus.io

## Bob

### Bob Mainnet

Parameter | Value
--- | ---
Chain ID | 60808
Address | 0x5aB885CDa7216b163fb6F813DEC1E1532516c833
Name | Chainlink Token on Bob Mainnet
Symbol | LINK
Decimals | 18
Network status | conduit-bob.checkly-dashboards.com

### Bob Sepolia Testnet
Testnet ETH and LINK are available at faucets.chain.link/bob-testnet.

Parameter | Value
--- | ---
Chain ID | 808813
Address | 0xcd2AfB2933391E35e8682cbaaF75d9CA7339b183
Name | Chainlink Token on Bob Sepolia Testnet
Symbol | LINK
Decimals | 18
Network status | conduit-bob.checkly-dashboards.com

## Botanix

### Botanix Mainnet

Parameter | Value
--- | ---
Chain ID | 3637
Address | 0x30e85A5c9525AD9a7A0FA5C74df4Baf0b01aD241
Name | Chainlink Token
Symbol | LINK
Decimals | 18

### Botanix Testnet
Testnet Native and LINK are available at faucets.chain.link/botanix-testnet.

Parameter | Value
--- | ---
Chain ID | 3636
Address | 0x7311DED199CC28D80E58e81e8589aa160199FCD2
Name | Chainlink Token on Botanix Testnet
Symbol | LINK
Decimals | 18

## Bsquared

### Bsquared Mainnet
BTC is used to pay for transactions on Bsquared Mainnet.

Parameter | Value
--- | ---
Chain ID | 223
Address | 0x709229D9587886a1eDFeE6b5cE636E1D70d1cE39
Name | Chainlink Token on Bsquared Mainnet
Symbol | LINK
Decimals | 18
Network status | explorer.bsquared.network

### Bsquared Testnet
Testnet BTC is used to pay for transactions on Bsquared Testnet.

Testnet BTC and LINK are available at faucets.chain.link/bsquared-testnet.

Parameter | Value
--- | ---
Chain ID | 1123
Address | 0x436a1907D9e6a65E6db73015F08f9C66F6B63E45
Name | Chainlink Token on Bsquared Testnet
Symbol | LINK
Decimals | 18
Network status | testnet-explorer.bsquared.network

## Celo

### Celo Mainnet
CELO is used to pay for transactions on the Celo network.

Parameter | Value
--- | ---
Chain ID | 42220
Address | 0xd07294e6E917e07dfDcee882dd1e2565085C2ae0
Name | Chainlink Token on Celo Mainnet
Symbol | LINK
Decimals | 18
Network status | explorer.celo.org

### Celo Alfajores Testnet
Testnet CELO is used to pay for transactions on Celo Alfajores. Testnet CELO is available from the Alfajores Token Faucet.

Testnet Native and LINK is available at faucets.chain.link/celo-alfajores-testnet.

Parameter | Value
--- | ---
Chain ID | 44787
Address | 0x32E08557B14FaD8908025619797221281D439071
Name | Chainlink Token on Celo Alfajores Testnet
Symbol | LINK
Decimals | 18
Network status | explorer.celo.org/alfajores

## Core

### Core Mainnet

Parameter | Value
--- | ---
Chain ID | 1116
Address | 0x3902228D6A3d2Dc44731fD9d45FeE6a61c722D0b
Name | Chainlink Token on Core Mainnet
Symbol | LINK
Decimals | 18

## Corn

### Corn Mainnet

Parameter | Value
--- | ---
Chain ID | 21000000
Address | 0x7311DED199CC28D80E58e81e8589aa160199FCD2
Name | Chainlink Token on Corn Mainnet
Symbol | LINK
Decimals | 18

### Corn Testnet
Testnet Native and LINK is available at faucets.chain.link/corn-testnet.

Parameter | Value
--- | ---
Chain ID | 21000001
Address | 0x996EfAb6011896Be832969D91E9bc1b3983cfdA1
Name | Chainlink Token on Corn Testnet
Symbol | LINK
Decimals | 18

## Cronos

### Cronos Mainnet

Parameter | Value
--- | ---
Chain ID | 25
Address | 0x8c80A01F461f297Df7F9DA3A4f740D7297C8Ac85
Name | Chainlink Token
Symbol | LINK
Decimals | 18

### Cronos Testnet

Parameter | Value
--- | ---
Chain ID | 338
Address | 0x2896e619Fa7c831A7E52b87EffF4d671bEc6B262
Name | Chainlink Token on Cronos Testnet
Symbol | LINK
Decimals | 18

## Cronos zkEVM

### Cronos zkEVM Mainnet

Parameter | Value
--- | ---
Chain ID | 388
Address | 0x61170ca9fB9cF98d4c7d684e07be6D969D59667E
Name | Chainlink Token on Cronos zkEVM Mainnet
Symbol | LINK
Decimals | 18

### Cronos zkEVM Testnet

Parameter | Value
--- | ---
Chain ID | 240
Address | 0xB96217A159cB11Bc51E87c8CAe46C7dF8826A827
Name | Chainlink Token on Cronos zkEVM Testnet
Symbol | LINK
Decimals | 18

## Ethereum

### Ethereum Mainnet
ETH is used to pay for transactions on Ethereum Mainnet.

Parameter | Value
--- | ---
Chain ID | 1
Address | 0x514910771AF9Ca656af840dff83E8264EcF986CA
Name | Chainlink Token on Ethereum Mainnet
Symbol | LINK
Decimals | 18
Network status | ethstats.dev

### Sepolia Testnet
Testnet ETH is used to pay for transactions on Sepolia.

Testnet ETH and LINK are available at faucets.chain.link/sepolia.

Parameter | Value
--- | ---
Chain ID | 11155111
Address | 0x779877A7B0D9E8603169DdbD7836e478b4624789
Name | Chainlink Token on Ethereum Sepolia Testnet
Symbol | LINK
Decimals | 18
Network status | etherscan.freshstatus.io

### Ethereum Holesky Testnet
Testnet ETH is used to pay for transactions on Holesky.

Testnet ETH and LINK are available at faucets.chain.link/holesky.

Parameter | Value
--- | ---
Chain ID | 17000
Address | 0x685cE6742351ae9b618F383883D6d1e0c5A31B4B
Name | Chainlink Token on Ethereum Holesky Testnet
Symbol | LINK
Decimals | 18
Network status | etherscan.freshstatus.io

## Etherlink

### Etherlink Mainnet

Parameter | Value
--- | ---
Chain ID | 42793
Address | 0x8ce7618E8f8E514d13889283F58FF03B794e6CC3
Name | Chainlink Token on Etherlink Mainnet
Symbol | LINK
Decimals | 18

### Etherlink Testnet

Parameter | Value
--- | ---
Chain ID | 128123
Address | 0xE02E6E94d4a5E215F308bDd564a1B6f13AA56950
Name | Chainlink Token on Etherlink Testnet
Symbol | LINK
Decimals | 18

## Fantom

### Fantom Mainnet
FTM is used to pay for transactions on Fantom Mainnet.

[Image: caution]ERC-677 LINK on Fantom

You must use ERC-677 LINK on Fantom. ERC-20 LINK will not work with Chainlink services.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
Parameter | Value
--- | ---
Chain ID | 250
Address | 0x6F43FF82CCA38001B6699a8AC47A2d0E66939407
Name | Chainlink Token on Fantom Mainnet
Symbol | LINK
Decimals | 18
Network status | ftmscan.freshstatus.io

### Fantom Testnet
Testnet FTM is used to pay for transactions on Fantom testnet. Testnet FTM is available at faucet.fantom.network.

Testnet LINK is available at faucets.chain.link/fantom-testnet.

Parameter | Value
--- | ---
Chain ID | 4002
Address | 0xfaFedb041c0DD4fA2Dc0d87a6B0979Ee6FA7af5F
Name | Chainlink Token on Fantom Testnet
Symbol | LINK
Decimals | 18
Network status | ftmscan.freshstatus.io

## Fraxtal

### Fraxtal Mainnet

Parameter | Value
--- | ---
Chain ID | 252
Address | 0xd6A6ba37fAaC229B9665E86739ca501401f5a940
Name | Chainlink Token on Fraxtal Mainnet
Symbol | LINK
Decimals | 18

### Fraxtal Testnet

Parameter | Value
--- | ---
Chain ID | 2522
Address | 0xb192c5Fb8e33694F0CFD4357806a63dc59feEBEF
Name | Chainlink Token on Fraxtal Testnet
Symbol | LINK
Decimals | 18

## Gnosis Chain (xDai)

### Gnosis Chain Mainnet
xDAI is used to pay for transactions on Gnosis Chain Mainnet. Use the xDai Bridge to send DAI from Ethereum Mainnet to Gnosis Chain and convert it to xDAI. Use OmniBridge to send LINK from Ethereum Mainnet to Gnosis Chain.

Parameter | Value
--- | ---
Chain ID | 100
Address | 0xE2e73A1c69ecF83F464EFCE6A5be353a37cA09b2
Name | Chainlink Token on Gnosis Chain (xDai) Mainnet
Symbol | LINK
Decimals | 18
Network status | gnosisscan.freshstatus.io

### Gnosis Chiado Testnet
xDAI is used to pay for transactions on Gnosis Chiado testnet. Use the Chiado faucet to get testnet xDAI.

Testnet Native and LINK is available at faucets.chain.link/gnosis-chiado-testnet.

Parameter | Value
--- | ---
Chain ID | 10200
Address | 0xDCA67FD8324990792C0bfaE95903B8A64097754F
Name | Chainlink Token on Gnosis Chiado Testnet
Symbol | LINK
Decimals | 18
Network status | gnosisscan.freshstatus.io

## HashKey

### HashKey Chain Mainnet

Parameter | Value
--- | ---
Chain ID | 177
Address | 0x71052BAe71C25C78E37fD12E5ff1101A71d9018F
Name | Chainlink Token on HashKey Chain Mainnet
Symbol | LINK
Decimals | 18

### HashKey Chain Testnet

Parameter | Value
--- | ---
Chain ID | 133
Address | 0x8418c4d7e8e17ab90232DC72150730E6c4b84F57
Name | Chainlink Token on HashKey Testnet
Symbol | LINK
Decimals | 18

## Hedera

### Hedera Mainnet

Parameter | Value
--- | ---
Chain ID | 296
Address | 0x7ce6bb2cc2d3fd45a974da6a0f29236cb9513a98
Name | Chainlink Token
Symbol | LINK
Decimals | 18

### Hedera Testnet
Testnet HBAR is used to pay for transactions on the Hedera testnet.

Testnet Native and LINK is available at faucets.chain.link/hedera-testnet.

Parameter | Value
--- | ---
Chain ID | 296
Address | 0x90a386d59b9A6a4795a011e8f032Fc21ED6FEFb6
Name | Chainlink Token on Hedera Testnet
Symbol | LINK
Decimals | 18

## Hemi

### Hemi Mainnet

Parameter | Value
--- | ---
Chain ID | 43111
Address | 0x63dbE12A6381D64adE47bc3D92aBF4393DFF4BC8
Name | Chainlink Token
Symbol | LINK
Decimals | 18

### Hemi Sepolia Testnet

Parameter | Value
--- | ---
Chain ID | 743111
Address | 0x5246409a2e09134824c4E709602205B176491e57
Name | Chainlink Token on Hemi Sepolia Testnet
Symbol | LINK
Decimals | 18

## HyperEVM

### HyperEVM Mainnet

Parameter | Value
--- | ---
Chain ID | 999
Address | 0x1AC2EE68b8d038C982C1E1f73F596927dd70De59
Name | Chainlink Token
Symbol | LINK
Decimals | 18

### HyperEVM Testnet

Parameter | Value
--- | ---
Chain ID | 998
Address | 0xDD311DBec8A24EdFabf5F985845a75F42e8f9544
Name | Chainlink Token
Symbol | LINK
Decimals | 18

## Ink

### Ink Mainnet

Parameter | Value
--- | ---
Chain ID | 57073
Address | 0x71052BAe71C25C78E37fD12E5ff1101A71d9018F
Name | Chainlink Token on Ink Mainnet
Symbol | LINK
Decimals | 18

### Ink Sepolia Testnet

Parameter | Value
--- | ---
Chain ID | 763373
Address | 0x3423C922911956b1Ccbc2b5d4f38216a6f4299b4
Name | Chainlink Token on Ink Sepolia Testnet
Symbol | LINK
Decimals | 18

## Janction

### Janction Sepolia Testnet

Parameter | Value
--- | ---
CHAIN_ID | 679
Address | 0x7311DED199CC28D80E58e81e8589aa160199FCD2
Name | Chainlink Token on Janction Sepolia Testnet
Symbol | LINK
Decimals | 18

## Kaia

### Kaia Mainnet

Parameter | Value
--- | ---
CHAIN_ID | 8217
Address | 0x7311ded199cc28d80e58e81e8589aa160199fcd2
Name | Chainlink Token
Symbol | LINK
Decimals | 18

### Kaia Kairos Testnet

Parameter | Value
--- | ---
CHAIN_ID | 1001
Address | 0xaf3243f975afe2269da8ffa835ca3a8f8b6a5a36
Name | Chainlink Token
Symbol | LINK
Decimals | 18

## Kroma

### Kroma Mainnet
ETH is used to pay for transactions on the Kroma mainnet.

Parameter | Value
--- | ---
ETH_CHAIN_ID | 255
Address | 0xC1F6f7622ad37C3f46cDF6F8AA0344ADE80BF450
Name | Chainlink Token on Kroma Mainnet
Symbol | LINK
Decimals | 18

### Kroma Sepolia Testnet
Testnet ETH is used to pay for transactions on the Kroma testnet.

Testnet Native and LINK are available at faucets.chain.link/kroma-testnet.

Parameter | Value
--- | ---
ETH_CHAIN_ID | 2358
Address | 0xa75cCA5b404ec6F4BB6EC4853D177FE7057085c8
Name | Chainlink Token on Kroma Sepolia Testnet
Symbol | LINK
Decimals | 18

## Lens

### Lens Mainnet

Parameter | Value
--- | ---
Chain ID | 232
Address | 0x6e970e8d6758164798290c8db1D79a527ca6e1B2
Name | Chainlink Token
Symbol | LINK
Decimals | 18

### Lens Sepolia Testnet

Parameter | Value
--- | ---
Chain ID | 37111
Address | 0x7f1b9eE544f9ff9bB521Ab79c205d79C55250a36
Name | Chainlink Token on Lens Sepolia Testnet
Symbol | LINK
Decimals | 18

## Linea

### Linea Mainnet
ETH is used to pay for transactions on Linea Mainnet. Use the Linea Bridge to transfer ETH from Ethereum to Linea.

Parameter | Value
--- | ---
Chain ID | 59144
Address | 0xa18152629128738a5c081eb226335FEd4B9C95e9
Name | Chainlink Token on Linea Mainnet
Symbol | LINK
Decimals | 18
Network status | linea.statuspage.io

### Linea Sepolia Testnet
Testnet ETH is used to pay for transactions on Linea Sepolia. Testnet Native and LINK are available at faucets.chain.link/linea-sepolia.

Parameter | Value
--- | ---
Chain ID | 59141
Address | 0xF64E6E064a71B45514691D397ad4204972cD6508
Name | Chainlink Token on Linea Sepolia Testnet
Symbol | LINK
Decimals | 18
Network status | linea.statuspage.io

## Lisk

### Lisk Mainnet

Parameter | Value
--- | ---
Chain ID | 1135
Address | 0x71052BAe71C25C78E37fD12E5ff1101A71d9018F
Name | Chainlink Token
Symbol | LINK
Decimals | 18

### Lisk Sepolia Testnet

Parameter | Value
--- | ---
Chain ID | 4202
Address | 0x6641415a61bCe80D97a715054d1334360Ab833Eb
Name | Chainlink Token
Symbol | LINK
Decimals | 18

## Mantle

### Mantle Mainnet
MNT is used to pay for transactions on the Mantle mainnet.

Parameter | Value
--- | ---
ETH_CHAIN_ID | 5000
Address | 0xfe36cF0B43aAe49fBc5cFC5c0AF22a623114E043
Name | ChainLink Token on Mantle Mainnet
Symbol | LINK
Decimals | 18

### Mantle Sepolia Testnet
Testnet ETH is used to pay for transactions on the Mantle Sepolia testnet.

Testnet Native and LINK are available at faucets.chain.link/mantle-sepolia.

Parameter | Value
--- | ---
ETH_CHAIN_ID | 5003
Address | 0x22bdEdEa0beBdD7CfFC95bA53826E55afFE9DE04
Name | ChainLink Token on Mantle Sepolia Testnet
Symbol | LINK
Decimals | 18

## MegaEth

### MegaEth Testnet

Parameter | Value
--- | ---
Chain ID | 6342
Address | 0x4d03398C2588D92B220578dAEde29814E41c8033
Name | Chainlink Token
Symbol | LINK
Decimals | 18

## Merlin

### Merlin Mainnet

Parameter | Value
--- | ---
Chain ID | 4200
Address | 0x71052BAe71C25C78E37fD12E5ff1101A71d9018F
Name | Chainlink Token on Merlin Mainnet
Symbol | LINK
Decimals | 18

### Merlin Testnet

Parameter | Value
--- | ---
Chain ID | 686868
Address | 0xB904d5b9a1e74F6576fFF550EeE75Eaa68e2dd50
Name | Chainlink Token on Merlin Testnet
Symbol | LINK
Decimals | 18

## Metal

### Metal Mainnet

Parameter | Value
--- | ---
Chain ID | 1750
Address | 0x587d19DDF735D6B536aAdB1a2A92938eB23B8d5C
Name | Chainlink Token
Symbol | LINK
Decimals | 18

### Metal L2 Testnet

Parameter | Value
--- | ---
Chain ID | 1740
Address | 0x7ECBE3416d92E8d79C8e5d8EB8Aad5DdEdAa0237
Name | Chainlink Token
Symbol | LINK
Decimals | 18

## Metis

### Metis Mainnet
METIS is used to pay for transactions on Metis Mainnet. You can use the Metis Bridge to transfer METIS from Ethereum Mainnet to Metis Mainnet.

[Image: caution]ERC-677 LINK on Metis

The LINK provided by the Metis Bridge is not ERC-677 compatible, so you cannot use it with
Chainlink services or oracle nodes.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
Parameter | Value
--- | ---
Chain ID | 1088
Address | 0xd2FE54D1E5F568eB710ba9d898Bf4bD02C7c0353
Name | Chainlink Token on Metis Mainnet
Symbol | LINK
Decimals | 18
Network status | explorer.metis.io

### Metis Sepolia Testnet
Testnet METIS is used to pay for transactions on Metis Sepolia.

Testnet METIS and LINK are available at faucets.chain.link/metis-sepolia.

Parameter | Value
--- | ---
Chain ID | 59902
Address | 0x9870D6a0e05F867EAAe696e106741843F7fD116D
Name | Chainlink Token on Metis Sepolia Testnet
Symbol | LINK
Decimals | 18
Network status | sepolia-explorer.metisdevops.link

## Mind Network

### Mind Network Mainnet

Parameter | Value
--- | ---
ETH_CHAIN_ID | 228
Address | 0xd8A9246e84903e82CA01e42774b01A7CdD465BFa
Name | Chainlink Token
Symbol | LINK
Decimals | 18

### Mind Network Testnet

Parameter | Value
--- | ---
ETH_CHAIN_ID | 192940
Address | 0xE0352dEd874c3E72d922CE533E136385fBE4a9B4
Name | Chainlink Token
Symbol | LINK
Decimals | 18

## Mint

### Mint Mainnet

Parameter | Value
--- | ---
Chain ID | 185
Address | 0x71052BAe71C25C78E37fD12E5ff1101A71d9018F
Name | Chainlink Token
Symbol | LINK
Decimals | 18

### Mint Sepolia Testnet

Parameter | Value
--- | ---
Chain ID | 1687
Address | 0x7ECBE3416d92E8d79C8e5d8EB8Aad5DdEdAa0237
Name | Chainlink Token
Symbol | LINK
Decimals | 18

## Mode

### Mode Mainnet
ETH is used to pay for transactions on the Mode mainnet.

Parameter | Value
--- | ---
ETH_CHAIN_ID | 34443
Address | 0x183E3691EfF3524B2315D3703D94F922CbE51F54
Name | Chainlink Token on Mode Mainnet
Symbol | LINK
Decimals | 18

### Mode Sepolia Testnet
Testnet ETH is used to pay for transactions on the Mode testnet.

Testnet ETH and LINK are available at faucets.chain.link/mode-sepolia.

Parameter | Value
--- | ---
ETH_CHAIN_ID | 919
Address | 0x925a4bfE64AE2bFAC8a02b35F78e60C29743755d
Name | Chainlink Token on Mode Sepolia Testnet
Symbol | LINK
Decimals | 18

## Monad

### Monad Testnet

Parameter | Value
--- | ---
Chain ID | 10143
Address | 0x6fE981Dbd557f81ff66836af0932cba535Cbc343
Name | Chainlink Token on Monad Testnet
Symbol | LINK
Decimals | 18

## Moonbeam

### Moonbeam Mainnet
GLMR is used to pay transaction fees on Moonbeam Mainnet.

Parameter | Value
--- | ---
Chain ID | 1284
Address | 0x012414A392F9FA442a3109f1320c439C45518aC3
Name | Chainlink Token on Moonbeam Mainnet
Symbol | LINK
Decimals | 18
Network status | moonscan.freshstatus.io

## Moonriver

### Moonriver Mainnet
MOVR is used to pay transaction fees on Moonriver Mainnet.

Parameter | Value
--- | ---
Chain ID | 1285
Address | 0x8b12Ac23BFe11cAb03a634C1F117D64a7f2cFD3e
Name | Chainlink Token on Moonriver Mainnet
Symbol | LINK
Decimals | 18
Network status | moonscan.freshstatus.io

## Neo X

### Neo X Mainnet

Parameter | Value
--- | ---
Chain ID | 47763
Address | 0xb25de57d73AB177FC091327Bcb725154dFBb5bFB
Name | Chainlink Token on Neo X Mainnet
Symbol | LINK
Decimals | 18

### Neo X Testnet

Parameter | Value
--- | ---
Chain ID | 12227332
Address | 0x7F85bAC57B5D4b81F866F495c30AB8C8c453f6FD
Name | Chainlink Token on Neo X Testnet
Symbol | LINK
Decimals | 18

## OPBNB

### OPBNB Mainnet

Parameter | Value
--- | ---
Chain ID | 204
Address | 0x99f0d88B81b758AB07E22C7AbA00E0121a882dEA
Name | Chainlink Token
Symbol | LINK
Decimals | 18

### OPBNB Testnet

Parameter | Value
--- | ---
Chain ID | 5611
Address | 0x56E16E648c51609A14Eb14B99BAB771Bee797045
Name | Chainlink Token
Symbol | LINK
Decimals | 18

## OP

### OP Mainnet
ETH is used to pay for transactions on OP. Use the OP Bridge to transfer ETH and LINK from Ethereum Mainnet to OP Mainnet.

Parameter | Value
--- | ---
Chain ID | 10
Address | 0x350a791Bfc2C21F9Ed5d10980Dad2e2638ffa7f6
Name | Chainlink Token on OP Mainnet
Symbol | LINK
Decimals | 18
Network status | status.optimism.io

### OP Sepolia Testnet
Testnet ETH is used to pay for transactions on OP Sepolia. Use the OP Bridge to transfer testnet ETH from Ethereum Sepolia to OP Sepolia. Testnet ETH is available at faucets.chain.link/sepolia.

Testnet Native and LINK is available at faucets.chain.link/optimism-sepolia. Testnet bridges might not transfer the correct type of LINK to OP Sepolia, so it is recommended to use only the LINK acquired from faucets.chain.link/optimism-sepolia when developing applications on testnet.

Parameter | Value
--- | ---
Chain ID | 11155420
Address | 0xE4aB69C077896252FAFBD49EFD26B5D171A32410
Name | Chainlink Token on OP Sepolia Testnet
Symbol | LINK
Decimals | 18
Network status | status.optimism.io

## Plume

### Plume Mainnet

Parameter | Value
--- | ---
Chain ID | 98866
Address | 0xb549B375dA0c76f8b3877B9aDfDD28378f087A64
Name | Chainlink Token
Symbol | LINK
Decimals | 18

### Plume Testnet

Parameter | Value
--- | ---
Chain ID | 98867
Address | 0xB97e3665AEAF96BDD6b300B2e0C93C662104A068
Name | Chainlink Token
Symbol | LINK
Decimals | 18
 | 

## Polygon

### Polygon Mainnet
POL is used to pay for transactions on Polygon. You can use the Polygon Bridge to transfer tokens to Polygon Mainnet and then use Polygon Gas Swap to swap supported tokens to POL.

[Image: caution]ERC-677 LINK on Polygon

The LINK provided by the Polygon Bridge is not ERC-677
compatible, so you cannot use it with Chainlink services or oracle nodes. Use the

[Chainlink PegSwap service](https://pegswap.chain.link/)to convert bridged LINK to the official ERC-677 LINK token on Polygon.

Watch the Moving Chainlink Cross-Chains video to learn more.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
Parameter | Value
--- | ---
Chain ID | 137
Address | 0xb0897686c545045aFc77CF20eC7A532E3120E0F1
Name | Chainlink Token on Polygon Mainnet
Symbol | LINK
Decimals | 18
Network status | polygonscan.freshstatus.io

### Polygon Amoy Testnet
Testnet POL is used to pay for transactions on Polygon Amoy.

Testnet POL and LINK are available at faucets.chain.link/polygon-amoy.

Parameter | Value
--- | ---
Chain ID | 80002
Address | 0x0Fd9e8d3aF1aaee056EB9e802c3A762a667b1904
Name | Chainlink Token on Polygon Amoy Testnet
Symbol | LINK
Decimals | 18
Network status | polygonscan.freshstatus.io

## Polygon Katana

### Polygon Katana Mainnet

Parameter | Value
--- | ---
Chain ID | 747474
Address | 0xc2C447b04e0ED3476DdbDae8E9E39bE7159d27b6
Name | Chainlink Token
Symbol | LINK
Decimals | 18

### Polygon Katana Tatara Testnet

Parameter | Value
--- | ---
Chain ID | 129399
Address | 0x29261B6Fb93097885bEB714ee253Da63A52dFc46
Name | Chainlink Token on Polygon Katana Takara Testnet
Symbol | LINK
Decimals | 18

## Polygon zkEVM

### Polygon zkEVM Mainnet
ETH is used to pay for transactions on Polygon zkEVM. Use the Polygon zkEVM Bridge to transfer ETH and LINK to Polygon zkEVM.

Parameter | Value
--- | ---
ETH_CHAIN_ID | 1101
Address | 0xdB7A504CF869484dd6aC5FaF925c8386CBF7573D
Name | Chainlink Token on Polygon zkEVM Mainnet
Symbol | LINK
Decimals | 18

### Polygon zkEVM Cardona Testnet
Testnet ETH is used to pay for transactions on Polygon zkEVM Cardona testnet. Use the Polygon zkEVM Bridge to transfer testnet ETH to Polygon zkEVM testnet.

Testnet ETH and LINK are available at faucets.chain.link/polygon-zkevm-cardona.

Parameter | Value
--- | ---
ETH_CHAIN_ID | 2442
Address | 0x5576815a38A3706f37bf815b261cCc7cCA77e975
Name | Chainlink Token on Polygon zkEVM Cardona Testnet
Symbol | LINK
Decimals | 18

## Ronin

### Ronin Mainnet
RON is used to pay for transactions on Ronin Mainnet.

Parameter | Value
--- | ---
Chain ID | 2020
Address | 0x3902228D6A3d2Dc44731fD9d45FeE6a61c722D0b
Name | Chainlink Token on Ronin Mainnet
Symbol | LINK
Decimals | 18
Network status | app.roninchain.com

### Ronin Saigon Testnet
Testnet RON is used to pay for transactions on Ronin Saigon.

Testnet Native and LINK are available at faucets.chain.link/ronin-saigon.

Parameter | Value
--- | ---
Chain ID | 2021
Address | 0x5bB50A6888ee6a67E22afFDFD9513be7740F1c15
Name | Chainlink Token on Ronin Saigon Testnet
Symbol | LINK
Decimals | 18
Network status | app.roninchain.com

## Rootstock

### Rootstock Mainnet

Parameter | Value
--- | ---
Chain ID | 30
Address | 0x938D84942f5D924070A6bb82F8e56a5E2b3098A4
Name | Chainlink Token on Rootstock Mainnet
Symbol | LINK
Decimals | 18

### Rootstock Testnet

Parameter | Value
--- | ---
Chain ID | 31
Address | 0x39dD98CcCC3a51b2c0007e23517488e363581264
Name | Chainlink Token on Rootstock Testnet
Symbol | LINK
Decimals | 18

## Scroll

### Scroll Mainnet
ETH is used to pay for transactions on Scroll Mainnet. Use the Scroll Bridge to transfer ETH from Ethereum to Scroll.

Parameter | Value
--- | ---
Chain ID | 534352
Address | 0x548C6944cba02B9D1C0570102c89de64D258d3Ac
Name | Chainlink Token on Scroll Mainnet
Symbol | LINK
Decimals | 18
Network status | status.scroll.io

### Scroll Sepolia Testnet
Testnet ETH is used to pay for transactions on Scroll testnet.

Testnet ETH and LINK are available at faucets.chain.link/scroll-sepolia-testnet. Testnet ETH is also available from the Scroll Sepolia Faucets.

Parameter | Value
--- | ---
Chain ID | 534351
Address | 0x231d45b53C905c3d6201318156BDC725c9c3B9B1
Name | Chainlink Token on Scroll Sepolia Testnet
Symbol | LINK
Decimals | 18
Network status | status.scroll.io

## Sei

### Sei Network

Parameter | Value
--- | ---
ETH_CHAIN_ID | 1329
Address | ?chain=pacific-1
Name | Chainlink Token on Sei Network
Symbol | LINK
Decimals | 18

### Sei Testnet
Testnet Native and LINK are available at faucets.chain.link/sei-testnet.

Parameter | Value
--- | ---
ETH_CHAIN_ID | 1328
Address | 0xA9d21ed8260DE08fF39DC5e7B65806d4e1CB817B?chain=atlantic-2
Name | Chainlink Token on Sei Testnet
Symbol | LINK
Decimals | 18

## Shibarium

### Shibarium Mainnet
BONE is used to pay for transactions on Shibarium Mainnet.

Parameter | Value
--- | ---
Chain ID | 109
Address | 0x71052BAe71C25C78E37fD12E5ff1101A71d9018F
Name | Chainlink Token on Shibarium Mainnet
Symbol | LINK
Decimals | 18
Network status | explorer.shibariumscan.io

### Shibarium Puppynet
Testnet BONE is used to pay for transactions on Shibarium Puppynet.

Testnet Native and LINK are available at faucets.chain.link/shibarium-puppynet.

Parameter | Value
--- | ---
Chain ID | 157
Address | 0x44637eEfD71A090990f89faEC7022fc74B2969aD
Name | Chainlink Token on Shibarium Puppynet
Symbol | LINK
Decimals | 18
Network status | puppyscan.shib.io

## Solana

### Solana Mainnet
SOL is used to pay for transactions on the Solana network.

Parameter | Value
--- | ---
Chain ID | mainnet
Address | LinkhB3afbBKb2EQQu7s7umdZceV3wcvAUJhQAfQ23L
Name | Chainlink Token
Symbol | LINK
Decimals | 9
Network status | status.solana.com/

### Solana Devnet

Parameter | Value
--- | ---
Chain ID | devnet
Address | LinkhB3afbBKb2EQQu7s7umdZceV3wcvAUJhQAfQ23L
Name | Chainlink Token
Symbol | LINK
Decimals | 9

## Soneium

### Soneium Mainnet

Parameter | Value
--- | ---
ETH_CHAIN_ID | 1868
Address | 0x32D8F819C8080ae44375F8d383Ffd39FC642f3Ec
Name | Chainlink Token on Soneium Mainnet
Symbol | LINK
Decimals | 18

### Soneium Minato Testnet
Testnet ETH is used to pay for transactions on the Soneium Minato testnet. Testnet Native and LINK are available at faucets.chain.link/soneium-minato.

Parameter | Value
--- | ---
ETH_CHAIN_ID | 1946
Address | 0x7ea13478Ea3961A0e8b538cb05a9DF0477c79Cd2
Name | Chainlink Token on Soneium Minato Testnet
Symbol | LINK
Decimals | 18

## Sonic

### Sonic Mainnet
S is used to pay for transactions on Sonic mainnet.

Parameter | Value
--- | ---
ETH_CHAIN_ID | 146
Address | 0x71052BAe71C25C78E37fD12E5ff1101A71d9018F
Name | Chainlink Token on Sonic Mainnet
Symbol | LINK
Decimals | 18

### Sonic Blaze Testnet
Testnet S is used to pay for transactions on Sonic Blaze testnet.

Parameter | Value
--- | ---
ETH_CHAIN_ID | 57054
Address | 0xd8C1eEE32341240A62eC8BC9988320bcC13c8580
Name | Chainlink Token on Sonice Blaze Testnet
Symbol | LINK
Decimals | 18

## Starknet

### Starknet Mainnet

Parameter | Value
--- | ---
Chain ID | SN_MAIN
Address | 0x060f47b96b525c1014fed595e87e98edc3ce0731627a0670e1804ee1a3ca0ee9
Name | Chainlink Token on Starknet Mainnet
Symbol | LINK
Decimals | 18

## Superseed

### Superseed Mainnet

Parameter | Value
--- | ---
Chain ID | 5330
Address | 0x41Ccf59e3F30EB624eF8E5Ea34b2da96bee472d9
Name | Chainlink Token
Symbol | LINK
Decimals | 18

### Superseed Sepolia Testnet

Parameter | Value
--- | ---
Chain ID | 53302
Address | 0xA3063eE34d9B4E407DF0E153c9bE679680e3A956
Name | Chainlink Token
Symbol | LINK
Decimals | 18

## TAC

### TAC Mainnet

Parameter | Value
--- | ---
Chain ID | 239
Address | 0xc2BE2F77562A6676098e8D363B9d8A33Ea009D4e
Name | Chainlink Token
Symbol | LINK
Decimals | 18

### TAC Saint Petersburg Testnet

Parameter | Value
--- | ---
Chain ID | 2391
Address | 0xe5e3a4fF1773d043a387b16Ceb3c91cC49bAFD54
Name | Chainlink Token
Symbol | LINK
Decimals | 18

## Taiko

### Taiko Alethia

Parameter | Value
--- | ---
Chain ID | 167000
Address | 0x917a3964C37993e99a47C779bEb5Db1E9d13804d
Name | Chainlink Token
Symbol | LINK
Decimals | 18

### Taiko Hekla Testnet

Parameter | Value
--- | ---
Chain ID | 167009
Address | 0x01fcdEedbA59bc68b0914D92277678dAB6827e2c
Name | Chainlink Token
Symbol | LINK
Decimals | 18

## Treasure

### Treasure Mainnet

Parameter | Value
--- | ---
Chain ID | 61166
Address | 0xC74eAEf00bE07C6C8A28feAa54e50942efEDF02A
Name | Chainlink Token on Treasure Mainnet
Symbol | LINK
Decimals | 18

### Treasure Topaz Testnet

Parameter | Value
--- | ---
Chain ID | 978658
Address | 0x0FE9fAAF3e26f756443fd8f92F6711989a8e0fF5
Name | Chainlink Token on Treasure Topaz Testnet
Symbol | LINK
Decimals | 18

## Unichain

### Unichain Mainnet

Parameter | Value
--- | ---
Chain ID | 130
Address | 0xEF66491eab4bbB582c57b14778afd8dFb70D8A1A
Name | Chainlink Token on Unichain Mainnet
Symbol | LINK
Decimals | 18

### Unichain Sepolia Testnet
Testnet Native and LINK are available at faucets.chain.link/unichain-testnet.

Parameter | Value
--- | ---
Chain ID | 1301
Address | 0xda40816f278Cd049c137F6612822D181065EBfB4
Name | Chainlink Token on Unichain Testnet
Symbol | LINK
Decimals | 18

## Wemix

### Wemix Mainnet
WEMIX is used to pay for transactions on the Wemix mainnet. To transfer LINK from Ethereum to Wemix, use Transporter.

Parameter | Value
--- | ---
ETH_CHAIN_ID | 1111
Address | 0x80f1FcdC96B55e459BF52b998aBBE2c364935d69
Name | Chainlink Token on Wemix Mainnet
Symbol | LINK
Decimals | 18

### Wemix Testnet
Testnet WEMIX is used to pay for transactions on the Wemix testnet.

Testnet Native and LINK are available at faucets.chain.link/wemix-testnet. Testnet WEMIX is also available from the WEMIX Faucet.

Parameter | Value
--- | ---
ETH_CHAIN_ID | 1112
Address | 0x3580c7A817cCD41f7e02143BFa411D4EeAE78093
Name | Chainlink Token on Wemix Testnet
Symbol | LINK
Decimals | 18

## World

### World Chain Mainnet
ETH is used to pay for transactions on World Chain Mainnet.

Parameter | Value
--- | ---
Chain ID | 480
Address | 0x915b648e994d5f31059B38223b9fbe98ae185473
Name | Chainlink Token on World Chain Mainnet
Symbol | LINK
Decimals | 18
Network status | world.org

### World Chain Sepolia Testnet
Testnet ETH is used to pay for transactions on World Chain Sepolia. Testnet Native and LINK are available at faucets.chain.link/worldchain-testnet.

Parameter | Value
--- | ---
Chain ID | 486
Address | 0xC82Ea35634BcE95C394B6BC00626f827bB0F4801
Name | Chainlink Token on World Chain Testnet
Symbol | LINK
Decimals | 18
Network status | world.org

## X Layer

### X Layer Mainnet

Parameter | Value
--- | ---
Chain ID | 196
Address | 0x8aF9711B44695a5A081F25AB9903DDB73aCf8FA9
Name | Chainlink Token on X Layer Mainnet
Symbol | LINK
Decimals | 18

### X Layer Sepolia Testnet

Parameter | Value
--- | ---
Chain ID | 195
Address | 0x724593f6FCb0De4E6902d4C55D7C74DaA2AF0E55
Name | Chainlink Token on X Layer Sepolia Testnet
Symbol | LINK
Decimals | 18

## Zircuit

### Zircuit Mainnet
ETH is used to pay for transactions on the Zircuit mainnet.

Parameter | Value
--- | ---
ETH_CHAIN_ID | 48900
Address | 0x5D6d033B4FbD2190D99D930719fAbAcB64d2439a
Name | Chainlink Token on Zircuit Mainnet
Symbol | LINK
Decimals | 18

### Zircuit Testnet
Testnet ETH is used to pay for transactions on the Zircuit testnet.

Testnet Native and LINK are available at faucets.chain.link/zircuit-sepolia.

Parameter | Value
--- | ---
ETH_CHAIN_ID | 48899
Address | 0xDEE94506570cA186BC1e3516fCf4fd719C312cCD
Name | Chainlink Token on Zircuit Testnet
Symbol | LINK
Decimals | 18

## ZKsync

### ZKsync Era Mainnet
ETH is used to pay for transactions on ZKsync Era Mainnet. Use the recommended ZKsync Bridges to transfer ETH from Ethereum to ZKsync.

Parameter | Value
--- | ---
Chain ID | 324
Address | 0x52869bae3E091e36b0915941577F2D47d8d8B534
Name | Chainlink Token on ZKsync Era Mainnet
Symbol | LINK
Decimals | 18
Network status | explorer.zksync.io

### ZKsync Sepolia Testnet
Testnet ETH is used to pay for transactions on ZKsync Sepolia testnet.

Testnet Native and LINK are available at faucets.chain.link/zksync-sepolia.

Parameter | Value
--- | ---
Chain ID | 300
Address | 0x23A1aFD896c8c8876AF46aDc38521f4432658d1e
Name | Chainlink Token on ZKsync Sepolia Testnet
Symbol | LINK
Decimals | 18
Network status | uptime.com/statuspage/zkSync

## Zora

### Zora Mainnet

Parameter | Value
--- | ---
Chain ID | 7777777
Address | 0x3662B6f73c5560229D1a98aF6e59E6649D568374
Name | Chainlink Token
Symbol | LINK
Decimals | 18

### Zora Testnet

Parameter | Value
--- | ---
Chain ID | 999999999
Address | 0xBEDDEB2DF8904cdBCFB6Bf29b91d122D5Ae4eb7e
Name | Chainlink Token
Symbol | LINK
Decimals | 18

================================================================================

# Integrating EVM Networks With Chainlink Services

Source: https://docs.chain.link/resources/network-integration
Extraction Method: playwright
Components: table(1)

# Integrating EVM Networks With Chainlink Services
Before an EVM blockchain network can integrate with Chainlink, it must meet certain technical requirements. These requirements are critical for Chainlink nodes and Chainlink services to function correctly on a given network.

[Image: note]Disclaimer

The standard EVM requirements required to integrate EVM blockchain networks with Chainlink services can vary, are
subject to change, and are provided here for reference purposes only. Chainlink services may have unique requirements
that are in addition to the requirements discussed herein.

.asideContent a,
  .asideContent a > code:not([class*="language"]) {
    color: var(--color-text-link);
    text-decoration: underline;
  }

  .theme-dark .asideContent code:not([class*="language"]) {
    color: var(--theme-code-text);
  }

  .asideContent p,
  .asideContent li {
    color: var(--theme-text-light);
    line-height: 1.5;
    font-size: 14px;
  }

  .asideContent p {
    margin-bottom: 0;
  }

  .asideContent p + p {
    margin-top: var(--space-2x);
  }

  .asideContent p + :is(ul, ol) {
    margin-top: var(--space-1x);
  }

  .asideContent li {
    margin-top: var(--space-1x);
  }

  .asideContent pre {
    margin-left: 0;
    margin-right: 0;
  }
## Standard EVM requirements

### Solidity global variables and opcode implementation
Solidity global variables and opcode implementation constructs must meet the following requirements in order for Chainlink services to operate correctly and as expected:

• Global variables: Support all global variables as specified in the Solidity Block and Transaction Properties documentation. For example, the following variables must be supported:

block.blockhash must return the hash of the requested block for the last 256 blocks
block.number must return the respective chain's block number
block.chainID must return the current chain ID
block.timestamp must return the current block timestamp as seconds since unix epoch
• Opcodes: Support all opcodes and expected behaviors from the OpCodes.sol contract
• Precompiles: Must support all precompile contracts and expected behaviors listed in the Solidity Mathematical and Cryptographic Functions documentation
• Contract size: Must support the maximum contract size defined in EIP-170
• Nonce: The transaction nonce must increase as transactions are confirmed and propagated to all nodes in the network.

### Finality
Blockchain development teams must ensure that blocks with a commitment level of finalized are actually final. The properties of the finality mechanism, including underlying assumptions and conditions under which finality violations could occur, must be clearly documented and communicated to application developers in the blockchain ecosystem.

Furthermore, this information should be accessible through RPC API tags finalized from the JSON-RPC specification tags described later in this document.

### Standardized RPCs with SLAs
Chainlink nodes use RPCs to communicate with the chain and perform soak testing. It is not possible to ensure the functionality of Chainlink services if RPCs are unstable, underperforming, or nonexistent. RPCs must meet the following requirements:

Dedicated RPC node:

• The chain must provide instructions and hardware requirements to set up and run a full node.
• The archive node setup must also be provided and allow queries of blocks from genesis with transaction history and logs.
• The RPC node must enable and allow configurable settings for the following items:

Batch calls
Log lookbacks
HTTPS and WSS connections

RPC providers:

• Three separate independent RPC providers must be available.
• RPC providers must ensure there is no rate limit.
• RPC providers must have a valid SSL certificate.
• During the trailing 30 days, the RPC providers must meet the following RPC performance requirements:

Uptime: At least 99.9%
Throughput: Support at least 300 calls per second
Latency: Less than 250ms
Support SLA: For SEV1 issues, provide a Time to Answer (TTA) of at most 1 hour

### Support the Ethereum JSON-RPC Specification
The chain must support the Ethereum JSON-RPC Specification. Chainlink services use several methods to operate on the chain and require a specific response format to those calls in line with the JSON RPC standard of Ethereum. If a response does not match this required format, the call fails and the Chainlink node will stop functioning properly.

The following methods are specifically required and must follow the Ethereum RPC API specification:

• GetCode
• Call
• ChainID
• SendTransaction
• SendRawTransaction
• GetTransactionReceipt
• GetTransactionByHash
• EstimateGas
• GasPrice
• GetTransactionCount
• GetLogs

Must follow the spec as defined in EIP-1474. The "latest" block number returned by GetBlockByNumber must also be served by GetLogs with logs.
Must accept the blockhash param as defined in EIP-234
• GetBalance
• GetBlockByNumber
• GetBlockByHash

The above RPC methods must have the expected request and response params with expected data types and values as described in the Execution-api spec and Ethereum RPC API Spec.

The network must also support the following items:

• Subscription Methods: Websocket JSON-RPC subscription methods

eth_subscribe with support for subscription to newHeads and logs
• Tags: The RPC methods must support the finalized, latest, and pending tags where applicable. They must also support natural numbers for blocks.
• Batch Requests: Must support batching of requests for the GetLogs and GetBlockByNumber methods.
• Response size: Any RPC request including the batch requests must be within the allowed size limit of around 173MB.

### eth_sendRawTransaction error message mapping to Geth client error messages
Chains must provide an error message mapping between their specific implementation to the error messages detailed below.

When the eth_sendRawTransaction call fails, Chainlink nodes must be able to recognize these error categories and determine the next appropriate action. If the error categories are different or cannot be mapped correctly, the Chainlink node will stop functioning properly and stop sending transactions to the chain. The following error messages are specifically critical:

Error | Description
--- | ---
NonceTooLow | Returned when the nonce used for the transaction is too low to use. This nonce likely has been already used on the chain previously.
NonceTooHigh | Returned when the nonce used for the transaction is higher than what the chain can use right now.
ReplacementTransactionUnderpriced | Returned when the transaction gas price used is too low. There is another transaction with the same nonce in the queue, with a higher price.
LimitReached | Returned when there are too many outstanding transactions on the node.
TransactionAlreadyInMempool | Returned when this current transaction was already received and stored.
TerminallyUnderpriced | Returned when the transaction's gas price is too low and won't be accepted by the node.
InsufficientEth | Returned when the account doesn't have enough funds to send this transaction.
TxFeeExceedsCap | Returned when the transaction gas fees exceed the configured cap by this node, and won't be accepted.
L2FeeTooLow | Specific for Ethereum L2s only. Returned when the gas fees are too low, When this error occurs the Suggested Gas Price is fetched again transaction is retried.
L2FeeTooHigh | Specific for Ethereum L2s only. Returned when the total fee is too high. When this error occurs the Suggested Gas Price is fetched again transaction is retried.
L2Full | Specific for Ethereum L2s only. The node is too full, and cannot handle more transactions.
TransactionAlreadyMined | Returned when the current transaction was already accepted and mined into a block.
Fatal | Return when something is seriously wrong with the transaction, and the transaction will never be accepted in the current format.

For examples of how other chains or clients are using these categories, see the error.go file in the go-ethereum repo on GitHub.

For chains with zk-proofs, chains must reject transactions that cause zk-proof overflow with a uniquely identifiable error message.

Any other reasons why transactions might be rejected by a node or sequencer other than malformed input/gasLimits must be detailed.

### Clarify use of transaction types
For transaction types other than 0x0 - Legacy, 0x1 - Access List, 0x2 - Dynamic, and 0x3 - Blob, networks must clarify how each transaction type is used. Chainlink nodes must know if the chain uses other types for regular transactions with regular gas so it can correctly estimate gas costs.

### Multi-signature wallet support
The chain must provide a supported and audited multi-signature wallet implementation with a UI.

### Block explorer support
The chain must provide a block explorer and support for contract and verification APIs.

================================================================================

# Faucets

Source: https://faucets.chain.link/
Extraction Method: playwright

# Choose Faucets
Get testnet tokens. Multiple assets available. Experiment with smart contracts today.

AllNativeLink[Image: bnb-chain-testnet-faucet][Image: chainlink-token-icon]
### BNB Chain Testnet
Drips 25 LINK

[Image: fuji-faucet]
### Avalanche Fuji
Drips 0.5 AVAX

[Image: fuji-faucet][Image: chainlink-token-icon]
### Avalanche Fuji
Drips 25 LINK

[Image: fantom-testnet-faucet][Image: chainlink-token-icon]
### Fantom Testnet
Drips 25 LINK

[Image: sepolia-faucet]
### Ethereum Sepolia
Drips 0.5 ETH

[Image: sepolia-faucet][Image: chainlink-token-icon]
### Ethereum Sepolia
Drips 25 LINK

[Image: base-sepolia-faucet]
### Base Sepolia
Drips 0.5 ETH

[Image: base-sepolia-faucet][Image: chainlink-token-icon]
### Base Sepolia
Drips 25 LINK

[Image: celo-alfajores-testnet-faucet][Image: chainlink-token-icon]
### Celo Alfajores Testnet
Drips 25 LINK

[Image: scroll-sepolia-testnet-faucet]
### Scroll Sepolia Testnet
Drips 0.5 ETH

[Image: scroll-sepolia-testnet-faucet][Image: chainlink-token-icon]
### Scroll Sepolia Testnet
Drips 25 LINK

[Image: polygon-amoy-faucet]
### Polygon Amoy
Drips 0.5 POL

[Image: polygon-amoy-faucet][Image: chainlink-token-icon]
### Polygon Amoy
Drips 25 LINK

[Image: arbitrum-sepolia-faucet]
### Arbitrum Sepolia
Drips 0.5 ETH

[Image: arbitrum-sepolia-faucet][Image: chainlink-token-icon]
### Arbitrum Sepolia
Drips 25 LINK

[Image: optimism-sepolia-faucet][Image: chainlink-token-icon]
### OP Sepolia
Drips 25 LINK

Show all Faucets
### Add wallet addresses
Where are you sending the testnet tokens?

## Build with Chainlink
[Image: question-circle-bg]
###### Get started with smart contracts
Understand the basic concepts behind smart contract development and oracle networks.

[Learn more](https://docs.chain.link/getting-started/conceptual-overview)[Image: programming-browser-bg]
###### Check out the Chainlink documentation
Learn about building on the industry-standard Web3 services platform.

[Learn more](https://docs.chain.link/)[Image: video-player-movie-bg]
###### Explore learning resources
Browse an extensive collection of smart contract learning materials and developer resources.

[Learn more](https://docs.chain.link/getting-started/other-tutorials)[Image: video-player-movie-bg]
###### Watch developer tutorials
Discover a wide range of technical tutorials and how-to’s on the official Chainlink YouTube.

[Learn more](https://www.youtube.com/@chainlink)
##### Need integration support?
[Talk to an expert](https://chain.link/contact)[Image: dev-expert]
##### Discord
[Join the community](https://discord.com/invite/aSK4zew)[Image: discord]
##### Stack Overflow
[Get technical support](https://stackoverflow.com/questions/tagged/chainlink)[Image: stack-overflow]
### How to get testnet tokens
1Choose Faucet

Choose one or multiple Faucet(s) you want to receive testnet tokens from.

2Connect your wallet

Connect a compatible wallet service, including MetaMask, WalletConnect, or Coinbase Wallet.

3Get testnet tokens

View the status of your transactions and see the tokens being sent and confirmed.

================================================================================

# PegSwap

Source: https://pegswap.chain.link/
Extraction Method: playwright

# Convert Chainlink tokens
Convert Chainlink tokens (LINK) to be ERC-677 compatible so you can use it with Chainlink oracles. Learn more

## Swap Chainlink
FromToYou can convert up to ...

Swap
## Supported networks
BNB Chain MainnetPegSwap address[0x1FCc...Bb9e](https://bscscan.com/address/0x1FCc3B22955e76Ca48bF025f1A6993685975Bb9e)Binance Pegged LINK[0xF8A0...51bD](https://bscscan.com/address/0xf8a0bf9cf54bb92f17374d9e9a321e6a111a51bd)(via[Binance Bridge](https://www.binance.org/en/bridge))Wrapped ERC677 LINK[0x4044...BB75](https://bscscan.com/address/0x404460c6a5ede2d891e8297795264fde62adbb75)Polygon MainnetPegSwap address[0xAA1D...BC5b](https://polygonscan.com/address/0xAA1DC356dc4B18f30C347798FD5379F3D77ABC5b)Polygon Bridged LINK[0x53E0...ad39](https://polygonscan.com/address/0x53E0bca35eC356BD5ddDFebbD1Fc0fD03FaBad39)(via[Polygon Bridge](https://portal.polygon.technology/bridge))Wrapped ERC677 LINK[0xb089...E0F1](https://polygonscan.com/address/0xb0897686c545045afc77cf20ec7a532e3120e0f1)Gnosis Chain MainnetPegSwap address[0x1FCc...Bb9e](https://gnosisscan.io/address/0x1FCc3B22955e76Ca48bF025f1A6993685975Bb9e)xDAI Bridged LINK from BNB[0x9390...B8d4](https://gnosisscan.io/address/0x93902393EFdbb5423e187B6B2F7282a23274B8d4)(via[Omnibridge](https://bsc-to-xdai-omnibridge.web.app))Wrapped ERC677 LINK[0xE2e7...09b2](https://gnosisscan.io/address/0xE2e73A1c69ecF83F464EFCE6A5be353a37cA09b2)Need help or have questions? Email us at support@chain.link

================================================================================

# Metrics | Chainlink

Source: https://metrics.chain.link/
Extraction Method: playwright

⌘K⌘KChainlink Metrics

Explore key Chainlink metrics, including network usage and ecosystem adoption.

Updated September 2025

$25.24T

Transaction Value Enabled (TVE)

$103.25B

Total Value Secured (TVS)

18.54B

Total Verified Messages (TVM)

## Adoption
Metrics covering adoption of the Chainlink ecosystem by smart contract applications.

### Transaction Value Enabled (TVE)
Updated Sep 2025

$25.24T

The cumulative monetary value of transactions facilitated by Chainlink oracles, including both volume and facilitated flow, measured in US Dollars.

.apexcharts-flip-y {
        transform: scaleY(-1) translateY(-100%);
        transform-origin: top;
        transform-box: fill-box;
      }
      .apexcharts-flip-x {
        transform: scaleX(-1);
        transform-origin: center;
        transform-box: fill-box;
      }
      .apexcharts-legend {
        display: flex;
        overflow: auto;
        padding: 0 10px;
      }
      .apexcharts-legend.apexcharts-legend-group-horizontal {
        flex-direction: column;
      }
      .apexcharts-legend-group {
        display: flex;
      }
      .apexcharts-legend-group-vertical {
        flex-direction: column-reverse;
      }
      .apexcharts-legend.apx-legend-position-bottom, .apexcharts-legend.apx-legend-position-top {
        flex-wrap: wrap
      }
      .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {
        flex-direction: column;
        bottom: 0;
      }
      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-left, .apexcharts-legend.apx-legend-position-top.apexcharts-align-left, .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {
        justify-content: flex-start;
        align-items: flex-start;
      }
      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-center, .apexcharts-legend.apx-legend-position-top.apexcharts-align-center {
        justify-content: center;
        align-items: center;
      }
      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-right, .apexcharts-legend.apx-legend-position-top.apexcharts-align-right {
        justify-content: flex-end;
        align-items: flex-end;
      }
      .apexcharts-legend-series {
        cursor: pointer;
        line-height: normal;
        display: flex;
        align-items: center;
      }
      .apexcharts-legend-text {
        position: relative;
        font-size: 14px;
      }
      .apexcharts-legend-text *, .apexcharts-legend-marker * {
        pointer-events: none;
      }
      .apexcharts-legend-marker {
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        margin-right: 1px;
      }

      .apexcharts-legend-series.apexcharts-no-click {
        cursor: auto;
      }
      .apexcharts-legend .apexcharts-hidden-zero-series, .apexcharts-legend .apexcharts-hidden-null-series {
        display: none !important;
      }
      .apexcharts-inactive-legend {
        opacity: 0.45;
      }$30T$30T$25T$25T$20T$20T$15T$15T$10T$10T$5T$5TJan 2022Jan 2022Jul 2022Jul 2022Jan 2023Jan 2023Jul 2023Jul 2023Jan 2024Jan 2024Jul 2024Jul 2024Jan 2025Jan 2025Jul 2025Jul 2025
### Total Value Secured (TVS)
Updated Sep 2025

$103.25B

The total value of assets deposited into or borrowed from smart contract applications secured by Chainlink oracles, measured in US dollars.

.apexcharts-flip-y {
        transform: scaleY(-1) translateY(-100%);
        transform-origin: top;
        transform-box: fill-box;
      }
      .apexcharts-flip-x {
        transform: scaleX(-1);
        transform-origin: center;
        transform-box: fill-box;
      }
      .apexcharts-legend {
        display: flex;
        overflow: auto;
        padding: 0 10px;
      }
      .apexcharts-legend.apexcharts-legend-group-horizontal {
        flex-direction: column;
      }
      .apexcharts-legend-group {
        display: flex;
      }
      .apexcharts-legend-group-vertical {
        flex-direction: column-reverse;
      }
      .apexcharts-legend.apx-legend-position-bottom, .apexcharts-legend.apx-legend-position-top {
        flex-wrap: wrap
      }
      .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {
        flex-direction: column;
        bottom: 0;
      }
      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-left, .apexcharts-legend.apx-legend-position-top.apexcharts-align-left, .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {
        justify-content: flex-start;
        align-items: flex-start;
      }
      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-center, .apexcharts-legend.apx-legend-position-top.apexcharts-align-center {
        justify-content: center;
        align-items: center;
      }
      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-right, .apexcharts-legend.apx-legend-position-top.apexcharts-align-right {
        justify-content: flex-end;
        align-items: flex-end;
      }
      .apexcharts-legend-series {
        cursor: pointer;
        line-height: normal;
        display: flex;
        align-items: center;
      }
      .apexcharts-legend-text {
        position: relative;
        font-size: 14px;
      }
      .apexcharts-legend-text *, .apexcharts-legend-marker * {
        pointer-events: none;
      }
      .apexcharts-legend-marker {
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        margin-right: 1px;
      }

      .apexcharts-legend-series.apexcharts-no-click {
        cursor: auto;
      }
      .apexcharts-legend .apexcharts-hidden-zero-series, .apexcharts-legend .apexcharts-hidden-null-series {
        display: none !important;
      }
      .apexcharts-inactive-legend {
        opacity: 0.45;
      }$120B$120B$100B$100B$80B$80B$60B$60B$40B$40B$20B$20BJan 2024Jan 2024Apr 2024Apr 2024Jul 2024Jul 2024Oct 2024Oct 2024Jan 2025Jan 2025Apr 2025Apr 2025Jul 2025Jul 2025
### Total Verified Messages (TVM)
Updated Sep 2025

18.54B

The cumulative sum of all verified outputs published on smart contract blockchains by Chainlink oracles.

.apexcharts-flip-y {
        transform: scaleY(-1) translateY(-100%);
        transform-origin: top;
        transform-box: fill-box;
      }
      .apexcharts-flip-x {
        transform: scaleX(-1);
        transform-origin: center;
        transform-box: fill-box;
      }
      .apexcharts-legend {
        display: flex;
        overflow: auto;
        padding: 0 10px;
      }
      .apexcharts-legend.apexcharts-legend-group-horizontal {
        flex-direction: column;
      }
      .apexcharts-legend-group {
        display: flex;
      }
      .apexcharts-legend-group-vertical {
        flex-direction: column-reverse;
      }
      .apexcharts-legend.apx-legend-position-bottom, .apexcharts-legend.apx-legend-position-top {
        flex-wrap: wrap
      }
      .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {
        flex-direction: column;
        bottom: 0;
      }
      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-left, .apexcharts-legend.apx-legend-position-top.apexcharts-align-left, .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {
        justify-content: flex-start;
        align-items: flex-start;
      }
      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-center, .apexcharts-legend.apx-legend-position-top.apexcharts-align-center {
        justify-content: center;
        align-items: center;
      }
      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-right, .apexcharts-legend.apx-legend-position-top.apexcharts-align-right {
        justify-content: flex-end;
        align-items: flex-end;
      }
      .apexcharts-legend-series {
        cursor: pointer;
        line-height: normal;
        display: flex;
        align-items: center;
      }
      .apexcharts-legend-text {
        position: relative;
        font-size: 14px;
      }
      .apexcharts-legend-text *, .apexcharts-legend-marker * {
        pointer-events: none;
      }
      .apexcharts-legend-marker {
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        margin-right: 1px;
      }

      .apexcharts-legend-series.apexcharts-no-click {
        cursor: auto;
      }
      .apexcharts-legend .apexcharts-hidden-zero-series, .apexcharts-legend .apexcharts-hidden-null-series {
        display: none !important;
      }
      .apexcharts-inactive-legend {
        opacity: 0.45;
      }30B30B25B25B20B20B15B15B10B10B5B5BDec 2020Dec 2020Jul 2021Jul 2021Feb 2022Feb 2022Sep 2022Sep 2022Apr 2023Apr 2023Nov 2023Nov 2023Jun 2024Jun 2024Jan 2025Jan 2025Aug 2025Aug 2025Disclaimer: The data above is provided on an “AS IS” and “AS AVAILABLE” basis, without warranties of any kind, whether express or implied, legal, statutory or otherwise. Without limiting the foregoing, the Chainlink Foundation and its affiliates disclaim any responsibility for errors, interruptions, accuracy, completeness or corrections to the data. Please note, some outliers and anomalous data have been removed from the charts above to improve the accuracy of the representative data.

================================================================================

# Staking

Source: https://staking.chain.link/
Extraction Method: playwright
Components: table(1)

# Chainlink Staking

### v0.2 open for General Access
Staking v0.2 is now open to the public. Anyone can stake, provided the staking protocol is not full. Learn more

## 4.32%

###### Current v0.2 Variable Reward Rate
LINK rewards divided by total LINK staked.[Learn more](https://blog.chain.link/chainlink-staking-v0-2-overview/#dynamic_reward_rates)v0.2 Community
Staking Protocol
# 40,875,000
/40,875,000LINKFilledUnfilled
## ETH/USD Node Set
[Primary Feed](https://data.chain.link/feeds/ethereum/mainnet/eth-usd)Answer
#### $4,486.49
Oracle responses
#### 31/31
Last update
#### 15 minutes ago
Alerts raised
#### 0

### Node operators

Oracle | Latest answer | Date | Status | Details
--- | --- | --- | --- | ---
01Node | $4,486.77 | October 2, 2025 at 23:57 UTC | Responded | 
Alpha Chain | $4,486.49 | October 2, 2025 at 23:57 UTC | Responded | 
Artifact | $4,486.71 | October 2, 2025 at 23:57 UTC | Responded | 
Blockdaemon | $4,487.07 | October 2, 2025 at 23:57 UTC | Responded | 
Blocksize | $4,486.06 | October 2, 2025 at 23:57 UTC | Responded | 
Chainlayer | $4,486.49 | October 2, 2025 at 23:57 UTC | Responded | 
Deutsche Telekom MMS | $4,486.29 | October 2, 2025 at 23:57 UTC | Responded | 
DexTrac | $4,486.71 | October 2, 2025 at 23:57 UTC | Responded | 
Easy 2 stake | $4,486.29 | October 2, 2025 at 23:57 UTC | Responded | 
Fiews | $4,486.71 | October 2, 2025 at 23:57 UTC | Responded | 

PrevShowing 1 to 10 of 31 entries

NextPlease see the following blog posts and Terms of Service for important information and disclosures.  Chainlink Staking v0.2 is currently in beta.

## Read more about Chainlink Staking
[ARTICLEIntroducing the Chainlink Staking Platform: v0.2 Upgrade and Launch Details](https://blog.chain.link/chainlink-staking-v0-2-overview/)[ARTICLEHow to Stake Chainlink (LINK)](https://blog.chain.link/how-to-stake-chainlink-link/)[ARTICLEMigration and Early Access Eligibility for Chainlink Staking v0.2](https://blog.chain.link/chainlink-staking-v0-2-early-access-eligibility)[ARTICLESustainable Oracle Economics Are Critical to the Success of Web3](https://blog.chain.link/sustainable-oracle-economics/)

================================================================================

# Chainlink Local

Source: https://docs.chain.link/chainlink-local
Extraction Method: playwright

# Chainlink Local
Chainlink Local is an installable package that allows you to run Chainlink services locally. You can import Chainlink Local into your preferred local development environment,
such as Foundry projects, Hardhat scripts, or the Remix IDE. Chainlink Local enables rapid exploration, prototyping, local development, and iteration with Chainlink services
before transitioning to a testnet.

For instance, you can use Chainlink Local to execute CCIP token transfers and arbitrary messages on a local Hardhat or Anvil (Foundry) development node. Chainlink Local also supports forked nodes,
allowing you to work with multiple locally running blockchain networks using historical network states. User contracts tested with Chainlink Local can be deployed to test networks without modifications,
ensuring a seamless transition from local development to live testnets.

Key Features of Chainlink Local:

• Local Simulation: Run Chainlink services on a local development blockchain node, enabling fast and efficient testing and prototyping.
• Forked Networks: Work with deployed Chainlink contracts using one or multiple forked networks, providing a more realistic testing environment.
• Seamless Integration: Integrate with Foundry, Hardhat, and Remix IDE for a streamlined development process.

To get started testing CCIP with Chainlink Local, follow the installation and setup steps in the CCIP guides for Foundry, Hardhat, or Remix IDE.

Playclass i extends HTMLElement{connectedCallback(){this.videoId=this.getAttribute("videoid");let e=this.querySelector(".lty-playbtn");if(this.playLabel=e&&e.textContent.trim()||this.getAttribute("playlabel")||"Play",this.dataset.title=this.getAttribute("title")||"",this.style.backgroundImage||(this.style.backgroundImage=`url("https://i.ytimg.com/vi/${this.videoId}/hqdefault.jpg")`,this.upgradePosterImage()),e||(e=document.createElement("button"),e.type="button",e.classList.add("lty-playbtn"),this.append(e)),!e.textContent){const t=document.createElement("span");t.className="lyt-visually-hidden",t.textContent=this.playLabel,e.append(t)}this.addNoscriptIframe(),e.nodeName==="A"&&(e.removeAttribute("href"),e.setAttribute("tabindex","0"),e.setAttribute("role","button"),e.addEventListener("keydown",t=>{(t.key==="Enter"||t.key===" ")&&(t.preventDefault(),this.activate())})),this.addEventListener("pointerover",i.warmConnections,{once:!0}),this.addEventListener("focusin",i.warmConnections,{once:!0}),this.addEventListener("click",this.activate),this.needsYTApi=this.hasAttribute("js-api")||navigator.vendor.includes("Apple")||navigator.userAgent.includes("Mobi")}static addPrefetch(e,t,a){const r=document.createElement("link");r.rel=e,r.href=t,a&&(r.as=a),document.head.append(r)}static warmConnections(){i.preconnected||(i.addPrefetch("preconnect","https://www.youtube-nocookie.com"),i.addPrefetch("preconnect","https://www.google.com"),i.addPrefetch("preconnect","https://googleads.g.doubleclick.net"),i.addPrefetch("preconnect","https://static.doubleclick.net"),i.preconnected=!0)}fetchYTPlayerApi(){window.YT||window.YT&&window.YT.Player||(this.ytApiPromise=new Promise((e,t)=>{var a=document.createElement("script");a.src="https://www.youtube.com/iframe_api",a.async=!0,a.onload=r=>{YT.ready(e)},a.onerror=t,this.append(a)}))}async getYTPlayer(){return this.playerPromise||await this.activate(),this.playerPromise}async addYTPlayerIframe(){this.fetchYTPlayerApi(),await this.ytApiPromise;const e=document.createElement("div");this.append(e);const t=Object.fromEntries(this.getParams().entries());this.playerPromise=new Promise(a=>{let r=new YT.Player(e,{width:"100%",videoId:this.videoId,playerVars:t,events:{onReady:n=>{n.target.playVideo(),a(r)}}})})}addNoscriptIframe(){const e=this.createBasicIframe(),t=document.createElement("noscript");t.innerHTML=e.outerHTML,this.append(t)}getParams(){const e=new URLSearchParams(this.getAttribute("params")||[]);return e.append("autoplay","1"),e.append("playsinline","1"),e}async activate(){if(this.classList.contains("lyt-activated"))return;if(this.classList.add("lyt-activated"),this.needsYTApi)return this.addYTPlayerIframe(this.getParams());const e=this.createBasicIframe();this.append(e),e.focus()}createBasicIframe(){const e=document.createElement("iframe");return e.width=560,e.height=315,e.title=this.playLabel,e.allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture",e.allowFullscreen=!0,e.src=`https://www.youtube-nocookie.com/embed/${encodeURIComponent(this.videoId)}?${this.getParams().toString()}`,e}upgradePosterImage(){setTimeout(()=>{const e=`https://i.ytimg.com/vi_webp/${this.videoId}/sddefault.webp`,t=new Image;t.fetchPriority="low",t.referrerpolicy="origin",t.src=e,t.onload=a=>{a.target.naturalHeight==90&&a.target.naturalWidth==120||(this.style.backgroundImage=`url("${e}")`)}},100)}}customElements.define("lite-youtube",i);

================================================================================

# functions-toolkit

Source: https://www.npmjs.com/package/@chainlink/functions-toolkit
Extraction Method: playwright
Components: code_block(51)

# functions-toolkit
An NPM package that can be used for working with Chainlink Functions.

Up-to-date documentation on Chainlink Functions can be found here.

# Table of Contents

• Table of Contents
• Prerequisites

Functions Billing Subscription Management

Subscription Initialization
Create Subscription
Fund Subscription
Adding/Removing Authorized Consumer Contracts
Cancelling Subscriptions
Transferring and Accepting Transfers of Subscriptions
Get subscription details
Timing out requests
Estimating request costs
Adding transaction options

Functions Encrypted Secrets Management

Initialize a SecretsManager instance
Fetch public keys
Encrypting Secrets
DON Hosted Secrets
Off-chain Hosted Secrets

Functions Response Listener

Functions Utilities

Local Functions Simulator
Local Functions Testnet
Decoding Response Bytes
Storing Encrypted Secrets in Gists
Building Functions Request CBOR Bytes

Browser use

# Prerequisites
Install Node.js version 18.18.0 or higher and Deno version 1.36.0 or higher.

Chainlink Functions requires signing a terms of service agreement before creating a billing subscription. See this getting started section in the docs.

## Functions Billing Subscription Management
The SubscriptionManager class is used to manage the Chainlink billing subscription used to pay for Functions requests.

### Subscription Initialization
To create a SubscriptionManager you need an object with 3 inputs.

1. An instance of the Ethers.js signer class. Ensure you have a provider connected so you can communicate with the blockchain. You can use Infura or Alchemy or another provider that provides access to blockchains that Chainlink Functions supports.
2. The contract address for the LINK token for the corresponding blockchain network from here.
3. The contract address for the Functions Router for the corresponding blockchain network contract from here.

Then create an instance of the SubscriptionManager by passing those 3 inputs.

```
const subscriptionManager = new SubscriptionManager({
  signer,
  linkTokenAddress,
  functionsRouterAddress,
})
```

After the class is instantiated, it must be initialized before it can be used. This is done by running the initialize async function as shown below:

```
await subscriptionManager.initialize()
```

### Create Subscription
createSubscription() creates a new Functions billing subscription using the Functions Router contract and returns a promise which resolves to the subscription ID of type number. Optionally, a consumer contract address can also be passed to create a subscription and add an authorized consumer in a single transaction.

```
const subscriptionId: number = await subscriptionManager.createSubscription({
  consumerAddress,
})
```

Make a note of your subscription ID as it will contain your funds. You will also need to use the subscription ID as an input for many operations when using Chainlink Functions.

### Fund Subscription
fundSubscription() is used to fund your subscription with LINK tokens. You must have a LINK balance for your subscription in order to pay for Functions requests. Furthermore, in order to upload DONHosted encrypted secrets, you must have a minimum balance in your subscription. Minimum subscription balance requirements for uploading encrypted secrets to the DON can be found at in the Chainlink Functions docs.

To fund the subscription with LINK, ensure the wallet that you have connected has sufficient LINK. You can get some testnet LINK from the faucet.

Note that all values are denominated in Juels. 1,000,000,000,000,000,000 (1e18) Juels are equal to 1 LINK. Do not use the JavaScript number type for calculations with Juels as the maximum safe JavaScript integer is only 2^54 - 1.

```
const juelsAmount:  BigInt | string = BigInt(2) * BigInt(10**18)
await subscriptionManager.fundSubscription({
  subscriptionId,
  juelsAmount,
})
```

fundSubscription() returns a promise which resolves to an Ethers.js TransactionReceipt

### Adding/Removing Authorized Consumer Contracts
A Functions Consumer is the smart contract which can send Functions requests to the Chainlink Oracle Network and where the oracle network will return the results of your decentralized computation. A visualization of this request/response flow is below.

(source)

Each subscription can hold a limited number of authorized Functions Consumers. Refer to the service limits to view the maximum number of consumer contracts per subscription. These are the consumer contracts that are authorized to use your subscription's LINK balance to pay for requests.

```
const addConsumerTxReceipt = await subscriptionManager.addConsumer({
  subscriptionId,
  consumerAddress,
})
```

Similarly, you can remove an authorized consumer contract.

```
const removeConsumerTxReceipt = await subscriptionManager.removeConsumer({
  subscriptionId,
  consumerAddress,
})
```

Both addConsumer() and removeConsumer() return a promise which resolves to an EthersJS TransactionReceipt.

### Cancelling Subscriptions
You can cancel subscriptions with cancelSubscription(). If there are any pending requests, you must first "time out" that pending request using the timeoutRequest() function before cancelling the subscription.

```
const cancelSubTxReceipt = await subscriptionManager.cancelSubscription({ subscriptionId })
```

cancelSubscription() takes a config object that has the following type definition. Optionally, you can specify a wallet address to which the subscription's LINK balance will be refunded. If unspecified, it will default to the subscription owner's address.

```
type SubCancelConfig = {
  subscriptionId: BigInt | number | string
  refundAddress?: string
  txOptions?: TransactionOptions
}
```

### Transferring and Accepting Transfers of Subscriptions
Transferring subscriptions is a two-stage process. First, the subscription owner proposes the transfer with requestSubscriptionTransfer() and it is recorded on chain, but the ownership does not transfer until the transferee accepts by calling acceptTransfer().

```
const transferTxReceipt = await subscriptionManager.requestSubscriptionTransfer({
  subscriptionId,
  newOwner, // transferee wallet address
})
```

To accept the ownership transfer, the transferee will need to have their own SubscriptionManager instance which is connected to the wallet address denoted by newOwner. Then the transferee can call the acceptSubTransfer() method.

```
const acceptTransferTxReceipt =  await transfereeSubManager.acceptSubTransfer({ subscriptionId })
```

### Get subscription details
You can request details for a given subscription (on the network on which it has been created) using getSubscriptionInfo().

```
const subscriptionInfo = await getSubscriptionInfo(subscriptionId)
```

This is a read-only interaction with the blockchain.

The returned promise resolves to a value of type SubscriptionInfo and has the following structure:

```
type SubscriptionInfo = {
  balance: BigInt // Represented in Juels (1,000,000,000,000,000,000 (1e18) Juels are equal to 1 LINK)
  owner: string // Subscription owner's address
  blockedBalance: BigInt // Balance reserved to pay for in-flight requests represented in Juels
  proposedOwner: string // Address used for transferring subscriptions
  consumers: string[] // Addresses of consumer contracts allowed to use the subscription
  flags: string // Indicates resource limits for a given subscription (If the default limits are not enough for your use case, contact the Chainlink team by emailing support@chain.link to inquire about a potential increase.)
}
```

### Timing out requests
In certain circumstances, such as when the cost of fulfillment exceeds the amount that was allocated when the request was initiated, pending requests may expire and must be manually timed out. This is because, when a request is in-flight, your LINK tokens that pay for that computation get locked up for the duration of the request's lifecycle. Calling timeoutRequest() unlocks those funds in the event a request expires without fulfillment.

Note that you cannot time out requests until they have expired. A request expires if it has not been fulfilled within 300 seconds after the request transaction was confirmed on-chain.

In order to time out a request, you must first fetch the request commitment which contains the request data that was emitted by the request transaction. This can be achieved using fetchRequestCommitment which returns a promise that resolves to a RequestCommitment object.

```
type RequestCommitment = {
  requestId: string
  coordinator: string
  estimatedTotalCostJuels: BigInt
  client: string
  subscriptionId: number
  callbackGasLimit: BigInt
  adminFee: BigInt
  donFee: BigInt
  gasOverheadBeforeCallback: BigInt
  gasOverheadAfterCallback: BigInt
  timeoutTimestamp: BigInt
}
```

Here is an example of using fetchRequestCommitment. The DON ID for each network can be found in the Chainlink Functions docs.

```
const provider: ethers.providers.JsonRpcProvider = new ethers.providers.JsonRpcProvider('http://YOUR_RPC_URL.com/')
const requestCommitment: RequestCommitment = await fetchRequestCommitment({
  requestId: '0xYOUR_REQUEST_ID',
  provider,
  functionsRouterAddress: '0xFUNCTIONS_ROUTER_ADDRESS'
  donId: 'DON_ID_FOR_NETWORK',
  toBlock: 100_000, // Optional value for ending block in range to search (defaults to latest block)
  pastBlocksToSearch: 2000, // Optional value for the number of blocks to search before the toBlock (defaults to 1000)
})
```

Now you can time out the request.

```
const timeoutRequestConfig: SubTimeoutConfig = {
  requestCommitments: [ requestCommitment ],
}
const timeoutReceipt: TransactionReceipt | void = await timeoutRequests(timeoutReqConfig)
```

### Estimating request costs
The estimateFunctionsRequestCost() method can be used to estimate the cost of a Functions request. The DON ID for each network can be found in the Chainlink Functions docs.

```
const estimatedCostInJuels: BigInt = await subscriptionManager.estimateFunctionsRequestCost({
  donId, // ID of the DON to which the Functions request will be sent
  subscriptionId, // Subscription ID
  callbackGasLimit, // Total gas used by the consumer contract's callback
  gasPriceWei, // Gas price in wei
})
```

This method will return a promise which resolves to a BigInt with the estimated request cost in Juels (1,000,000,000,000,000,000 (1e18) Juels are equal to 1 LINK).

### Adding transaction options
All SubscriptionManager class methods which write to the blockchain can take an optional TransactionOptions object that has the following shape.

```
export type TransactionOptions = {
  overrides?: Overrides
  confirmations?: number
}
```

Overrides are defined by Ethers.js for contract function calls. confirmations refers to the number of block confirmations to wait before proceeding.

## Functions Encrypted Secrets Management
This class helps you encrypt and manage the secrets that your Functions source code uses. Secrets are sensitive values such as API keys or passwords that are typically stored as environment variables to avoid exposing these values in plaintext.

Functions secrets utilize threshold public key cryptography, requiring multiple nodes to participate in a decentralized decryption process such that no node can decrypt secrets without consensus from the rest of the DON.

Encrypted secrets are never stored directly on the blockchain, but instead can be either hosted by the DON (Location.DONHosted) or stored in a JSON file located at one or more URLs (Location.Remote). Then, the encrypted secrets can be referenced and used in a Functions request.

### Initialize a SecretsManager instance
To create a SecretsManager you need an object with 3 inputs.

1. An instance of the Ethers.js signer class. Ensure you have a Provider connected to communicate with the blockchain. You can use Infura or Alchemy or another similar provider that provides access to blockchains that Chainlink Functions supports.
2. The contract address for the Functions Router smart contract from here here.
3. The donId string to reference the DON you would like to use, which can also be found here.

```
const secretsManager = new SecretsManager({
  signer,
  functionsRouterAddress,
  donId,
})
```

After the class is instantiated, it must be initialized before it can be used. This is done by running the initialize() async method.

```
await secretsManager.initialize()
```

### Fetch public keys
You can fetch the public keys by querying the Functions Coordinator contract.

In most cases you will not need to call this method directly. The other methods in SecretsManager will automatically use this method.

```
const keys = await secretsManager.fetchKeys()
```

fetchKeys() returns a promise that resolves to an object with the following properties:

```
{
  thresholdPublicKey: ThresholdPublicKey
  donPublicKey: string
}
```

The threshold public key is an added layer of cryptographic protection for the security of your API secrets. Your secrets get encrypted twice - first with the donPublicKey and then with the thresholdPublicKey.

Encrypting with the thresholdPublicKey requires nodes to collaborate in order to decrypt secrets. This is because secrets cannot be decrypted with a single key; instead, each DON node has a decryption key shard and multiple nodes must come together in a decentralized process to decrypt the secrets. This improves security since no single DON node can decrypt secrets without collaborating with other DON nodes.

### Encrypting Secrets
Secrets are encrypted by passing them in an object to the encryptSecrets() method.

Here are some important conditions you must satisfy when configuring your secrets for Chainlink Functions.

1. Secrets are optional. You do not need to configure secrets if your custom Functions source code does not need to access any secret values.
2. Your secrets must be passed in an object with string key/value pairs:

```
{
  testKey: 'testValue1',
  testKey2: 'testValue2',
  testKey3: 'testValue3',
}
```

```
const encryptedSecrets = await secretsManager.encryptSecrets({
  testKey: 'testValue0'
})
```

encryptSecrets() returns a promise that resolves to an object with a single property encryptedSecrets.

```
{
  encryptedSecrets: string
}
```

encryptedSecrets contains the string representation of your secrets, converted into bytes, and encrypted using the public keys.

### DON Hosted Secrets
Encrypted secrets can be uploaded directly to the DON via gateway URLs such that they can be used when making an on-chain request. This is accomplished by sending a signed POST request to gateway URLs which are connected to the DON. The DON then maintains a decentralized database with eventual consistency such that the stored values will propagate to all DON nodes.

First, encrypt the secrets with encryptSecrets(). Then, pass the encryptedSecrets hex string in an object to the uploadEncryptedSecretsToDON() method as shown below. The slotId can be any integer value of zero or greater, however using a previously used slot ID will overwrite the existing data. After minutesUntilExpiration, the entry will be deleted from all DON nodes. Get the list of valid gateway URLs for each blockchain network from the Chainlink Functions documentation.

```
const encryptedSecretsObj = await secretsManager.encryptSecrets({ mySecret: 'secret' })
const mySlotIdNumber = 0
const myExpirationTimeInMinutes = 10

const {
  version, // Secrets version number (corresponds to timestamp when encrypted secrets were uploaded to DON)
  success, // Boolean value indicating if encrypted secrets were successfully uploaded to all nodes connected to the gateway
} = await secretsManager.uploadEncryptedSecretsToDON({
  encryptedSecretsHexstring: encryptedSecretsObj.encryptedSecrets,
  gatewayUrls: [ 'https://exampleGatewayUrl1.com/gateway', 'https://exampleGatewayUrl2.com/gateway', ... ],
  slotId: mySlotIdNumber,
  minutesUntilExpiration: myExpirationTimeInMinutes,
})
```

The uploadEncryptedSecretsToDON() method will return a promise that resolves to an object of the type shown below.

```
{
  version: number,
  success: boolean,
}
```

The version is a number which represents the version of the uploaded encrypted secrets; it is the POSIX time at which the uploadEncryptedSecretsToDON() method was initiated. This will be used when making a Functions request to ensure the latest version of the encrypted secrets are used. If the upload was unsuccessful for one or more nodes, a warning message will be printed and the success field will be false. If the upload was unsuccessful for all nodes, the method will throw an error.

```
const secretsEntriesForGateway = await secretsManager.listDONHostedEncryptedSecrets([ 'https://exampleGatewayUrl1.com/gateway', 'https://exampleGatewayUrl2.com/gateway', ... ])
```

listDONHostedEncryptedSecrets() will return an array with following shape or throw an error. If the method successfully returns, but the error field of the returned object is populated, it indicates that the request to list secrets was successful, but there is a discrepancy between the node responses.

```
{
  result: [
    {
      gatewayUrl: 'https://examplegatewayurl.com/gateway',
      nodeResponses: [
        {
          success: true,
          rows: [
            {
              slot_id: 0,
              version: 0,
              expiration: 100_000,
            },
            ...
          ],
        },
        ...
      ],
    },
    ...
  ],
  error: 'Possible error message <may be undefined>'
}
```

buildDONHostedEncryptedSecretsReference() can be used to construct the hex string which represents the encryptedSecretsReference bytes used to reference the DON hosted encrypted secrets when making an on-chain Functions request. To use DON hosted encrypted secrets in an on-chain request, also ensure that secretsLocation is set to Location.DONHosted (ie: 2).

```
const encryptedSecretsReference: string = secretsManager.buildDONHostedEncryptedSecretsReference({
  slotId: number,
  version: number
})
```

### Off-chain Hosted Secrets
Encrypted secrets can also be stored off-chain in JSON file instead of being hosted on the DON, enabling more direct control over how the encrypted secrets data is stored. The DON nodes fetch this file from one or more URLs.

First encrypt the secrets with encryptSecrets() and then paste or upload the resulting object into a private Github Gist, cloud storage bucket or or any other location such that the encrypted secrets JSON object can be fetched by the DON via URL. These secrets are encrypted so even if the JSON file is hosted at a public URL, your secrets are not visible.

You can also use the gist uploader utility function to upload the encrypted secrets string to a JSON file in a Github Gist.

As an additional layer of security, the URLs pointing to your JSON file must also encrypted with the DON Public key before being used as the encryptedSecretsReference in an on-chain request. This is to prevent directly exposing the URL to anyone except DON members, mitigating risk of DDOS or other attack vectors. You can build the encrypted URLs encryptSecretsUrls().

```
const encryptedSecretsReference: string = await encryptSecretsUrls(secretsUrls: string[])
```

encryptSecretsUrls() returns a promise which resolves to a hex string representing the secrets URLs as an encrypted string of space-separated URLs.

The resulting encryptedSecretsReference can then be used as one of the parameters for constructing the Functions request.

## Functions Response Listener
The ResponseListener class provides an easy way to listen for on-chain responses to Functions requests.

To create a Request Listener you need an object with 2 inputs.

1. An instance of an Ethers.js provider. You can use Infura or Alchemy or another similar provider that provides access to blockchains that Chainlink Functions supports.
2. The contract address for the Functions Router smart contract from here.

const responseListener = new ResponseListener({
provider,
functionsRouterAddress,
})

To listen for a response to a single Functions request, use the listenForResponseFromTransaction() method.
Optionally, you can provide:

• timeout after which the listener will throw an error indicating that the time limit was exceeded (default 5 minutes expressed in milliseconds)
• number of block confirmations (default 1, but note that should be 2 or more to for higher confidence in finality, and to protect against reorgs)
• frequency of checking if the request is already included on-chain (or if it got moved after a chain re-org) (default 2 seconds, but note that checkIntervals higher than block time could cause this listener to hang as the response will have completed before the next check.)

```
const response: FunctionsResponse = await responseListener.listenForResponseFromTransaction(
  txHash: string,
  timeoutMs?: number, // milliseconds
  confirmations?: number,
  checkInterval?: number,
)
```

listenForResponseFromTransaction() returns a response with the following structure:

```
{
  requestId: string // Request ID of the fulfilled request represented as a bytes32 hex string
  subscriptionId: number // Subscription ID billed for request
  totalCostInJuels: bigint // Actual cost of request in Juels (1,000,000,000,000,000,000 (1e18) Juels are equal to 1 LINK)
  responseBytesHexstring: string // Response bytes sent to client contract represented as a hex string ("0x" if no response)
  errorString: string // Error sent to client contract interpreted as a UTF-8 string ("" if no error)
  returnDataBytesHexstring: string // Data returned by consumer contract's handleOracleFulfillment method represented as a hex string
  fulfillmentCode: FulfillmentCode // Indicates whether the request was fulfilled successfully or not
}
```

Alternatively, to listen using a request ID, use the listenForResponse() method.

Notes:

1. Request ID can change during a chain re-org so it's less reliable than a request transaction hash.
2. If the methods are called after the response is already on chain, it won't be returned correctly.
3. Listening for multiple responses simultaneously is not supported by the above methods and will lead to undefined behavior.

```
const response: FunctionsResponse = await responseListener.listenForResponse(
  requestId: string,
  timeout?: number,
)
```

The FunctionsResponse will have the following shape.

```
{
  requestId: string // Request ID of the fulfilled request represented as a bytes32 hex string
  subscriptionId: number // Subscription ID billed for request
  totalCostInJuels: BigInt // Actual cost of request in Juels (1,000,000,000,000,000,000 (1e18) Juels are equal to 1 LINK)
  responseBytesHexstring: string // Response bytes sent to client contract represented as a hex string
  errorString: string // Error bytes sent to client contract represented as a hex string
  returnDataBytesHexstring: string // Data returned by consumer contract's handleOracleFulfillment method represented as a hex string
  fulfillmentCode: FulfillmentCode // Indicates whether the request was fulfilled successfully or not
}
```

The possible fulfillment codes are shown below.

```
{
  FULFILLED = 0, // Indicates that a Function was executed and calling the consumer contract's handleOracleFulfill method was successful
  USER_CALLBACK_ERROR = 1, // Indicates that the consumer contract's handleOracleFulfill method reverted
  // all other codes indicate internal errors
}
```

To listen for multiple Functions responses for a given subscription ID, use the listenForResponses() method. This method is particularly useful when Chainlink Automation is being used to trigger the sending of Functions requests. listenForResponses() takes the subscription ID and a callback as arguments. The callback will be given a FunctionsResponse as an argument.

Note: To avoid undefined behavior, ensure only one listener method is running at a time.

```
const callback = (response: FunctionsResponse) => { console.log(response) }
responseListener.listenForResponses(
  subscriptionId: number | string,
  callback,
)
```

When finished listening for responses, use the stopListeningForResponses method to stop the listener.

```
responseListener.stopListeningForResponses()
```

## Functions Utilities

### Local Functions Simulator
> The local Functions JavaScript simulator requires Deno to be installed on your machine and accessible via the PATH environment variable (confirm this by ensuring the deno --version commands).
> Visit deno.land/#installation for installation instructions.

The simulateScript function is used to simulate the execution of your custom Functions JavaScript source code on your machine. This means you can use the simulator during development to test your JavaScript code. This is useful for debugging especially since the simulateScript function returns captured terminal output which contains any console log messages or errors.

simulateScript takes an object as an argument with the following parameters shown below. Arguments can be accessed within the source code via the global variables args and bytesArgs which is are injected into the runtime. bytesArgs are useful for passing arbitrary non-string bytes values from your requesting contract; they will be represented as hex strings in the JavaScript runtime. You can also add API keys and other secrets using the secrets object that gets injected as a global variable in the runtime.

```
const result = await simulateScript({
  source: string // JavaScript source code
  args?: string[] // Array of string arguments accessible from the source code via the global variable `args`
  bytesArgs?: string[] // Array of bytes arguments, represented as hex strings, accessible from the source code via the global variable `bytesArgs`
  secrets?: Record<string, string> // Secret values represented as key-value pairs
  maxOnChainResponseBytes?: number // Maximum size of the returned value in bytes (defaults to 256)
  maxExecutionTimeMs?: number // Maximum execution duration (defaults to 10_000ms)
  maxMemoryUsageMb?: number // Maximum RAM usage (defaults to 128mb)
  numAllowedQueries?: number // Maximum number of HTTP requests (defaults to 5)
  maxQueryDurationMs?: number // Maximum duration of each HTTP request (defaults to 9_000ms)
  maxQueryUrlLength?: number // Maximum HTTP request URL length (defaults to 2048)
  maxQueryRequestBytes?: number // Maximum size of outgoing HTTP request payload (defaults to 2048 == 2 KB)
  maxQueryResponseBytes?: number // Maximum size of incoming HTTP response payload (defaults to 2_097_152 == 2 MB)
})
```

simulateScript returns a promise which resolves to an object as shown below.

```
{
  responseBytesHexstring?: string // Response bytes which would be returned on-chain, represented as a hex string
  errorString?: string // Error message that would be returned on-chain (either errorString or responseBytesHexstring will be defined)
  capturedTerminalOutput: string // stdout or stderr terminal output captured during simulated execution. Print this to view console.log messages.
}
```

Any 3rd party imports used in the JavaScript source code are loaded asynchronously at runtime. Therefore, to use 3rd party imports in the source code that is executed by the simulateScript function, you must use the async import function as shown in the examples below.

```
const { format } = await import("npm:date-fns");
return Functions.encodeString(format(new Date(), "yyyy-MM-dd"));
```

```
const { escape } = await import("https://deno.land/std/regexp/mod.ts");
return Functions.encodeString(escape("$hello*world?"));
```

NOTE: When running simulateScript, depending on your security settings, you may get a popup asking if you would like to accept incoming network connections. You can safely accept or ignore this popup and it should disappear when the simulation is complete.

NOTE: The simulateScript function is a debugging tool and hence is not a perfect representation of the actual Chainlink oracle execution environment. Therefore, it is important to make a Functions request on a supported testnet blockchain before mainnet usage.

### Local Functions Testnet
For debugging smart contracts and the end-to-end request flow on your local machine, you can use the localFunctionsTestnet function. This creates a local testnet RPC node with a mock Chainlink Functions contracts. You can then deploy your own Functions consumer contract to this local network, create and manage subscriptions, and send requests. Request processing will simulate the behavior of an actual DON where the request is executed 4 times and the discrete median response is transmitted back to the consumer contract. (Note that Chainlink Functions uses the following calculation to select the discrete median response: const medianResponse = responses[responses.length - 1) / 2]).

The localFunctionsTestnet function takes the following values as arguments.

```
const localFunctionsTestnet = await startLocalFunctionsTestnet(
  simulationConfigPath?: string // Absolute path to config file which exports simulation config parameters
  options?: ServerOptions, // Ganache server options
  port?: number, // Defaults to 8545
)
```

Observe that localFunctionsTestnet takes in a simulationConfigPath string as an optional argument. The primary reason for this is because the local testnet does not have the ability to access or decrypt encrypted secrets provided within request transactions. Instead, you can export an object named secrets from a TypeScript or JavaScript file and provide the absolute path to that file as the simulationConfigPath argument. When the JavaScript code is executed during the request, secrets specified in that file will be made accessible within the JavaScript code regardless of the secretsLocation or encryptedSecretsReference values sent in the request transaction. This config file can also contain other simulation config parameters. An example of this config file is shown below.

```
export const secrets: { test: 'hello world' } // `secrets` object which can be accessed by the JavaScript code during request execution (can only contain string values)
export const maxOnChainResponseBytes = 256 // Maximum size of the returned value in bytes (defaults to 256)
export const maxExecutionTimeMs = 10000 // Maximum execution duration (defaults to 10_000ms)
export const maxMemoryUsageMb = 128 // Maximum RAM usage (defaults to 128mb)
export const numAllowedQueries = 5 // Maximum number of HTTP requests (defaults to 5)
export const maxQueryDurationMs = 9000// Maximum duration of each HTTP request (defaults to 9_000ms)
export const maxQueryUrlLength = 2048 // Maximum HTTP request URL length (defaults to 2048)
export const maxQueryRequestBytes = 2048 // Maximum size of outgoing HTTP request payload (defaults to 2048 == 2 KB)
export const maxQueryResponseBytes = 2097152 // Maximum size of incoming HTTP response payload (defaults to 2_097_152 == 2 MB)
```

localFunctionsTestnet returns a promise which resolves to the following type.

```
{
  server: Server // Ganache server
  adminWallet: { address: string, privateKey: string } // Funded admin wallet
  getFunds: (address: string, { weiAmount, juelsAmount }: { weiAmount?: BigInt | string; juelsAmount?: BigInt | string }) => Promise<void> // Method which can be called to send funds to any address
  close: () => Promise<void> // Method to close the server
  donId: string // DON ID for simulated DON
  // The following values are all Ethers.js contract types: https://docs.ethers.org/v5/api/contract/contract/
  linkTokenContract: Contract // Mock LINK token contract
  functionsRouterContract: Contract // Mock FunctionsRouter contract
}
```

Now you can connect to the local Functions testnet RPC node with your preferred blockchain tooling, deploy a FunctionsConsumer contract, instantiate and initialize theSubscriptionManager, create, add the consumer contract and fund the subscription, send requests, and use the ResponseListener to listen for responses all on your machine.

See an example of using the localFunctionsTestnet in the Functions HardHat starter kit.

NOTE: When simulating request executions, depending on your security settings, you may get multiple popups asking if you would like to accept incoming network connections. You can safely accept or ignore these popups and they should disappear when the executions are complete.

NOTE: Cost estimates and other configuration values may differ significantly from actual values on live testnet or mainnet chains.

NOTE: The localFunctionsTestnet function is a debugging tool and hence is not a perfect representation of the actual Chainlink oracle execution environment. Therefore, it is important to make a Functions request on a supported testnet blockchain before mainnet usage.

### Decoding Response Bytes
On-chain responses are encoded as Solidity bytes which are usually displayed as hex strings. However, these hex strings often need to be decoded into a useable type. In order to decode hex strings into human-readable values, this package provides the decodeResult function. Currently, the decodeResult function supports decoding hex strings into uint256, int256 or string values.

```
const result: BigInt | string = decodeResult(
  resultHexString: string,
  expectedReturnType: ReturnType // 'uint256' | 'int256' | 'string'
)
```

Possible return values are also available in the ReturnType enum shown below.

```
export enum ReturnType {
  uint = 'uint256',
  uint256 = 'uint256',
  int = 'int256',
  int256 = 'int256',
  string = 'string',
  bytes = 'bytes',
}
```

### Storing Encrypted Secrets in Gists
When describing the use of off-chain secrets, it was mentioned the encrypted secrets JSON file could be hosted at a URL instead of uploading to DON hosted storage. One example of this is storing the encrypted secrets JSON file in a private GitHub gist. To support this common hosting method, you can use the provided createGist() and deleteGist() utilities.

First, you need to create a Github Personal Access Token. Then, you can encrypt your secrets and create a gist.

```
const encryptedSecrets = await secretsManager.encryptSecrets({
  mySecret: 'secretValue'
})
```

The encrypted secrets object produced by encryptSecrets should look similar to the object shown below.

```
{
 "encryptedSecrets": '0x1234567890abcdef', // some long hex string
}
```

Now, you can stringify this object and use it to create a gist.

```
const gistURL = await createGist(githubApiToken: string, JSON.stringify(encryptedSecrets)) // encryptedSecrets must be a string, not an object.
```

The gistURL itself must then be encrypted by calling encryptSecretsUrls() in order to produce the encryptedSecretsReference used to make a Functions request.

You can also delete gists using deleteGist().

```
const success: boolean = await deleteGist(githubApiToken: string, gistURL: string)
```

This function will return a promise which resolves to true if deletion is successful, else it will throw an error.

### Building Functions Request CBOR Bytes
Instead of performing the CBOR encoding for a Functions request on-chain in your Functions consumer contract, it is also possible to generate the CBOR encoding off-chain in order to save gas. Then, the resulting encoded CBOR bytes can be used when making an on-chain request. You can either store the encoded request in a bytes storage variable within your consumer contract, or initiate the Functions request by passing the CBOR-encoded request object bytes directly into the _sendRequest() method which is inherited from FunctionsClient.sol .

Note that when encoding a request off-chain, args or bytesArgs cannot be added to the request on-chain. This is a limitation of CBOR encoding due to its immutable structure.

To build the CBOR encoded Functions request bytes off-chain, use the buildRequestCBOR() function as shown below.

```
const functionsRequestBytesHexString: string = buildRequestCBOR({
  codeLocation: number  // Must be 0 for inline source code.  No other values are supported at this time.
  secretsLocation?: number // Must be 1 for Remote or 2 for DONHosted secrets.  No other values are supported at this time.
  codeLanguage: number // Must be 0 for JavaScript.  No other values are supported at this time.
  source: string // JavaScript source code
  encryptedSecretsReference?: string // Hex string representing an encrypted secrets URLs or DON hosted encrypted secrets reference
  args?: string[] // Array of string arguments
  bytesArgs?: string[] // Array of bytes arguments, represented as hex strings
})
```

## Browser use
This package can also be used in most modern web browsers. You can import the package in your front-end application, and call the APIs as you would in a back end NodeJs/Deno environment.

================================================================================

# Search code, repositories, users, issues, pull requests...

Source: https://github.com/smartcontractkit/ccip-javascript-sdk
Extraction Method: playwright

# CCIP JavaScript SDK

### Start here
The CCIP JavaScript SDK is a monorepo for two packages:

• ccip-js: A TypeScript library that provides a client for managing cross-chain token transfers that use Chainlink's Cross-Chain Interoperability Protocol (CCIP) routers.
• ccip-react-components: A set of prebuilt ready-to-use React UI components. This package depends on ccip-js.

Using both packages, you can add a fully featured CCIP bridge to your app that can be styled to match your app design.

To view more detailed documentation and more examples, visit the Chainlink Javascript SDK Documentation. Development specific information is also found in individual READMEs inside the ./packages/<<PACKAGE_NAME>> directory.

There is also an example implementation of a front end NextJS app that uses these packages in ./examples/nextjs. That has its own README as well.

### Prerequisites

1. Clone the ccip-javascript-sdk repo:

```
git clone https://github.com/smartcontractkit/ccip-javascript-sdk.git
```

1. Install pnpm.
2. Run pnpm install

### Run the example app

```
pnpm build
```

```
pnpm dev-example
```

### Build packages
If you want to make changes to the package code, you need to rebuild the packages.
Then:

1. Make sure to build the ccip-js package before you build the ccip-react-components package. The React components depend on the JS package.
2. Make sure your client's package.json file to points to the updated local versions or use npm link or equivalent in your downstream client code. You can see examples of this in the steps below.

Follow these steps:

1. Build the ccip-js package:

```
pnpm build-ccip-js
```

1. Build the ccip-react-components package:

```
pnpm build-components
```

1. Update the ccip-react-components package to use the local ccip-js version by modifying packages/ccip-react-components/package.json file. Replace the @chainlink/ccip-js dependency with the workspace reference:

```
"@chainlink/ccip-js": "workspace:*"
```

1. Update the examples/nextjs app to use both local ccip-js and ccip-react-components version by modifying examples/nextjs/package.json file. Replace the @chainlink/ccip-js and @chainlink/ccip-react-components dependency with relative path:

```
"@chainlink/ccip-js": "link:../../packages/ccip-js",
"@chainlink/ccip-react-components": "link:../../packages/ccip-react-components",
```

## Contributing
Contributions to either repos are welcome! Please open an issue or submit a pull request using the process below.

1. Fork the repository.
2. Clone your fork: git clone https://github.com/YOUR_USERNAME/ccip-javascript-sdk.git
3. Navigate to directory: cd ccip-javascript-sdk
4. Fetch all branches: git fetch origin
5. Switch to develop branch: git checkout develop
6. Install dependencies: pnpm install
7. Create a feature branch: git checkout -b feature/my-feature
8. Commit your changes
9. Push to the branch (git push origin feature/my-feature).
10. Open a pull request from your fork to the develop branch of this repo.

🚨 Always branch off from develop when creating your feature branch.

## Resources

• ccip-js README
• ccip-react-components README
• examples/nextjs README
• Chainlink CCIP Javascript SDK Documentation
• Chainlink CCIP Documentation
• Chainlink CCIP Directory
• Chainlink Documentation

================================================================================

## Failed Pages

- https://docs.chain.link/This document offers simple, clean, and comprehensive resources for developers to learn, experiment, and build with Chainlink.: Duplicate content
- https://docs.chain.link/ccip/supported-networks/v1_2_0/mainnet: Duplicate content
- https://docs.chain.link/ccip/supported-networks/v1_2_0/testnet: Duplicate content
- https://docs.chain.link/data-feeds/feed-registry: Duplicate content
- https://docs.chain.link/data-feeds/feed-registry/feed-registry-functions: Duplicate content
- https://docs.chain.link/data-feeds/smartdata: Duplicate content
- https://docs.chain.link/data-feeds/smartdata/addresses: Duplicate content
